package com.mservice.momo.entry;import com.google.protobuf.InvalidProtocolBufferException;import com.mservice.momo.avatar.AvatarIO;import com.mservice.momo.data.*;import com.mservice.momo.data.model.Const;import com.mservice.momo.data.model.colName;import com.mservice.momo.msg.MomoMessage;import com.mservice.momo.msg.MomoProto;import com.mservice.momo.msg.StatisticModels;import com.mservice.momo.util.DataUtil;import com.mservice.momo.util.StatisticUtils;import com.mservice.momo.util.StringConstUtil;import com.mservice.momo.vertx.AppConstant;import com.mservice.momo.vertx.data.SockData;import com.mservice.momo.vertx.models.Notification;import com.mservice.momo.vertx.models.TranObj;import com.mservice.momo.vertx.periodic.TimerLocSync;import com.mservice.momo.vertx.periodic.TimerTranSync;import com.mservice.momo.vertx.processor.*;import org.vertx.java.core.AsyncResult;import org.vertx.java.core.AsyncResultHandler;import org.vertx.java.core.Handler;import org.vertx.java.core.buffer.Buffer;import org.vertx.java.core.eventbus.Message;import org.vertx.java.core.json.JsonArray;import org.vertx.java.core.json.JsonObject;import org.vertx.java.core.logging.Logger;import org.vertx.java.core.net.NetServer;import org.vertx.java.core.net.NetSocket;import org.vertx.java.platform.Verticle;import java.util.ArrayList;import java.util.HashMap;import java.util.HashSet;import java.util.Set;import java.util.concurrent.atomic.AtomicInteger;/** * Created by admin on 2/7/14. */public class ServerVerticle extends Verticle {    public static final String MOMO_BROADCAST = "momo.broadcast";    public static final String LOAD_CFG = "LOAD_CFG";    public static final String CHANGE_CFG = "CHANGE_CFG";    public static String ARR_GROUP_CFG = "";    public static String ARR_CAPSET_CFG = "";    public static String UPPER_LIMIT_CFG = "5000000";    public static String OTP_TEMPLATE = "%s";    public static String PHONES_FOR_TEST = "";    public static boolean TEST_MODE = false;    public static boolean SEND_SMS = false;    public static String BANK_NET_BANK_CODE_BANK_NAME_SUPPORT = "";    public static boolean BANK_NET_TEST_MODE = false;    //tai khoan cua momo dung de nap tien cho khach hang    public static String VIETCOMBANK_AGENT_ADJUST_FOR_BANKNET = "";    public static String VIETTINBANK_AGENT_ADJUST_FOR_BANKNET = "";    //session and otp time-out config    public static int SESSION_TIME_OUT = 0;    public static int OTP_TIME_OUT = 0;    public static int LOGIN_MAX_COUNT = 0;    public static int TRAN_SYNC_PREV_MINUTES = 0;    public static int SERVER_PORT;    public static String SERVER_IP;    public static String AVATAR_FOLDER = "";    public static long REFERENCE_BONUS = 0;    public static int REQUEST_MONEY_MAX_PER_DAY = 0;    public static int TRAN_SYNC_INTERVAL = 0;    public static int TRAN_SYNC_SIZE = 0;    public static int LAST_SYNC_TIME = 0;    public static int LOCATION_SYNC_INTERVAL = 0;    public static int LOCATION_SYNC_SIZE = 0;    public static String AGENT_ADJUST_FOR_BANK_MANUAL = "";    public static String AGENT_ADJUST_FOR_BANK_MANUAL_FEE = "";    public static boolean IN_PROMOTION = false;    public static long NONAME_MAX_TRAN_VALUE_PER_DAY;    public static int NONAME_MAX_TRAN_COUNT_PER_DAY;    public static JsonObject ANDROID_VERSION;    public static JsonObject IOS_VERSION;    public static JsonObject WINDOWPHONE_VERSION;    public static String ZALO_GROUP = "0";    public static String ZALO_CAPSET_ID = "";    public static String ZALO_UPPER_LIMIT = "";    //tin nhan cho chuyen tien tu momo den so dien thoai    public static ArrayList<String> M2NUMBER_SMS = new ArrayList<>();    public static ArrayList<Long> M2NUMBER_AFTER_TIME = new ArrayList<>();    //tran type config when running --> default all runned    public static HashMap<Integer, Boolean> MapTranRunning = new HashMap<>();    public static HashMap<String, Long> hashDataUsers;    private static HashSet<Integer> TRANS_ACTIONS;    private static HashSet<Integer> NOT_EXPIRE_ACTIONS;    static {        MapTranRunning.put(MomoProto.TranHisV1.TranType.TOP_UP_VALUE, true);        MapTranRunning.put(MomoProto.TranHisV1.TranType.TOP_UP_GAME_VALUE, true);        MapTranRunning.put(MomoProto.TranHisV1.TranType.M2C_VALUE, true);        MapTranRunning.put(MomoProto.TranHisV1.TranType.M2M_VALUE, true);        MapTranRunning.put(MomoProto.TranHisV1.TranType.PAY_ONE_BILL_VALUE, true);        MapTranRunning.put(MomoProto.TranHisV1.TranType.QUICK_PAYMENT_VALUE, true);        MapTranRunning.put(MomoProto.TranHisV1.TranType.QUICK_DEPOSIT_VALUE, true);        MapTranRunning.put(MomoProto.TranHisV1.TranType.BANK_NET_TO_MOMO_VALUE, true);        MapTranRunning.put(MomoProto.TranHisV1.TranType.BANK_NET_VERIFY_OTP_VALUE, true);        MapTranRunning.put(MomoProto.TranHisV1.TranType.PAY_ONE_BILL_OTHER_VALUE, true);        MapTranRunning.put(MomoProto.TranHisV1.TranType.TRANSFER_MONEY_TO_PLACE_VALUE, true);        MapTranRunning.put(MomoProto.TranHisV1.TranType.BILL_PAY_TELEPHONE_VALUE, true);        MapTranRunning.put(MomoProto.TranHisV1.TranType.BILL_PAY_TICKET_AIRLINE_VALUE, true);        MapTranRunning.put(MomoProto.TranHisV1.TranType.BILL_PAY_TICKET_TRAIN_VALUE, true);        MapTranRunning.put(MomoProto.TranHisV1.TranType.BILL_PAY_INSURANCE_VALUE, true);        MapTranRunning.put(MomoProto.TranHisV1.TranType.BILL_PAY_INTERNET_VALUE, true);        MapTranRunning.put(MomoProto.TranHisV1.TranType.BILL_PAY_OTHER_VALUE, true);        MapTranRunning.put(MomoProto.TranHisV1.TranType.DEPOSIT_CASH_OTHER_VALUE, true);        MapTranRunning.put(MomoProto.TranHisV1.TranType.BUY_MOBILITY_CARD_VALUE, true);        MapTranRunning.put(MomoProto.TranHisV1.TranType.BUY_GAME_CARD_VALUE, true);        MapTranRunning.put(MomoProto.TranHisV1.TranType.BUY_OTHER_VALUE, true);        MapTranRunning.put(MomoProto.TranHisV1.TranType.DEPOSIT_CASH_VALUE, true);        MapTranRunning.put(MomoProto.TranHisV1.TranType.BILL_PAY_CINEMA_VALUE, true);        MapTranRunning.put(MomoProto.TranHisV1.TranType.MOMO_TO_BANK_MANUAL_VALUE, true);        MapTranRunning.put(MomoProto.TranHisV1.TranType.DEPOSIT_AT_HOME_VALUE, true);        MapTranRunning.put(MomoProto.TranHisV1.TranType.WITHDRAW_AT_HOME_VALUE, true);        //giao dich moi        MapTranRunning.put(MomoProto.TranHisV1.TranType.PHIM123_VALUE, true);    }    static {        NOT_EXPIRE_ACTIONS = new HashSet<Integer>();        NOT_EXPIRE_ACTIONS.add(MomoProto.MsgType.GET_OTP_VALUE);        NOT_EXPIRE_ACTIONS.add(MomoProto.MsgType.VERIFY_OTP_VALUE);        NOT_EXPIRE_ACTIONS.add(MomoProto.MsgType.REGISTER_VALUE);        NOT_EXPIRE_ACTIONS.add(MomoProto.MsgType.LOGIN_VALUE);        NOT_EXPIRE_ACTIONS.add(MomoProto.MsgType.LOG_OUT_VALUE);    }    static {        TRANS_ACTIONS = new HashSet<Integer>();        TRANS_ACTIONS.add(MomoProto.MsgType.TRANS_REQUEST_VALUE);        TRANS_ACTIONS.add(MomoProto.MsgType.TRANSFER_REQUEST_VALUE);    }    Logger logger;    PhonesDb mPhonesDb;    ImeisDb mImeisDb;    BillsDb mBillsDb;    AccessHistoryDb mAccessHistoryDb;    DeviceInfoDb mDeviceInfoDb;    AgentsDb mAgentDb;    TransDb mTranDb;    DynamicConfigDb dynamicConfigDb;    //processor    ConnectProcess connectProcess;    InfoProcess infoProcess;    MoMoInfoProcess moMoInfoProcess;    TransProcess transProcess;    BanknetProcess banknetProcess;    NotificationProcess notificationProcess;    StoreRatingProcess storeRatingProcess;    GiftProcess giftProcess;    TransferProcess transferProcess;    StatisticUtils statisticUtils;    AtomicInteger countUser;    private NotificationToolDb notificationToolDb;    private Common mCom;    private boolean isUat;    private PromotionProcess promotionProcess;    public static void LoadCfg(JsonObject config) {        ARR_GROUP_CFG = config.getObject("server").getString("arr_group_cfg", "");        ARR_CAPSET_CFG = config.getObject("server").getString("arr_capset_cfg", "");        UPPER_LIMIT_CFG = config.getObject("server").getString("upper_limit_cfg", "5000000");        OTP_TEMPLATE = config.getObject("server").getString("otp_template", "%s");        //chi test trong danh sach phone duoc cung cap trong config ma thoi        PHONES_FOR_TEST = config.getObject("server").getString("phones_test_list", "");        TEST_MODE = config.getObject("server").getBoolean("test_mode", false);        SEND_SMS = config.getObject("server").getBoolean("send_sms", true);        VIETCOMBANK_AGENT_ADJUST_FOR_BANKNET = config.getObject("server").getString("vietcombank_adjust_for_banknet", "0"); // duoc su dung lam tai khoan adjustment khi chuyen tien tu banknet -->momo        VIETTINBANK_AGENT_ADJUST_FOR_BANKNET = config.getObject("server").getString("viettinbank_adjust_for_banknet", "0"); // duoc su dung lam tai khoan adjustment khi chuyen tien tu banknet -->momo        BANK_NET_TEST_MODE = config.getObject("server").getBoolean("bank_net_test_mode", false);        BANK_NET_BANK_CODE_BANK_NAME_SUPPORT = config.getObject("bank_net").getString("bank_support");        SESSION_TIME_OUT = config.getObject("server").getInteger("session_time_out", 20);        OTP_TIME_OUT = config.getObject("server").getInteger("otp_time_out", 10);        LOGIN_MAX_COUNT = config.getObject("server").getInteger("login_max_try", 3);        TRAN_SYNC_PREV_MINUTES = config.getObject("server").getInteger("tran_sync_prev_minutes", 10);        SERVER_PORT = config.getObject("server").getInteger("app_port", 9443);        SERVER_IP = config.getObject("server").getString("app_ip", "0.0.0.0");//        AVATAR_FOLDER = config.getObject("avatar").getString("folder","home/");        REFERENCE_BONUS = config.getObject("server").getLong("ref_bonus", 0);        REQUEST_MONEY_MAX_PER_DAY = config.getObject("server").getInteger("request_money_per_day", 5);        TRAN_SYNC_INTERVAL = config.getObject("sync_time").getInteger("tran_interval");        TRAN_SYNC_SIZE = config.getObject("sync_time").getInteger("tran_size");        LOCATION_SYNC_INTERVAL = config.getObject("sync_time").getInteger("loc_interval");        LOCATION_SYNC_SIZE = config.getObject("sync_time").getInteger("loc_size");        //tai khoan dung de treo tien setting cho chuyen tien qua ngan hang khong lien ket        AGENT_ADJUST_FOR_BANK_MANUAL = config.getObject("bank_manual").getString("agent_adjust_manual", "bankoutmanual");        AGENT_ADJUST_FOR_BANK_MANUAL_FEE = config.getObject("bank_manual").getString("agent_adjust_manual_fee", "bankoutmanualfee");        IN_PROMOTION = config.getObject("server").getBoolean("in_promotion", true);        NONAME_MAX_TRAN_VALUE_PER_DAY = config.getObject("server").getLong("noname_tran_max_value_per_day", 1000000);        NONAME_MAX_TRAN_COUNT_PER_DAY = config.getObject("server").getInteger("noname_max_tran_count_per_day", 15);        M2NUMBER_SMS.add(config.getObject("sms_for_m2number").getString("sms1", ""));        M2NUMBER_SMS.add(config.getObject("sms_for_m2number").getString("sms2", ""));        M2NUMBER_SMS.add(config.getObject("sms_for_m2number").getString("sms3", ""));        M2NUMBER_SMS.add(config.getObject("sms_for_m2number").getString("sms4", ""));        M2NUMBER_AFTER_TIME.add(config.getObject("sms_for_m2number").getLong("after1time", 24));        M2NUMBER_AFTER_TIME.add(config.getObject("sms_for_m2number").getLong("after2time", 36));        M2NUMBER_AFTER_TIME.add(config.getObject("sms_for_m2number").getLong("after3time", 48));        ANDROID_VERSION = config.getObject("mobiapp_version").getObject("android");        IOS_VERSION = config.getObject("mobiapp_version").getObject("ios");        WINDOWPHONE_VERSION = config.getObject("mobiapp_version").getObject("windowphone");        ZALO_GROUP = config.getObject("server").getString("zalo_group");        ZALO_CAPSET_ID = config.getObject("server").getString("zalo_capset_id");        ZALO_UPPER_LIMIT = config.getObject("server").getString("zalo_upper_limit");    }    private void loadChildrenCfg(JsonObject glbCfg) {        //load config for Location sync        TimerLocSync.loadCfg(LOCATION_SYNC_INTERVAL, LOCATION_SYNC_SIZE);        //load config for Transaction sync        TimerTranSync.loadCfg(TRAN_SYNC_INTERVAL, TRAN_SYNC_SIZE);        //load config for request money        ReqMoney.loadCfg(REQUEST_MONEY_MAX_PER_DAY);        //setting for phonesDB        PhonesDb.LOGIN_MAX_COUNT = LOGIN_MAX_COUNT;        //setting for TranDB        TranObj.TRAN_SYNC_PREV_MINUTES = TRAN_SYNC_PREV_MINUTES;        logger = container.logger();        logger.info("Danh sasch phones duoc test : " + PHONES_FOR_TEST);        logger.info("Test Mode status : " + TEST_MODE);        logger.info("SESSION TIME-OUT : " + SESSION_TIME_OUT);        logger.info("OTP TIME-OUT : " + OTP_TIME_OUT);        logger.info("Server starting in folder : " + System.getProperty("user.dir"));        mPhonesDb = new PhonesDb(vertx.eventBus(), container.logger());        mImeisDb = new ImeisDb(vertx.eventBus());        mBillsDb = new BillsDb(vertx.eventBus());        mAccessHistoryDb = new AccessHistoryDb(vertx.eventBus());        mDeviceInfoDb = new DeviceInfoDb(vertx.eventBus());        mAgentDb = new AgentsDb(vertx.eventBus(), logger);        mTranDb = DBFactory.createTranDb(vertx, vertx.eventBus(), logger, container.config());        notificationProcess = new NotificationProcess(vertx, container);        storeRatingProcess = new StoreRatingProcess(vertx, container);        mCom = new Common(vertx, logger, container.config());        //setting for connect process        ConnectProcess.TEST_MODE = TEST_MODE;        ConnectProcess.SESSION_TIME_OUT = SESSION_TIME_OUT;        ConnectProcess.OTP_TIME_OUT = OTP_TIME_OUT;        ConnectProcess.OTP_TEMPLATE = OTP_TEMPLATE;        ConnectProcess.ARR_GROUP_CFG = ARR_GROUP_CFG;        ConnectProcess.ARR_CAPSET_CFG = ARR_CAPSET_CFG;        ConnectProcess.UPPER_LIMIT_CFG = UPPER_LIMIT_CFG;        ConnectProcess.SEND_SMS = SEND_SMS;        ConnectProcess.LOGIN_MAX_COUNT = LOGIN_MAX_COUNT;        ConnectProcess.VIETCOMBANK_AGENT_ADJUST_FOR_BANKNET = VIETCOMBANK_AGENT_ADJUST_FOR_BANKNET;        ConnectProcess.VIETTINBANK_AGENT_ADJUST_FOR_BANKNET = VIETTINBANK_AGENT_ADJUST_FOR_BANKNET;        ConnectProcess.REFERENCE_BONUS = REFERENCE_BONUS;        ConnectProcess.ZALO_GROUP = ZALO_GROUP;        ConnectProcess.ZALO_CAPSET_ID = ZALO_CAPSET_ID;        ConnectProcess.ZALO_UPPER_LIMIT = ZALO_UPPER_LIMIT;        connectProcess = new ConnectProcess(vertx, logger, glbCfg);        transProcess = new TransProcess(vertx, logger, container.config());        //setting for info process        InfoProcess.REQUEST_MONEY_MAX_PER_DAY = REQUEST_MONEY_MAX_PER_DAY;        InfoProcess.NONAME_MAX_TRAN_COUNT_PER_DAY = NONAME_MAX_TRAN_COUNT_PER_DAY;        InfoProcess.NONAME_MAX_TRAN_VALUE_PER_DAY = NONAME_MAX_TRAN_VALUE_PER_DAY;        infoProcess = new InfoProcess(vertx, logger, glbCfg);        infoProcess.setDynamicConfigDb(dynamicConfigDb);        moMoInfoProcess = new MoMoInfoProcess(vertx, logger, glbCfg);        //setting for bank-net handler        BanknetProcess.BANK_NET_BANK_CODE_BANK_NAME_SUPPORT = BANK_NET_BANK_CODE_BANK_NAME_SUPPORT;        BanknetProcess.VIETCOMBANK_AGENT_ADJUST_FOR_BANKNET = VIETCOMBANK_AGENT_ADJUST_FOR_BANKNET;        BanknetProcess.VIETTINBANK_AGENT_ADJUST_FOR_BANKNET = VIETTINBANK_AGENT_ADJUST_FOR_BANKNET;        BanknetProcess.BANK_NET_TEST_MODE = BANK_NET_TEST_MODE;        banknetProcess = new BanknetProcess(vertx, logger, glbCfg);        //setting for broadcast handler        BroadcastHandler.IN_PROMOTION = IN_PROMOTION;        BroadcastHandler.NONAME_MAX_TRAN_VALUE_PER_DAY = NONAME_MAX_TRAN_VALUE_PER_DAY;        //for transfer application        TransferProcess.BANK_NET_TEST_MODE = BANK_NET_TEST_MODE;        transferProcess = new TransferProcess(vertx                , logger                , glbCfg                , MapTranRunning);        //setting for AVATAR        AvatarIO.folder = AVATAR_FOLDER;        //load config for chuyen tien qua ngan hang khong lien ket//        Cashdeposit.AGENT_ADJUST_FOR_BANK_MANUAL=AGENT_ADJUST_FOR_BANK_MANUAL;//        Cashdeposit.AGENT_ADJUST_FOR_BANK_MANUAL_FEE=AGENT_ADJUST_FOR_BANK_MANUAL_FEE;        //setting for transfer common        /*TransferCommon.vertx=vertx;        TransferCommon.logger=logger;        TransferCommon.BANK_NET_TEST_MODE = BANK_NET_TEST_MODE;        TransferCommon.VIETCOMBANK_AGENT_ADJUST_FOR_BANKNET = VIETCOMBANK_AGENT_ADJUST_FOR_BANKNET;        TransferCommon.VIETTINBANK_AGENT_ADJUST_FOR_BANKNET = VIETTINBANK_AGENT_ADJUST_FOR_BANKNET;        TransferCommon.InitObjs();*/        //setting for feeDB        FeeCollection.setFeeDb(new FeeDb(vertx, logger));        FeeCollection.getInstance().initData();        dynamicConfigDb = new DynamicConfigDb(vertx, container);        infoProcess.setDynamicConfigDb(dynamicConfigDb);        //tam dung dich vu nap rut tan noi        boolean paused = glbCfg.getBoolean("allow_nap_rut_tan_noi", false);        MapTranRunning.put(MomoProto.TranHisV1.TranType.DEPOSIT_AT_HOME_VALUE, paused);        MapTranRunning.put(MomoProto.TranHisV1.TranType.WITHDRAW_AT_HOME_VALUE, paused);        statisticUtils = new StatisticUtils(vertx, container.logger(), glbCfg);        giftProcess = new GiftProcess(mCom, vertx, logger, glbCfg);        isUat = glbCfg.getBoolean(StringConstUtil.IS_UAT, false);        hashDataUsers = new HashMap<>();//        // start gift transaction rollback timer.//        logger.info("GiftRollback");//        new GiftRollback(vertx, logger, glbCfg);////        // start timer scan gifts will be sent out withtimed//        logger.info("SendGiftTimer");//        new SendGiftTimer(vertx, logger, glbCfg);////        //start timer scan gifts will be expired//        logger.info("ExpiredGiftTimer");//        new ExpiredGiftTimer(vertx, logger, glbCfg);////        // start timer scan gifts will be reminded to used//        logger.info("GiftRemindTimer");//        new GiftRemindTimer(vertx, logger, glbCfg);        promotionProcess = new PromotionProcess(vertx, logger, glbCfg);        countUser = new AtomicInteger(0);        notificationToolDb = new NotificationToolDb(vertx, logger);    }    public void start() {        final JsonObject glbCfg = container.config();        LoadCfg(glbCfg);        //load all children modules config        loadChildrenCfg(glbCfg);        //get some config        NetServer server = vertx.createNetServer();        //setup the connection properties        server.setTCPNoDelay(true); //If true then Nagle's Algorithm is disabled. If false then it is enabled.        server.setSendBufferSize(2048); // Sets the TCP send buffer size in bytes.        server.setReceiveBufferSize(2048); //Sets the TCP receive buffer size in bytes.        server.setTCPKeepAlive(true); // if keepAlive is true then TCP keep alive is enabled, if false it is disabled.        server.setReuseAddress(true);  // if reuse is true then addresses in TIME_WAIT state can be reused after they have been closed.        server.setSSL(true);        server.setAcceptBacklog(100000);        server.setClientAuthRequired(false);        server.setUsePooledBuffers(true);        server.setSoLinger(0);        //todo convert this to config        //server.set`KeyStorePath("mservice_keystore.jks");        //server.setKeyStorePassword("m5erv1c3##123$$");        //server.setKeyStorePath("Certificates.jks");        //server.setKeyStorePassword("MomoApp");        server.setKeyStorePath("appmomo1.jks");//        server.setKeyStorePassword("frontendmomo");        server.setKeyStorePassword("payment_momo");        /*        SSLContext sslContext =        server.setSSLContext(new SSLContext())*/        //setSoLinger(linger) ==> still dont know what for        //setTrafficClass(trafficClass) ==> still dont know what for        server.connectHandler(new Handler<NetSocket>() {            public void handle(final NetSocket sock) {                logger.info("New client: " + sock.remoteAddress().toString() + " has socket handlerId" + sock.writeHandlerID());                StatisticUtils.fireNewConnection(vertx.eventBus(), StatisticModels.Action.Channel.MOBILE);                countUser.incrementAndGet();                logger.info("NUMBER OF USER COUNT "  + countUser.intValue());                //ConcurrentMap<NetSocket, Long> HELLO_MAP = vertx.sharedData().getMap("map.hello");                final SockData data = new SockData(vertx, logger, glbCfg);                data.start_access_time = System.currentTimeMillis();                String orgIpAcc = sock.remoteAddress().toString();                String ipOrg = orgIpAcc.split(":")[0];                data.ip = (ipOrg.indexOf("/") == 0 ? ipOrg.substring(1, ipOrg.length() - 1) : ipOrg);                data.sockId = sock.writeHandlerID();                final HashMap<String, SockData> hashMapSockData = new HashMap<String, SockData>();                sock.dataHandler(new Handler<Buffer>() {                    public void handle(Buffer buffer) {                        final MomoMessage msg = MomoMessage.fromBuffer(buffer);                        if (msg == null) {                            mCom.logInfoForSock(sock, "rcv wrong message", data);                            mCom.writeErrorToSocket(sock);                            return;                        }                        hashDataUsers.put("" + msg.cmdIndex, System.currentTimeMillis());                        logger.info("NUMBER OF USERS: " + hashDataUsers.size());                        final MomoProto.MsgType type = MomoProto.MsgType.valueOf(msg.cmdType);                        if (type == null) {                            mCom.logInfoForSock(sock, "rcv unknown message type " + msg.cmdType + " return ", data);                            return;                        } else {                            logger.debug(msg + "rcv " + type);//                          logger.info(sock.remoteAddress().toString() + "> received msg type " + type.name() + " - phone " + msg.cmdPhone);                        }                        logger.info("NUMBER OF USERS: " + hashDataUsers.size() + " MSG_TYPE " + type + "_" + msg.cmdType + " NUMBER " + msg.cmdPhone + " SOCK_ID " + sock.writeHandlerID());                        //send this msg to make sure, the connection will be exist for a long time                        final AtomicInteger atomicCount = new AtomicInteger(3);                        MomoProto.TranHisV1 request = null;                        if(msg.cmdType == MomoProto.MsgType.TRANS_REQUEST_VALUE || msg.cmdType == MomoProto.MsgType.TRANSFER_REQUEST_VALUE)                        {                            try {                                request = MomoProto.TranHisV1.parseFrom(msg.cmdBody);                            } catch (InvalidProtocolBufferException e) {                                e.printStackTrace();                            }                        }                        final MomoProto.TranHisV1 fRequest = request;                        vertx.setPeriodic(10000L, new Handler<Long>() {                            @Override                            public void handle(Long checkUserTimer) {                                if(atomicCount.intValue() == 0)                                {                                    vertx.cancelTimer(checkUserTimer);                                    if(fRequest != null){                                        logger.info(" ALERT 3 TIMES NOT WRITE DATA TO NUMBER " + msg.cmdPhone + " INDEX: " + msg.cmdIndex + " MSG_TYPE " + type + "_" + msg.cmdType + " TRANTYPE " + fRequest.getTranType());                                    }                                    else{                                        logger.info(" ALERT 3 TIMES NOT WRITE DATA TO NUMBER " + msg.cmdPhone + " INDEX: " + msg.cmdIndex + " MSG_TYPE " + type + "_" + msg.cmdType);                                    }                                }                                else if(hashDataUsers.containsKey("" + msg.cmdIndex))                                {                                    logger.info("NOT WRITE DATA TO NUMBER " + msg.cmdPhone + " INDEX: " + msg.cmdIndex + " MSG_TYPE " + type + "_" + msg.cmdType + (fRequest != null ? " TRANTYPE " + fRequest.getTranType() : ""));                                    atomicCount.decrementAndGet();                                }                                else {                                    vertx.cancelTimer(checkUserTimer);                                }                            }                        });                        if (msg.cmdType == MomoProto.MsgType.ECHO_VALUE) {                            SockData sockData = new SockData(vertx, logger, glbCfg);//                            promotionProcess.getUserInfoToCheckPromoProgram("", "0"+msg.cmdPhone, null, 0, 0, 0, "ECHO", sockData, new JsonObject());                            mCom.writeEchoReply(sock, msg);                            return;                        }                        if (msg.cmdType == MomoProto.MsgType.HELLO_VALUE) {                            //hello is a very special case                            MomoProto.Hello hello;                            try {                                hello = MomoProto.Hello.parseFrom(msg.cmdBody);                            } catch (InvalidProtocolBufferException e) {                                hello = null;                                logger.debug(msg + "hello == null" + e.getMessage());                            }                            if (hello != null) {                                logger.debug("imei " + hello.getImei() == null ? "" : hello.getImei());                                logger.debug("imei_key " + hello.getImeiKey() == null ? "" : hello.getImeiKey());                                logger.debug("session_key " + hello.getSessionKey() == null ? "" : hello.getSessionKey());                            }                            if (hello == null || !hello.hasImei()) {                                mCom.writeErrorToSocket(sock);                                return;                            }                            data.hello = true;                            data.imei = hello.getImei();                            connectProcess.processHello(sock, msg, data, hello);                        } else {                            //app moi toanh, chua cai dat, setup gi ca...                            if (msg.cmdType == MomoProto.MsgType.GET_SERVICE_BY_SERVICE_ID_VALUE) {                                infoProcess.getServicesByServiceId(sock, msg, null);                            } else if (msg.cmdType == MomoProto.MsgType.GET_SERVICE_BY_LAST_TIME_VALUE) {                                infoProcess.getServicesByLastTime(sock, msg, null);                            } else {                                if(!Misc.checkNumber(msg.cmdPhone) && MomoProto.MsgType.PHONE_EXIST_VALUE == msg.cmdType)                                {                                    final MomoProto.AgentInfo.Builder replyBuilder = MomoProto.AgentInfo.newBuilder();                                    replyBuilder.setResult(false)                                            .setName("")                                            .setCardId("")                                            .addListKeyValue(MomoProto.TextValue.newBuilder().setText(StringConstUtil.DESCRIPTION)                                                    .setValue("Số điện thoại không hợp lệ"))                                            .setRegStatus(MomoProto.RegStatus.newBuilder()                                                            .setIsReged(false)                                                            .setIsNamed(false)                                                            .setIsActive(false)                                                            .setIsSetup(false)                                                            .setIsStopped(false)                                                            .setIsSuppend(false)                                                            .setIsFrozen(false)                                            );                                    Buffer bufferLocal = MomoMessage.buildBuffer(                                            MomoProto.MsgType.PHONE_EXIST_REPLY_VALUE,                                            msg.cmdIndex,                                            msg.cmdPhone,                                            replyBuilder.build().toByteArray()                                    );                                    mCom.writeDataToSocket(sock, bufferLocal);                                    return;                                }                                else if (!Misc.checkNumber(msg.cmdPhone)) {                                    mCom.writeErrorToSocket(sock                                            , MomoProto.SystemError.NUMBER_NOT_VALID_VALUE, "");                                    return;                                }                                if (!data.hello) {                                    mCom.writeErrorToSocket(sock                                            , MomoProto.SystemError.NOT_HELLO_YET_VALUE, "");                                    return;                                }                                //kiem tra session                                if (TRANS_ACTIONS.contains(msg.cmdType) && !preCheckTranRequest(msg, sock, data)) {                                    return;                                }                                //lenh thuc hien giao dich                                //neu cache data  null hoac pin == "" --> return                                if (TRANS_ACTIONS.contains(msg.cmdType)) {                                    if (data == null || data.getPhoneObj() == null || "".equalsIgnoreCase(data.pin)) {                                        logger.info("0" + msg.cmdPhone +                                                " trantype " +                                                MomoProto.MsgType.valueOf(msg.cmdType).name() +                                                " data == null || data.pin is empty");                                        Buffer buf = Misc.buildSessionExpired(msg);                                        mCom.writeDataToSocket(sock, buf);                                    } else {//                                        logger.info("index khi goi vao backend " + msg.cmdIndex + "");//                                        logger.info("startProcess khi goi vao backend ");                                        startProcess(msg, sock, data);                                    }                                } else {                                    //thuc hien cac loai lenh khac//                                    logger.info("index khi goi vao backend " + msg.cmdIndex + "");//                                    logger.info("startProcess khi goi vao backend ");                                    startProcess(msg, sock, data);                                }                            }                        }                    }                });//---------------------------------------------------------------------                sock.closeHandler(new Handler<Void>() {                    @Override                    public void handle(Void aVoid) {                        //send sms for incoming alert                        mCom.logInfoForSock(sock, "-disconnected", data);                        countUser.decrementAndGet();//                        logger.info("NUMBER OF USER COUNT "  + countUser.intValue());                        data.closeData(vertx.eventBus(), logger);                        StatisticUtils.fireCloseConnection(vertx.eventBus(), StatisticModels.Action.Channel.MOBILE);                        if (data != null) {                            connectProcess.removeConnection(data.getNumber());                        }                    }                });                sock.exceptionHandler(new Handler<Throwable>() {                    public void handle(Throwable t) {                        if (data != null) {                            logger.debug("Client socket exception -> close this, info " + sock.remoteAddress().toString() + "-" + data.getNumber(), t);                            connectProcess.removeConnection(data.getNumber());                        } else {                            logger.debug("Client socket exception -> close this, info " + sock.remoteAddress().toString(), t);                        }                        countUser.decrementAndGet();                        //luu lich su truy cap                        if (!"".equalsIgnoreCase(data.deviceModel)) {                            mAccessHistoryDb.saveAccessTime(                                    data.getNumber()                                    , data.ip                                    , data.start_access_time                                    , data.deviceModel, new Handler<Boolean>() {                                        @Override                                        public void handle(Boolean o) {                                            logger.debug("TRACK ACCESS INFOR WHEN DISCONNECT " + o);                                        }                                    }                            );                        }                        sock.close();                    }                });            }        });// -------------------------------------------------------------------------------------        server.listen(SERVER_PORT, SERVER_IP, new AsyncResultHandler<NetServer>() {            public void handle(AsyncResult<NetServer> asyncResult) {                logger.info("Server started succeeded on ip,port " + SERVER_IP + "," + SERVER_PORT + asyncResult.succeeded());                if (!asyncResult.succeeded()) {                    logger.error("Can not listen on ip,port : " + SERVER_IP + "," + SERVER_PORT, asyncResult.cause());                }            }        });        //        Handler<Message<JsonObject>> changeCfgHandler = new Handler<Message<JsonObject>>() {            @Override            public void handle(Message<JsonObject> message) {                JsonObject jo = message.body();                String task = jo.getString(colName.CfgAtRuning.TASK, "");                switch (task) {                    case Const.SET_TRAN_SERVICE_STATUS:                        changeTranTypeStatus(jo, message);                        break;                    case Const.GET_ALL_TRAN_SERVICE_STATUS:                        getAllTranServiceStatus(message);                        break;                    case Const.TASK_CONFIG:                        //todo change server config                        break;                    default:                        logger.warn("TASK: " + task + " is not supported");                        break;                }            }        };        vertx.eventBus().registerLocalHandler(CHANGE_CFG, changeCfgHandler);    }    private void startProcess(final MomoMessage msg, final NetSocket sock, final SockData data) {        switch (msg.cmdType) {            case MomoProto.MsgType.CREATE_TOKEN_VALUE:                infoProcess.createVMCardToken(sock, msg, data);                break;            case MomoProto.MsgType.WALLET_MAP_VALUE:                infoProcess.mapWallet(sock, msg, data);                break;            case MomoProto.MsgType.DELETE_TOKEN_VALUE:                infoProcess.deleteVMCardToken(sock, msg, data);                break;            case MomoProto.MsgType.GET_CARD_LIST_VALUE:                infoProcess.getVisaMasterCardList(sock, msg, data);                break;            case MomoProto.MsgType.GET_CARD_TYPE_VALUE:                infoProcess.getCardType(sock, msg, null);                break;            case MomoProto.MsgType.GET_LIQUIDITY_VALUE:                infoProcess.getRetailerLiquidity(sock, msg, data);                break;            case MomoProto.MsgType.GET_OTP_FOR_CLIENT_VALUE:                infoProcess.processGetOtpForClient(sock, msg, data);                break;            case MomoProto.MsgType.GET_C2C_INFO_VALUE:                infoProcess.processGetC2cInfo(sock, msg, data);                break;            case MomoProto.MsgType.GET_OTP_VALUE:                connectProcess.processGetOtp(sock, msg, data);                break;            case MomoProto.MsgType.VERIFY_OTP_VALUE:                connectProcess.processVerifyOtp(sock, msg, data);                break;            case MomoProto.MsgType.REGISTER_VALUE:                connectProcess.processRegister(sock, msg, data);                break;            case MomoProto.MsgType.LOGIN_VALUE:                connectProcess.processLogIn(sock, msg, data, null);                break;            case MomoProto.MsgType.LOG_OUT_VALUE:                connectProcess.processLogOut(sock, msg, data);                break;            case MomoProto.MsgType.PHONE_EXIST_VALUE:                infoProcess.processCheckPhone(sock, msg);                break;            case MomoProto.MsgType.TRANS_REQUEST_VALUE:                processTranRequest(sock, msg, data);                break;            case MomoProto.MsgType.GET_BILL_INFO_VALUE:                infoProcess.processGetBillInfo(sock, msg, data, null);                break;            case MomoProto.MsgType.CHANGE_PIN_VALUE:                connectProcess.processChangePin(sock, msg, data);                break;            case MomoProto.MsgType.WHO_IS_MOMOER_VALUE:                infoProcess.processWhoIsMomoer(sock, msg);                break;            case MomoProto.MsgType.GET_ACCESS_HISTORY_VALUE:                infoProcess.processGetAccessHistory(sock, msg);                break;            case MomoProto.MsgType.DEVICE_INFO_VALUE:                infoProcess.processSaveDeviceInfo(sock, msg, data);                break;            case MomoProto.MsgType.STORE_LOCATION_SYNC_VALUE:                infoProcess.processSyncStoreLocation(sock, msg);                break;            case MomoProto.MsgType.MONEY_REQUEST_VALUE:                infoProcess.processMoneyRequest(sock, msg, data);                break;            case MomoProto.MsgType.TRAN_SYNC_VALUE:                infoProcess.processTranSync(sock, msg);                break;            case MomoProto.MsgType.BANK_NET_TO_MOMO_VALUE:                infoProcess.processBanknetCheckInfo(sock, msg, data, null);                break;            case MomoProto.MsgType.TRAN_STATISTIC_PER_DAY_VALUE:                infoProcess.processTranStatistic(sock, msg, data);                break;            case MomoProto.MsgType.GET_FEE_VALUE:                infoProcess.processGetFee(sock, msg);                break;            case MomoProto.MsgType.GET_MIN_MAX_TRAN_VALUE:                infoProcess.processGetMinMaxTran(sock, msg, null);                break;            //Nhan thong tin xac nhan co map vi tiep hay khong            ////BEGIN 0000000026 Test gui thong tin de ban popup MAPVI            case MomoProto.MsgType.CONFIRM_WALLET_MAPPING_VALUE:                moMoInfoProcess.getWalletConfirmInfo(sock, msg, data);                break;            //END 0000000026 Test gui thong tin de ban popup MAPVI            //transfer.start            case MomoProto.MsgType.TRANSFER_REQUEST_VALUE:                transferProcess.execTransfer(sock, msg, data, null);                break;            case MomoProto.MsgType.CARD_ADD_OR_UPDATE_VALUE:                infoProcess.processAddOrUpdate(sock, msg);                break;            case MomoProto.MsgType.CARD_SYNC_VALUE:                infoProcess.processCardSyncAtFirstTime(sock, msg);                break;            case MomoProto.MsgType.AGENT_MODIFY_VALUE:                infoProcess.processAgentModify(sock, msg, data, null);                break;            case MomoProto.MsgType.AVATAR_UPLOAD_VALUE:                infoProcess.processAvatarUpload(sock, msg);                break;            case MomoProto.MsgType.REMOVE_SAVED_BILL_VALUE:                infoProcess.processRemoveSavedBill(sock, msg);                break;            case MomoProto.MsgType.NOTIFICATION_RECEIVED_VALUE:                removePendingNotification(sock, data, msg);                break;            case MomoProto.MsgType.UPDATE_NOTIFICATIONS_STATUS_VALUE:                notificationProcess.updateNotificationsStatus(sock, data, msg);                break;            case MomoProto.MsgType.NOTIFICATION_SYNC_VALUE:                infoProcess.syncNotification(sock, data, msg);                break;            case MomoProto.MsgType.TRAN_DELETE_VALUE:                infoProcess.processDeleteTrans(sock, msg, null);                break;            case MomoProto.MsgType.BANKNET_VERIFY_OTP_VALUE:                transProcess.processBanknetVerifyOtp(sock, msg, data, null);                break;            //transfer.end            case MomoProto.MsgType.CHECK_TRAN_STATUS_VALUE:                infoProcess.checkTranStatus(sock, msg);                break;            case MomoProto.MsgType.GET_DYNAMIC_CONFIG_VALUE:                infoProcess.getDynamicConfig(sock, msg);                break;            case MomoProto.MsgType.CREATE_ORDER_123PHIM_VALUE:                infoProcess.createOrder123Phim(sock, msg, data, null);                break;            case MomoProto.MsgType.GET_PROMOTION_VALUE:                infoProcess.getPromotionList(sock, msg);                break;            case MomoProto.MsgType.GET_PROMOTION_DETAIL_VALUE:                infoProcess.getPromotionDetail(sock, msg);                break;            case MomoProto.MsgType.INVITE_STATISTIC_VALUE:                infoProcess.getInviteeStatistic(sock, msg);                break;            case MomoProto.MsgType.GET_SMARTLINK_URL_VALUE:                infoProcess.getSmartlinkUrl(sock, msg);                break;            case MomoProto.MsgType.GET_SERVICE_VALUE:                infoProcess.getServices(sock, msg, null);                break;            case MomoProto.MsgType.GET_SERVICE_LAYOUT_VALUE:                infoProcess.getServiceLayout(sock, msg, data, null);                break;            case MomoProto.MsgType.GET_NOTIFICAITON_VALUE:                infoProcess.getNotification(sock, msg, data, null);                break;            case MomoProto.MsgType.GET_SERVICE_BY_LAST_TIME_VALUE:                infoProcess.getServicesByLastTime(sock, msg, null);                break;            case MomoProto.MsgType.GET_SERVICE_BY_SERVICE_ID_VALUE:                infoProcess.getServicesByServiceId(sock, msg, null);                break;            case MomoProto.MsgType.GET_PROMO_VALUE:                transProcess.processGetPromo(sock, msg, null);                break;            case MomoProto.MsgType.STORE_COMMENT_CRUD_VALUE:                storeRatingProcess.commentCrud(sock, msg, data, null);                break;            case MomoProto.MsgType.GET_STORE_RATE_VALUE:                storeRatingProcess.getStoreRate(sock, msg, null);                break;            case MomoProto.MsgType.GET_STORE_COMMENT_PAGE_VALUE:                storeRatingProcess.getStoreCommentPage(sock, msg, null);                break;            case MomoProto.MsgType.GET_STORE_WARNING_TYPE_VALUE:                storeRatingProcess.getStoreWarningTypes(sock, msg, null);                break;            case MomoProto.MsgType.WARN_STORE_VALUE:                storeRatingProcess.warnStore(sock, msg, null);                break;            case MomoProto.MsgType.GET_USER_SETTING_VALUE:                infoProcess.getUserSetting(sock, msg, data, null);                break;            case MomoProto.MsgType.SET_USER_SETTING_VALUE:                infoProcess.setUserSetting(sock, msg, data, null);                break;            case MomoProto.MsgType.GIFT_CLAIM_VALUE:                giftProcess.giftClaim(sock, msg, data, null);                break;            case MomoProto.MsgType.GET_GIFT_TYPE_VALUE:                giftProcess.getGiftType(sock, msg, data, null);                break;            case MomoProto.MsgType.GET_GIFT_VALUE:                giftProcess.getGift(sock, msg, data, null);                break;            case MomoProto.MsgType.SET_GIFT_STATUS_VALUE:                giftProcess.setGiftStatus(sock, msg, data, null);                break;            case MomoProto.MsgType.SEND_GIFT_MESSAGE_VALUE:                giftProcess.sendGiftMessage(sock, msg, data, null);                break;            case MomoProto.MsgType.GET_AGENT_INFO_VALUE:                infoProcess.processGetAgentInfo(sock, msg);                break;            case MomoProto.MsgType.CLEAR_ALL_NOTI_VALUE:                infoProcess.clearAllNoti(sock, msg);                break;            /*case MomoProto.MsgType.FTP_INFO_VALUE:                infoProcess.processGetFtpInfo(sock, msg);                break;*/            case MomoProto.MsgType.CHECK_BILL_VALUE:                infoProcess.validateBill(sock, msg, data, null);                break;            case MomoProto.MsgType.USE_GIFT_VALUE:                giftProcess.useGift(sock, msg, data, null);                break;            case MomoProto.MsgType.CAN_USE_GIFT_VALUE:                giftProcess.canUseGift(sock, msg, data, null);                break;            case MomoProto.MsgType.GET_TRAN_CONFIRM_INFO_VALUE:                giftProcess.getTranConfirmInfo(sock, msg, data, null);                break;            case MomoProto.MsgType.ADD_FIELD_VALUE:                infoProcess.addFields(sock, msg, data, null);                break;            case MomoProto.MsgType.GET_FORM_FIELDS_VALUE:                infoProcess.getFormFields(sock, msg, null);                break;            case MomoProto.MsgType.SUBMIT_FORM_VALUE:                infoProcess.processSubmitForm(sock, msg, data, null);                break;            case MomoProto.MsgType.GET_VALUE_FOR_DROPBOX_VALUE:                infoProcess.getValueForDropByParentId(sock, msg, null);                break;            case MomoProto.MsgType.GET_CATEGORY_VALUE:                infoProcess.getCategory(sock, msg, null);                break;            case MomoProto.MsgType.TRANSLATE_CONFIRM_INFO_VALUE:                infoProcess.translateForm(sock, msg, data, null);                break;            case MomoProto.MsgType.MUST_UPDATE_INFO_VALUE:                infoProcess.mustUpdateAgentInfo(sock, msg, data, null);                break;            case MomoProto.MsgType.DGD_GET_FEE_VALUE:                infoProcess.getRetailerFee(sock, msg, null);                break;            case MomoProto.MsgType.GET_BALANCE_VALUE:                infoProcess.processGetBalance(sock, msg, data, null);                break;            case MomoProto.MsgType.GET_FEE_BANK_VALUE:                infoProcess.processGetFeeFromBank(sock, msg);                break;            case MomoProto.MsgType.CHECK_USER_RESET_PASSWORD_VALUE:                moMoInfoProcess.checkUserResetPassword(sock, msg, data);                break;            case MomoProto.MsgType.RESET_PASSWORD_VALUE:                moMoInfoProcess.resetPinForPoorUser(sock, msg, data);                break;            case MomoProto.MsgType.SEND_EMAIL_VALUE:                moMoInfoProcess.sendEmail(sock, msg, data);                break;            case MomoProto.MsgType.BUILD_URL_NAPAS_VALUE:                moMoInfoProcess.buildURLNapas(sock, msg, data);                break;            default:                logger.warn("COMMAND IS NOT SUPPORTED, tranType,cmdPhone "                        + MomoProto.MsgType.valueOf(msg.cmdType).name() + ",0" + msg.cmdPhone);                break;        }    }    private void removePendingNotification(final NetSocket sock,final SockData data,final MomoMessage msg) {        MomoProto.NotificationReceived request;        try {            request = MomoProto.NotificationReceived.parseFrom(msg.cmdBody);        } catch (InvalidProtocolBufferException e) {            logger.error("InvalidProtocolBufferException", e);            request = null;        }        if (request == null) {            mCom.writeErrorToSocket(sock);            return;        }        Buffer buffer = MomoMessage.buildBuffer(                MomoProto.MsgType.NOTIFICATION_RECEIVED_REPLY_VALUE,                msg.cmdIndex,                msg.cmdPhone,                MomoProto.StandardReply.newBuilder().setDesc("Noti received reply").setRcode(0).setResult(true).build().toByteArray()        );        mCom.writeDataToSocket(sock, buffer);        final JsonObject joUpdateNotiTool = new JsonObject().putNumber("status", 1);        //app cu        final MomoProto.NotificationReceived frequest = request;        if (request.getNotificationId() != null && !request.getNotificationId().isEmpty()) {            data.removePendingPacket(request.getNotificationId());            BroadcastHandler.LocalMsgHelper helper = new BroadcastHandler.LocalMsgHelper();            helper.setNewPhone(msg.cmdPhone);            Notification notification = new Notification();            notification.id = request.getNotificationId();            helper.setExtra(notification.toJsonObject());            //cancel sending over sms and cloud message//            vertx.eventBus().publish(AppConstant.NotificationVerticle_ADDRESS_SEND_PACKET_SUCCESS, helper.getJsonObject());            vertx.eventBus().publish(AppConstant.HTTP_POST_BUS_ADDRESS,                    Misc.makeHttpPostWrapperData(AppConstant.NotificationVerticle_ADDRESS_SEND_PACKET_SUCCESS, helper.getJsonObject()));            statisticUtils.broadCastNotiReceive(msg.cmdPhone, request.getNotificationId());            notificationToolDb.upsertPartial(request.getNotificationId(), joUpdateNotiTool, new Handler<Boolean>() {                @Override                public void handle(Boolean result) {                    logger.info("update " + result + " " + frequest.getNotificationId() + " success ");                }            });        }        // app moi        final AtomicInteger countNoti = new AtomicInteger(frequest.getNotiList().size());        vertx.setPeriodic(250L, new Handler<Long>() {            @Override            public void handle(Long timerNoti) {                int positionNoti = countNoti.decrementAndGet();                if(positionNoti < 0)                {                    vertx.cancelTimer(timerNoti);                    return;                }                data.removePendingPacket(frequest.getNotiList().get(positionNoti).getId());                BroadcastHandler.LocalMsgHelper helper = new BroadcastHandler.LocalMsgHelper();                helper.setNewPhone(msg.cmdPhone);                Notification notification = new Notification();                notification.id = frequest.getNotiList().get(positionNoti).getId();                helper.setExtra(notification.toJsonObject());                //cancel sending over sms and cloud message//            vertx.eventBus().publish(AppConstant.NotificationVerticle_ADDRESS_SEND_PACKET_SUCCESS, helper.getJsonObject());                vertx.eventBus().publish(AppConstant.HTTP_POST_BUS_ADDRESS,                        Misc.makeHttpPostWrapperData(AppConstant.NotificationVerticle_ADDRESS_SEND_PACKET_SUCCESS, helper.getJsonObject()));                statisticUtils.broadCastNotiReceive(msg.cmdPhone, frequest.getNotificationId());                notificationToolDb.upsertPartial(frequest.getNotiList().get(positionNoti).getId(), joUpdateNotiTool, new Handler<Boolean>() {                    @Override                    public void handle(Boolean event) {                    }                });            }        });//        for (MomoProto.Notification noti : request.getNotiList()) {////        }    }    private void processTranRequest(final NetSocket sock, final MomoMessage msg, final SockData data) {        MomoProto.TranHisV1 request;        try {            request = MomoProto.TranHisV1.parseFrom(msg.cmdBody);        } catch (InvalidProtocolBufferException e) {            logger.error(msg + "InvalidProtocolBufferException", e);            request = null;        }        if (request == null) {            mCom.writeErrorToSocket(sock);            return;        }        mCom.sendTranAck(sock, msg);        switch (request.getTranType()) {            case MomoProto.TranHisV1.TranType.C2C_VALUE:                transProcess.processC2C(sock, msg, data, null);                break;            case MomoProto.TranHisV1.TranType.BANK_OUT_VALUE:                transProcess.processBankOut(sock, msg, data, null);                break;            case MomoProto.TranHisV1.TranType.BANK_IN_VALUE:                transProcess.processBankIn(sock, msg, data, null);                break;            case MomoProto.TranHisV1.TranType.C2C_RECEIVE_VALUE:                transProcess.processC2CReceive(sock, msg, data, null);                break;            case MomoProto.TranHisV1.TranType.M2C_VALUE:                transProcess.processM2CTransfer(sock, msg, data, null);                break;            case MomoProto.TranHisV1.TranType.M2M_VALUE:                transProcess.processM2MTransfer(sock, msg, data, null, null);                break;            case MomoProto.TranHisV1.TranType.TOP_UP_VALUE:                transProcess.processTopUp(sock, msg, data, null);                break;            case MomoProto.TranHisV1.TranType.PAY_ONE_BILL_VALUE:                transProcess.processPayOneBill(sock, msg, data, null);                break;            case MomoProto.TranHisV1.TranType.PAY_ONE_SALE_OFF_BILL_VALUE:                transferProcess.processPayOneSaleOffBill(sock, msg, data, null);                break;            case MomoProto.TranHisV1.TranType.TOP_UP_GAME_VALUE:                transProcess.processTopUpGame(sock, msg, data, null);                break;            case MomoProto.TranHisV1.TranType.BANK_NET_TO_MOMO_VALUE:                infoProcess.processBanknetCheckInfo(sock, msg, data, null);                //banknetProcess.processBanknetToMoMo(sock, msg, data,null);                break;            case MomoProto.TranHisV1.TranType.BANK_NET_VERIFY_OTP_VALUE:                banknetProcess.processBanknetVerifyOtp(sock, msg, data, null);                break;            case MomoProto.TranHisV1.TranType.TRANSFER_MONEY_TO_PLACE_VALUE:                transProcess.processTransferMoneyToPlace(sock, msg, data, null);                break;            case MomoProto.TranHisV1.TranType.TRANSFER_ONE_BILL_VALUE:                transProcess.processM2MerchantTransferViaRedis(sock, msg, data, null, null);                break;            case MomoProto.TranHisV1.TranType.ATM_CASH_IN_VALUE:                transProcess.processATMBankIn(sock, msg, data, null);                break;            case MomoProto.TranHisV1.TranType.ATM_CASH_OUT_VALUE:                transProcess.processBankOut(sock, msg, data, null);                break;//            case MomoProto.TranHisV1.TranType.VM_PROCESS_CASH_IN_VALUE://                transProcess.processVisaMasterCashIn(sock, msg, data, false, null, null, null);//                break;            /*processAgentModify*/            default:                logger.warn(msg + "SYSTEM NOT DEFINED THIS TRANSACTION TYPE " + MomoProto.MsgType.valueOf(msg.cmdType).name());                break;        }    }    private boolean preCheckTranRequest(MomoMessage msg, NetSocket sock, SockData data) {        boolean result = msg.cmdType == MomoProto.MsgType.TRANSFER_REQUEST_VALUE                || msg.cmdType == MomoProto.MsgType.TRANS_REQUEST_VALUE ? true : false;        if (!result) return true;        MomoProto.TranHisV1 request = null; //giao dich tren app transfer        try {            request = MomoProto.TranHisV1.parseFrom(msg.cmdBody);        } catch (InvalidProtocolBufferException e) {            logger.error(msg + "InvalidProtocolBufferException", e);            request = null;        }        String partnerPhone = "";        if (request.getTranType() == MomoProto.TranHisV1.TranType.TOP_UP_VALUE) {            partnerPhone = request.getPartnerCode();        } else if (request.getTranType() == MomoProto.TranHisV1.TranType.M2M_VALUE                || request.getTranType() == MomoProto.TranHisV1.TranType.M2C_VALUE) {            partnerPhone = request.getPartnerId();        }        if (partnerPhone.equalsIgnoreCase("")) return true;        boolean valid;        try {            long phoneNumber = DataUtil.stringToVnPhoneNumber(partnerPhone);            valid = (phoneNumber > 0 ? true : false);        } catch (Exception ex) {            logger.info("CastExceptionPartnerPhone : " + partnerPhone + ex.getMessage());            valid = false;        }        if (!valid) {            Buffer buf = Misc.buildBufferInvalid(request, msg, MomoProto.TranHisV1.ResultCode.PARTNER_NUMBER_NOT_VALID_VALUE);            mCom.writeDataToSocket(sock, buf);        }        return valid;    }    private synchronized void changeTranTypeStatus(JsonObject jo, Message message) {        int tranType = jo.getInteger(colName.CfgAtRuning.TRAN_TYPE, 0);        if (tranType == Const.ALL_TRANSACTION) {            setAll(jo);        } else {            MapTranRunning.put(tranType, jo.getBoolean(colName.CfgAtRuning.VALUE, true));        }        jo.putBoolean(colName.CfgAtRuning.SUCCESS, true);        message.reply(jo);    }    private void setAll(JsonObject jo) {        MapTranRunning.put(MomoProto.TranHisV1.TranType.TOP_UP_VALUE, jo.getBoolean(colName.CfgAtRuning.VALUE, true));        MapTranRunning.put(MomoProto.TranHisV1.TranType.TOP_UP_GAME_VALUE, jo.getBoolean(colName.CfgAtRuning.VALUE, true));        MapTranRunning.put(MomoProto.TranHisV1.TranType.M2C_VALUE, jo.getBoolean(colName.CfgAtRuning.VALUE, true));        MapTranRunning.put(MomoProto.TranHisV1.TranType.M2M_VALUE, jo.getBoolean(colName.CfgAtRuning.VALUE, true));        MapTranRunning.put(MomoProto.TranHisV1.TranType.PAY_ONE_BILL_VALUE, jo.getBoolean(colName.CfgAtRuning.VALUE, true));        MapTranRunning.put(MomoProto.TranHisV1.TranType.QUICK_PAYMENT_VALUE, jo.getBoolean(colName.CfgAtRuning.VALUE, true));        MapTranRunning.put(MomoProto.TranHisV1.TranType.QUICK_DEPOSIT_VALUE, jo.getBoolean(colName.CfgAtRuning.VALUE, true));        MapTranRunning.put(MomoProto.TranHisV1.TranType.BANK_NET_TO_MOMO_VALUE, jo.getBoolean(colName.CfgAtRuning.VALUE, true));        MapTranRunning.put(MomoProto.TranHisV1.TranType.BANK_NET_VERIFY_OTP_VALUE, jo.getBoolean(colName.CfgAtRuning.VALUE, true));        MapTranRunning.put(MomoProto.TranHisV1.TranType.PAY_ONE_BILL_OTHER_VALUE, jo.getBoolean(colName.CfgAtRuning.VALUE, true));        MapTranRunning.put(MomoProto.TranHisV1.TranType.TRANSFER_MONEY_TO_PLACE_VALUE, jo.getBoolean(colName.CfgAtRuning.VALUE, true));        MapTranRunning.put(MomoProto.TranHisV1.TranType.BILL_PAY_TELEPHONE_VALUE, jo.getBoolean(colName.CfgAtRuning.VALUE, true));        MapTranRunning.put(MomoProto.TranHisV1.TranType.BILL_PAY_TICKET_AIRLINE_VALUE, jo.getBoolean(colName.CfgAtRuning.VALUE, true));        MapTranRunning.put(MomoProto.TranHisV1.TranType.BILL_PAY_TICKET_TRAIN_VALUE, jo.getBoolean(colName.CfgAtRuning.VALUE, true));        MapTranRunning.put(MomoProto.TranHisV1.TranType.BILL_PAY_INSURANCE_VALUE, jo.getBoolean(colName.CfgAtRuning.VALUE, true));        MapTranRunning.put(MomoProto.TranHisV1.TranType.BILL_PAY_INTERNET_VALUE, jo.getBoolean(colName.CfgAtRuning.VALUE, true));        MapTranRunning.put(MomoProto.TranHisV1.TranType.BILL_PAY_OTHER_VALUE, jo.getBoolean(colName.CfgAtRuning.VALUE, true));        MapTranRunning.put(MomoProto.TranHisV1.TranType.DEPOSIT_CASH_OTHER_VALUE, jo.getBoolean(colName.CfgAtRuning.VALUE, true));        MapTranRunning.put(MomoProto.TranHisV1.TranType.BUY_MOBILITY_CARD_VALUE, jo.getBoolean(colName.CfgAtRuning.VALUE, true));        MapTranRunning.put(MomoProto.TranHisV1.TranType.BUY_GAME_CARD_VALUE, jo.getBoolean(colName.CfgAtRuning.VALUE, true));        MapTranRunning.put(MomoProto.TranHisV1.TranType.BUY_OTHER_VALUE, jo.getBoolean(colName.CfgAtRuning.VALUE, true));        MapTranRunning.put(MomoProto.TranHisV1.TranType.DEPOSIT_CASH_VALUE, jo.getBoolean(colName.CfgAtRuning.VALUE, true));        MapTranRunning.put(MomoProto.TranHisV1.TranType.BILL_PAY_CINEMA_VALUE, jo.getBoolean(colName.CfgAtRuning.VALUE, true));        MapTranRunning.put(MomoProto.TranHisV1.TranType.MOMO_TO_BANK_MANUAL_VALUE, jo.getBoolean(colName.CfgAtRuning.VALUE, true));        MapTranRunning.put(MomoProto.TranHisV1.TranType.DEPOSIT_AT_HOME_VALUE, jo.getBoolean(colName.CfgAtRuning.VALUE, true));        MapTranRunning.put(MomoProto.TranHisV1.TranType.WITHDRAW_AT_HOME_VALUE, jo.getBoolean(colName.CfgAtRuning.VALUE, true));    }    private void getAllTranServiceStatus(Message message) {        JsonArray jsonArray = new JsonArray();        Set<Integer> keys = MapTranRunning.keySet();        for (int key : keys) {            JsonObject item = new JsonObject();//            item.putNumber("key",key);            item.putString("name", MomoProto.TranHisV1.TranType.valueOf(key).name());            item.putBoolean("val", MapTranRunning.get(key));            item.putNumber("key", key);            jsonArray.add(item);        }        message.reply(jsonArray);    }}