// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MomoMsg

#ifndef PROTOBUF_MomoMsg__INCLUDED
#define PROTOBUF_MomoMsg__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace com {
namespace mservice {
namespace momo {
namespace msg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_MomoMsg();
void protobuf_AssignDesc_MomoMsg();
void protobuf_ShutdownFile_MomoMsg();

class Err;
class Hello;
class HelloReply;
class Base;

enum Err_ResultCode {
  Err_ResultCode_MSG_FORMAT_NOT_CORRECT = 1
};
bool Err_ResultCode_IsValid(int value);
const Err_ResultCode Err_ResultCode_ResultCode_MIN = Err_ResultCode_MSG_FORMAT_NOT_CORRECT;
const Err_ResultCode Err_ResultCode_ResultCode_MAX = Err_ResultCode_MSG_FORMAT_NOT_CORRECT;
const int Err_ResultCode_ResultCode_ARRAYSIZE = Err_ResultCode_ResultCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* Err_ResultCode_descriptor();
inline const ::std::string& Err_ResultCode_Name(Err_ResultCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    Err_ResultCode_descriptor(), value);
}
inline bool Err_ResultCode_Parse(
    const ::std::string& name, Err_ResultCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Err_ResultCode>(
    Err_ResultCode_descriptor(), name, value);
}
enum HelloReply_ResultCode {
  HelloReply_ResultCode_ALL_OK = 0,
  HelloReply_ResultCode_MSG_FORMAT_NOT_CORRECT = 1,
  HelloReply_ResultCode_PHONE_NUMBER_NOT_REGISTERED = 2,
  HelloReply_ResultCode_PHONE_NUMBER_NOT_CORRECT = 3
};
bool HelloReply_ResultCode_IsValid(int value);
const HelloReply_ResultCode HelloReply_ResultCode_ResultCode_MIN = HelloReply_ResultCode_ALL_OK;
const HelloReply_ResultCode HelloReply_ResultCode_ResultCode_MAX = HelloReply_ResultCode_PHONE_NUMBER_NOT_CORRECT;
const int HelloReply_ResultCode_ResultCode_ARRAYSIZE = HelloReply_ResultCode_ResultCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* HelloReply_ResultCode_descriptor();
inline const ::std::string& HelloReply_ResultCode_Name(HelloReply_ResultCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    HelloReply_ResultCode_descriptor(), value);
}
inline bool HelloReply_ResultCode_Parse(
    const ::std::string& name, HelloReply_ResultCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HelloReply_ResultCode>(
    HelloReply_ResultCode_descriptor(), name, value);
}
enum Base_MsgType {
  Base_MsgType_ACK = 1,
  Base_MsgType_ERROR = 2,
  Base_MsgType_HELLO = 1001,
  Base_MsgType_HELLO_REPLY = 1002,
  Base_MsgType_GET_OTP = 1003,
  Base_MsgType_GET_OTP_REPLY = 1004,
  Base_MsgType_VERIFY_OTP = 1005,
  Base_MsgType_VERIFY_OTP_REPLY = 1006,
  Base_MsgType_LOGIN = 1007,
  Base_MsgType_LOGIN_REPLY = 1008,
  Base_MsgType_SIGNUP = 1009,
  Base_MsgType_SIGNUP_REPLY = 1010,
  Base_MsgType_RECOVERY_PIN = 1011,
  Base_MsgType_RECOVERY_PIN_REPLY = 1012,
  Base_MsgType_BILLAY_GETBILL = 1013,
  Base_MsgType_BILLAY_GETBILL_REPLY = 1014,
  Base_MsgType_DEVICE_INFO = 1015,
  Base_MsgType_DEVICE_INFO_REPLY = 1016,
  Base_MsgType_TOPUP_PHONE = 1017,
  Base_MsgType_TOPUP_PHONE_REPLY = 1018,
  Base_MsgType_BILLAY_ONE_PAYMENT = 1019,
  Base_MsgType_BILLAY_ONE_PAYMENT_REPLY = 1020,
  Base_MsgType_CHANGE_MPIN = 1021,
  Base_MsgType_CHANGE_MPIN_REPLY = 1022,
  Base_MsgType_BILLPAY_GET_ALL = 1023,
  Base_MsgType_BILLPAY_GET_ALL_REPLY = 1024,
  Base_MsgType_TRANSFER_M2M = 1027,
  Base_MsgType_TRANSFER_M2M_REPLY = 1028,
  Base_MsgType_TRANSFER_M2C = 1029,
  Base_MsgType_TRANSFER_M2C_REPLY = 1030,
  Base_MsgType_CASHIN_FORM_VCB_TO_MOMO = 1031,
  Base_MsgType_CASHIN_FORM_VCB_TO_MOMO_REPLY = 1032,
  Base_MsgType_CASHOUT_FORM_MOMO_TO_VCB = 1033,
  Base_MsgType_CASHOUT_FORM_MOMO_TO_VCB_REPLY = 1034,
  Base_MsgType_GET_USER_INFO = 1035,
  Base_MsgType_GET_USER_INFO_REPLY = 1036,
  Base_MsgType_PHONE_EXIST = 1037,
  Base_MsgType_PHONE_EXIST_REPLY = 1038,
  Base_MsgType_LOG_OUT = 1039,
  Base_MsgType_LOG_OUT_REPLY = 1040
};
bool Base_MsgType_IsValid(int value);
const Base_MsgType Base_MsgType_MsgType_MIN = Base_MsgType_ACK;
const Base_MsgType Base_MsgType_MsgType_MAX = Base_MsgType_LOG_OUT_REPLY;
const int Base_MsgType_MsgType_ARRAYSIZE = Base_MsgType_MsgType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Base_MsgType_descriptor();
inline const ::std::string& Base_MsgType_Name(Base_MsgType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Base_MsgType_descriptor(), value);
}
inline bool Base_MsgType_Parse(
    const ::std::string& name, Base_MsgType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Base_MsgType>(
    Base_MsgType_descriptor(), name, value);
}
// ===================================================================

class Err : public ::google::protobuf::Message {
 public:
  Err();
  virtual ~Err();

  Err(const Err& from);

  inline Err& operator=(const Err& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Err& default_instance();

  void Swap(Err* other);

  // implements Message ----------------------------------------------

  Err* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Err& from);
  void MergeFrom(const Err& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Err_ResultCode ResultCode;
  static const ResultCode MSG_FORMAT_NOT_CORRECT = Err_ResultCode_MSG_FORMAT_NOT_CORRECT;
  static inline bool ResultCode_IsValid(int value) {
    return Err_ResultCode_IsValid(value);
  }
  static const ResultCode ResultCode_MIN =
    Err_ResultCode_ResultCode_MIN;
  static const ResultCode ResultCode_MAX =
    Err_ResultCode_ResultCode_MAX;
  static const int ResultCode_ARRAYSIZE =
    Err_ResultCode_ResultCode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ResultCode_descriptor() {
    return Err_ResultCode_descriptor();
  }
  static inline const ::std::string& ResultCode_Name(ResultCode value) {
    return Err_ResultCode_Name(value);
  }
  static inline bool ResultCode_Parse(const ::std::string& name,
      ResultCode* value) {
    return Err_ResultCode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional uint32 result_code = 1;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 1;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);

  // optional string result_desc = 2;
  inline bool has_result_desc() const;
  inline void clear_result_desc();
  static const int kResultDescFieldNumber = 2;
  inline const ::std::string& result_desc() const;
  inline void set_result_desc(const ::std::string& value);
  inline void set_result_desc(const char* value);
  inline void set_result_desc(const char* value, size_t size);
  inline ::std::string* mutable_result_desc();
  inline ::std::string* release_result_desc();
  inline void set_allocated_result_desc(::std::string* result_desc);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.Err)
 private:
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_result_desc();
  inline void clear_has_result_desc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* result_desc_;
  ::google::protobuf::uint32 result_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_MomoMsg();
  friend void protobuf_AssignDesc_MomoMsg();
  friend void protobuf_ShutdownFile_MomoMsg();

  void InitAsDefaultInstance();
  static Err* default_instance_;
};
// -------------------------------------------------------------------

class Hello : public ::google::protobuf::Message {
 public:
  Hello();
  virtual ~Hello();

  Hello(const Hello& from);

  inline Hello& operator=(const Hello& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Hello& default_instance();

  void Swap(Hello* other);

  // implements Message ----------------------------------------------

  Hello* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Hello& from);
  void MergeFrom(const Hello& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string imei = 1;
  inline bool has_imei() const;
  inline void clear_imei();
  static const int kImeiFieldNumber = 1;
  inline const ::std::string& imei() const;
  inline void set_imei(const ::std::string& value);
  inline void set_imei(const char* value);
  inline void set_imei(const char* value, size_t size);
  inline ::std::string* mutable_imei();
  inline ::std::string* release_imei();
  inline void set_allocated_imei(::std::string* imei);

  // optional string magic_key = 2;
  inline bool has_magic_key() const;
  inline void clear_magic_key();
  static const int kMagicKeyFieldNumber = 2;
  inline const ::std::string& magic_key() const;
  inline void set_magic_key(const ::std::string& value);
  inline void set_magic_key(const char* value);
  inline void set_magic_key(const char* value, size_t size);
  inline ::std::string* mutable_magic_key();
  inline ::std::string* release_magic_key();
  inline void set_allocated_magic_key(::std::string* magic_key);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.Hello)
 private:
  inline void set_has_imei();
  inline void clear_has_imei();
  inline void set_has_magic_key();
  inline void clear_has_magic_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* imei_;
  ::std::string* magic_key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_MomoMsg();
  friend void protobuf_AssignDesc_MomoMsg();
  friend void protobuf_ShutdownFile_MomoMsg();

  void InitAsDefaultInstance();
  static Hello* default_instance_;
};
// -------------------------------------------------------------------

class HelloReply : public ::google::protobuf::Message {
 public:
  HelloReply();
  virtual ~HelloReply();

  HelloReply(const HelloReply& from);

  inline HelloReply& operator=(const HelloReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HelloReply& default_instance();

  void Swap(HelloReply* other);

  // implements Message ----------------------------------------------

  HelloReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HelloReply& from);
  void MergeFrom(const HelloReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef HelloReply_ResultCode ResultCode;
  static const ResultCode ALL_OK = HelloReply_ResultCode_ALL_OK;
  static const ResultCode MSG_FORMAT_NOT_CORRECT = HelloReply_ResultCode_MSG_FORMAT_NOT_CORRECT;
  static const ResultCode PHONE_NUMBER_NOT_REGISTERED = HelloReply_ResultCode_PHONE_NUMBER_NOT_REGISTERED;
  static const ResultCode PHONE_NUMBER_NOT_CORRECT = HelloReply_ResultCode_PHONE_NUMBER_NOT_CORRECT;
  static inline bool ResultCode_IsValid(int value) {
    return HelloReply_ResultCode_IsValid(value);
  }
  static const ResultCode ResultCode_MIN =
    HelloReply_ResultCode_ResultCode_MIN;
  static const ResultCode ResultCode_MAX =
    HelloReply_ResultCode_ResultCode_MAX;
  static const int ResultCode_ARRAYSIZE =
    HelloReply_ResultCode_ResultCode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ResultCode_descriptor() {
    return HelloReply_ResultCode_descriptor();
  }
  static inline const ::std::string& ResultCode_Name(ResultCode value) {
    return HelloReply_ResultCode_Name(value);
  }
  static inline bool ResultCode_Parse(const ::std::string& name,
      ResultCode* value) {
    return HelloReply_ResultCode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional bool result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline bool result() const;
  inline void set_result(bool value);

  // optional uint32 result_code = 2;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);

  // optional string magic_key = 3;
  inline bool has_magic_key() const;
  inline void clear_magic_key();
  static const int kMagicKeyFieldNumber = 3;
  inline const ::std::string& magic_key() const;
  inline void set_magic_key(const ::std::string& value);
  inline void set_magic_key(const char* value);
  inline void set_magic_key(const char* value, size_t size);
  inline ::std::string* mutable_magic_key();
  inline ::std::string* release_magic_key();
  inline void set_allocated_magic_key(::std::string* magic_key);

  // optional string result_desc = 4;
  inline bool has_result_desc() const;
  inline void clear_result_desc();
  static const int kResultDescFieldNumber = 4;
  inline const ::std::string& result_desc() const;
  inline void set_result_desc(const ::std::string& value);
  inline void set_result_desc(const char* value);
  inline void set_result_desc(const char* value, size_t size);
  inline ::std::string* mutable_result_desc();
  inline ::std::string* release_result_desc();
  inline void set_allocated_result_desc(::std::string* result_desc);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.HelloReply)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_magic_key();
  inline void clear_has_magic_key();
  inline void set_has_result_desc();
  inline void clear_has_result_desc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool result_;
  ::google::protobuf::uint32 result_code_;
  ::std::string* magic_key_;
  ::std::string* result_desc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_MomoMsg();
  friend void protobuf_AssignDesc_MomoMsg();
  friend void protobuf_ShutdownFile_MomoMsg();

  void InitAsDefaultInstance();
  static HelloReply* default_instance_;
};
// -------------------------------------------------------------------

class Base : public ::google::protobuf::Message {
 public:
  Base();
  virtual ~Base();

  Base(const Base& from);

  inline Base& operator=(const Base& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Base& default_instance();

  void Swap(Base* other);

  // implements Message ----------------------------------------------

  Base* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Base& from);
  void MergeFrom(const Base& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Base_MsgType MsgType;
  static const MsgType ACK = Base_MsgType_ACK;
  static const MsgType ERROR = Base_MsgType_ERROR;
  static const MsgType HELLO = Base_MsgType_HELLO;
  static const MsgType HELLO_REPLY = Base_MsgType_HELLO_REPLY;
  static const MsgType GET_OTP = Base_MsgType_GET_OTP;
  static const MsgType GET_OTP_REPLY = Base_MsgType_GET_OTP_REPLY;
  static const MsgType VERIFY_OTP = Base_MsgType_VERIFY_OTP;
  static const MsgType VERIFY_OTP_REPLY = Base_MsgType_VERIFY_OTP_REPLY;
  static const MsgType LOGIN = Base_MsgType_LOGIN;
  static const MsgType LOGIN_REPLY = Base_MsgType_LOGIN_REPLY;
  static const MsgType SIGNUP = Base_MsgType_SIGNUP;
  static const MsgType SIGNUP_REPLY = Base_MsgType_SIGNUP_REPLY;
  static const MsgType RECOVERY_PIN = Base_MsgType_RECOVERY_PIN;
  static const MsgType RECOVERY_PIN_REPLY = Base_MsgType_RECOVERY_PIN_REPLY;
  static const MsgType BILLAY_GETBILL = Base_MsgType_BILLAY_GETBILL;
  static const MsgType BILLAY_GETBILL_REPLY = Base_MsgType_BILLAY_GETBILL_REPLY;
  static const MsgType DEVICE_INFO = Base_MsgType_DEVICE_INFO;
  static const MsgType DEVICE_INFO_REPLY = Base_MsgType_DEVICE_INFO_REPLY;
  static const MsgType TOPUP_PHONE = Base_MsgType_TOPUP_PHONE;
  static const MsgType TOPUP_PHONE_REPLY = Base_MsgType_TOPUP_PHONE_REPLY;
  static const MsgType BILLAY_ONE_PAYMENT = Base_MsgType_BILLAY_ONE_PAYMENT;
  static const MsgType BILLAY_ONE_PAYMENT_REPLY = Base_MsgType_BILLAY_ONE_PAYMENT_REPLY;
  static const MsgType CHANGE_MPIN = Base_MsgType_CHANGE_MPIN;
  static const MsgType CHANGE_MPIN_REPLY = Base_MsgType_CHANGE_MPIN_REPLY;
  static const MsgType BILLPAY_GET_ALL = Base_MsgType_BILLPAY_GET_ALL;
  static const MsgType BILLPAY_GET_ALL_REPLY = Base_MsgType_BILLPAY_GET_ALL_REPLY;
  static const MsgType TRANSFER_M2M = Base_MsgType_TRANSFER_M2M;
  static const MsgType TRANSFER_M2M_REPLY = Base_MsgType_TRANSFER_M2M_REPLY;
  static const MsgType TRANSFER_M2C = Base_MsgType_TRANSFER_M2C;
  static const MsgType TRANSFER_M2C_REPLY = Base_MsgType_TRANSFER_M2C_REPLY;
  static const MsgType CASHIN_FORM_VCB_TO_MOMO = Base_MsgType_CASHIN_FORM_VCB_TO_MOMO;
  static const MsgType CASHIN_FORM_VCB_TO_MOMO_REPLY = Base_MsgType_CASHIN_FORM_VCB_TO_MOMO_REPLY;
  static const MsgType CASHOUT_FORM_MOMO_TO_VCB = Base_MsgType_CASHOUT_FORM_MOMO_TO_VCB;
  static const MsgType CASHOUT_FORM_MOMO_TO_VCB_REPLY = Base_MsgType_CASHOUT_FORM_MOMO_TO_VCB_REPLY;
  static const MsgType GET_USER_INFO = Base_MsgType_GET_USER_INFO;
  static const MsgType GET_USER_INFO_REPLY = Base_MsgType_GET_USER_INFO_REPLY;
  static const MsgType PHONE_EXIST = Base_MsgType_PHONE_EXIST;
  static const MsgType PHONE_EXIST_REPLY = Base_MsgType_PHONE_EXIST_REPLY;
  static const MsgType LOG_OUT = Base_MsgType_LOG_OUT;
  static const MsgType LOG_OUT_REPLY = Base_MsgType_LOG_OUT_REPLY;
  static inline bool MsgType_IsValid(int value) {
    return Base_MsgType_IsValid(value);
  }
  static const MsgType MsgType_MIN =
    Base_MsgType_MsgType_MIN;
  static const MsgType MsgType_MAX =
    Base_MsgType_MsgType_MAX;
  static const int MsgType_ARRAYSIZE =
    Base_MsgType_MsgType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MsgType_descriptor() {
    return Base_MsgType_descriptor();
  }
  static inline const ::std::string& MsgType_Name(MsgType value) {
    return Base_MsgType_Name(value);
  }
  static inline bool MsgType_Parse(const ::std::string& name,
      MsgType* value) {
    return Base_MsgType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .com.mservice.momo.msg.Base.MsgType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::com::mservice::momo::msg::Base_MsgType type() const;
  inline void set_type(::com::mservice::momo::msg::Base_MsgType value);

  // optional string phone = 2;
  inline bool has_phone() const;
  inline void clear_phone();
  static const int kPhoneFieldNumber = 2;
  inline const ::std::string& phone() const;
  inline void set_phone(const ::std::string& value);
  inline void set_phone(const char* value);
  inline void set_phone(const char* value, size_t size);
  inline ::std::string* mutable_phone();
  inline ::std::string* release_phone();
  inline void set_allocated_phone(::std::string* phone);

  // optional uint32 index = 3;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 3;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional bool ack = 10;
  inline bool has_ack() const;
  inline void clear_ack();
  static const int kAckFieldNumber = 10;
  inline bool ack() const;
  inline void set_ack(bool value);

  // optional .com.mservice.momo.msg.Err err = 11;
  inline bool has_err() const;
  inline void clear_err();
  static const int kErrFieldNumber = 11;
  inline const ::com::mservice::momo::msg::Err& err() const;
  inline ::com::mservice::momo::msg::Err* mutable_err();
  inline ::com::mservice::momo::msg::Err* release_err();
  inline void set_allocated_err(::com::mservice::momo::msg::Err* err);

  // optional .com.mservice.momo.msg.Hello hello = 1001;
  inline bool has_hello() const;
  inline void clear_hello();
  static const int kHelloFieldNumber = 1001;
  inline const ::com::mservice::momo::msg::Hello& hello() const;
  inline ::com::mservice::momo::msg::Hello* mutable_hello();
  inline ::com::mservice::momo::msg::Hello* release_hello();
  inline void set_allocated_hello(::com::mservice::momo::msg::Hello* hello);

  // optional .com.mservice.momo.msg.HelloReply hello_reply = 1002;
  inline bool has_hello_reply() const;
  inline void clear_hello_reply();
  static const int kHelloReplyFieldNumber = 1002;
  inline const ::com::mservice::momo::msg::HelloReply& hello_reply() const;
  inline ::com::mservice::momo::msg::HelloReply* mutable_hello_reply();
  inline ::com::mservice::momo::msg::HelloReply* release_hello_reply();
  inline void set_allocated_hello_reply(::com::mservice::momo::msg::HelloReply* hello_reply);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.Base)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_phone();
  inline void clear_has_phone();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_ack();
  inline void clear_has_ack();
  inline void set_has_err();
  inline void clear_has_err();
  inline void set_has_hello();
  inline void clear_has_hello();
  inline void set_has_hello_reply();
  inline void clear_has_hello_reply();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* phone_;
  int type_;
  ::google::protobuf::uint32 index_;
  ::com::mservice::momo::msg::Err* err_;
  ::com::mservice::momo::msg::Hello* hello_;
  ::com::mservice::momo::msg::HelloReply* hello_reply_;
  bool ack_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_MomoMsg();
  friend void protobuf_AssignDesc_MomoMsg();
  friend void protobuf_ShutdownFile_MomoMsg();

  void InitAsDefaultInstance();
  static Base* default_instance_;
};
// ===================================================================


// ===================================================================

// Err

// optional uint32 result_code = 1;
inline bool Err::has_result_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Err::set_has_result_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Err::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Err::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 Err::result_code() const {
  return result_code_;
}
inline void Err::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
}

// optional string result_desc = 2;
inline bool Err::has_result_desc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Err::set_has_result_desc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Err::clear_has_result_desc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Err::clear_result_desc() {
  if (result_desc_ != &::google::protobuf::internal::kEmptyString) {
    result_desc_->clear();
  }
  clear_has_result_desc();
}
inline const ::std::string& Err::result_desc() const {
  return *result_desc_;
}
inline void Err::set_result_desc(const ::std::string& value) {
  set_has_result_desc();
  if (result_desc_ == &::google::protobuf::internal::kEmptyString) {
    result_desc_ = new ::std::string;
  }
  result_desc_->assign(value);
}
inline void Err::set_result_desc(const char* value) {
  set_has_result_desc();
  if (result_desc_ == &::google::protobuf::internal::kEmptyString) {
    result_desc_ = new ::std::string;
  }
  result_desc_->assign(value);
}
inline void Err::set_result_desc(const char* value, size_t size) {
  set_has_result_desc();
  if (result_desc_ == &::google::protobuf::internal::kEmptyString) {
    result_desc_ = new ::std::string;
  }
  result_desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Err::mutable_result_desc() {
  set_has_result_desc();
  if (result_desc_ == &::google::protobuf::internal::kEmptyString) {
    result_desc_ = new ::std::string;
  }
  return result_desc_;
}
inline ::std::string* Err::release_result_desc() {
  clear_has_result_desc();
  if (result_desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = result_desc_;
    result_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Err::set_allocated_result_desc(::std::string* result_desc) {
  if (result_desc_ != &::google::protobuf::internal::kEmptyString) {
    delete result_desc_;
  }
  if (result_desc) {
    set_has_result_desc();
    result_desc_ = result_desc;
  } else {
    clear_has_result_desc();
    result_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Hello

// optional string imei = 1;
inline bool Hello::has_imei() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Hello::set_has_imei() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Hello::clear_has_imei() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Hello::clear_imei() {
  if (imei_ != &::google::protobuf::internal::kEmptyString) {
    imei_->clear();
  }
  clear_has_imei();
}
inline const ::std::string& Hello::imei() const {
  return *imei_;
}
inline void Hello::set_imei(const ::std::string& value) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  imei_->assign(value);
}
inline void Hello::set_imei(const char* value) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  imei_->assign(value);
}
inline void Hello::set_imei(const char* value, size_t size) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  imei_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Hello::mutable_imei() {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  return imei_;
}
inline ::std::string* Hello::release_imei() {
  clear_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = imei_;
    imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Hello::set_allocated_imei(::std::string* imei) {
  if (imei_ != &::google::protobuf::internal::kEmptyString) {
    delete imei_;
  }
  if (imei) {
    set_has_imei();
    imei_ = imei;
  } else {
    clear_has_imei();
    imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string magic_key = 2;
inline bool Hello::has_magic_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Hello::set_has_magic_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Hello::clear_has_magic_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Hello::clear_magic_key() {
  if (magic_key_ != &::google::protobuf::internal::kEmptyString) {
    magic_key_->clear();
  }
  clear_has_magic_key();
}
inline const ::std::string& Hello::magic_key() const {
  return *magic_key_;
}
inline void Hello::set_magic_key(const ::std::string& value) {
  set_has_magic_key();
  if (magic_key_ == &::google::protobuf::internal::kEmptyString) {
    magic_key_ = new ::std::string;
  }
  magic_key_->assign(value);
}
inline void Hello::set_magic_key(const char* value) {
  set_has_magic_key();
  if (magic_key_ == &::google::protobuf::internal::kEmptyString) {
    magic_key_ = new ::std::string;
  }
  magic_key_->assign(value);
}
inline void Hello::set_magic_key(const char* value, size_t size) {
  set_has_magic_key();
  if (magic_key_ == &::google::protobuf::internal::kEmptyString) {
    magic_key_ = new ::std::string;
  }
  magic_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Hello::mutable_magic_key() {
  set_has_magic_key();
  if (magic_key_ == &::google::protobuf::internal::kEmptyString) {
    magic_key_ = new ::std::string;
  }
  return magic_key_;
}
inline ::std::string* Hello::release_magic_key() {
  clear_has_magic_key();
  if (magic_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = magic_key_;
    magic_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Hello::set_allocated_magic_key(::std::string* magic_key) {
  if (magic_key_ != &::google::protobuf::internal::kEmptyString) {
    delete magic_key_;
  }
  if (magic_key) {
    set_has_magic_key();
    magic_key_ = magic_key;
  } else {
    clear_has_magic_key();
    magic_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// HelloReply

// optional bool result = 1;
inline bool HelloReply::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HelloReply::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HelloReply::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HelloReply::clear_result() {
  result_ = false;
  clear_has_result();
}
inline bool HelloReply::result() const {
  return result_;
}
inline void HelloReply::set_result(bool value) {
  set_has_result();
  result_ = value;
}

// optional uint32 result_code = 2;
inline bool HelloReply::has_result_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HelloReply::set_has_result_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HelloReply::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HelloReply::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 HelloReply::result_code() const {
  return result_code_;
}
inline void HelloReply::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
}

// optional string magic_key = 3;
inline bool HelloReply::has_magic_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HelloReply::set_has_magic_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HelloReply::clear_has_magic_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HelloReply::clear_magic_key() {
  if (magic_key_ != &::google::protobuf::internal::kEmptyString) {
    magic_key_->clear();
  }
  clear_has_magic_key();
}
inline const ::std::string& HelloReply::magic_key() const {
  return *magic_key_;
}
inline void HelloReply::set_magic_key(const ::std::string& value) {
  set_has_magic_key();
  if (magic_key_ == &::google::protobuf::internal::kEmptyString) {
    magic_key_ = new ::std::string;
  }
  magic_key_->assign(value);
}
inline void HelloReply::set_magic_key(const char* value) {
  set_has_magic_key();
  if (magic_key_ == &::google::protobuf::internal::kEmptyString) {
    magic_key_ = new ::std::string;
  }
  magic_key_->assign(value);
}
inline void HelloReply::set_magic_key(const char* value, size_t size) {
  set_has_magic_key();
  if (magic_key_ == &::google::protobuf::internal::kEmptyString) {
    magic_key_ = new ::std::string;
  }
  magic_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HelloReply::mutable_magic_key() {
  set_has_magic_key();
  if (magic_key_ == &::google::protobuf::internal::kEmptyString) {
    magic_key_ = new ::std::string;
  }
  return magic_key_;
}
inline ::std::string* HelloReply::release_magic_key() {
  clear_has_magic_key();
  if (magic_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = magic_key_;
    magic_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HelloReply::set_allocated_magic_key(::std::string* magic_key) {
  if (magic_key_ != &::google::protobuf::internal::kEmptyString) {
    delete magic_key_;
  }
  if (magic_key) {
    set_has_magic_key();
    magic_key_ = magic_key;
  } else {
    clear_has_magic_key();
    magic_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string result_desc = 4;
inline bool HelloReply::has_result_desc() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HelloReply::set_has_result_desc() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HelloReply::clear_has_result_desc() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HelloReply::clear_result_desc() {
  if (result_desc_ != &::google::protobuf::internal::kEmptyString) {
    result_desc_->clear();
  }
  clear_has_result_desc();
}
inline const ::std::string& HelloReply::result_desc() const {
  return *result_desc_;
}
inline void HelloReply::set_result_desc(const ::std::string& value) {
  set_has_result_desc();
  if (result_desc_ == &::google::protobuf::internal::kEmptyString) {
    result_desc_ = new ::std::string;
  }
  result_desc_->assign(value);
}
inline void HelloReply::set_result_desc(const char* value) {
  set_has_result_desc();
  if (result_desc_ == &::google::protobuf::internal::kEmptyString) {
    result_desc_ = new ::std::string;
  }
  result_desc_->assign(value);
}
inline void HelloReply::set_result_desc(const char* value, size_t size) {
  set_has_result_desc();
  if (result_desc_ == &::google::protobuf::internal::kEmptyString) {
    result_desc_ = new ::std::string;
  }
  result_desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HelloReply::mutable_result_desc() {
  set_has_result_desc();
  if (result_desc_ == &::google::protobuf::internal::kEmptyString) {
    result_desc_ = new ::std::string;
  }
  return result_desc_;
}
inline ::std::string* HelloReply::release_result_desc() {
  clear_has_result_desc();
  if (result_desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = result_desc_;
    result_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HelloReply::set_allocated_result_desc(::std::string* result_desc) {
  if (result_desc_ != &::google::protobuf::internal::kEmptyString) {
    delete result_desc_;
  }
  if (result_desc) {
    set_has_result_desc();
    result_desc_ = result_desc;
  } else {
    clear_has_result_desc();
    result_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Base

// required .com.mservice.momo.msg.Base.MsgType type = 1;
inline bool Base::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Base::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Base::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Base::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::com::mservice::momo::msg::Base_MsgType Base::type() const {
  return static_cast< ::com::mservice::momo::msg::Base_MsgType >(type_);
}
inline void Base::set_type(::com::mservice::momo::msg::Base_MsgType value) {
  assert(::com::mservice::momo::msg::Base_MsgType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string phone = 2;
inline bool Base::has_phone() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Base::set_has_phone() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Base::clear_has_phone() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Base::clear_phone() {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    phone_->clear();
  }
  clear_has_phone();
}
inline const ::std::string& Base::phone() const {
  return *phone_;
}
inline void Base::set_phone(const ::std::string& value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void Base::set_phone(const char* value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void Base::set_phone(const char* value, size_t size) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Base::mutable_phone() {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  return phone_;
}
inline ::std::string* Base::release_phone() {
  clear_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phone_;
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Base::set_allocated_phone(::std::string* phone) {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    delete phone_;
  }
  if (phone) {
    set_has_phone();
    phone_ = phone;
  } else {
    clear_has_phone();
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 index = 3;
inline bool Base::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Base::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Base::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Base::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 Base::index() const {
  return index_;
}
inline void Base::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional bool ack = 10;
inline bool Base::has_ack() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Base::set_has_ack() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Base::clear_has_ack() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Base::clear_ack() {
  ack_ = false;
  clear_has_ack();
}
inline bool Base::ack() const {
  return ack_;
}
inline void Base::set_ack(bool value) {
  set_has_ack();
  ack_ = value;
}

// optional .com.mservice.momo.msg.Err err = 11;
inline bool Base::has_err() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Base::set_has_err() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Base::clear_has_err() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Base::clear_err() {
  if (err_ != NULL) err_->::com::mservice::momo::msg::Err::Clear();
  clear_has_err();
}
inline const ::com::mservice::momo::msg::Err& Base::err() const {
  return err_ != NULL ? *err_ : *default_instance_->err_;
}
inline ::com::mservice::momo::msg::Err* Base::mutable_err() {
  set_has_err();
  if (err_ == NULL) err_ = new ::com::mservice::momo::msg::Err;
  return err_;
}
inline ::com::mservice::momo::msg::Err* Base::release_err() {
  clear_has_err();
  ::com::mservice::momo::msg::Err* temp = err_;
  err_ = NULL;
  return temp;
}
inline void Base::set_allocated_err(::com::mservice::momo::msg::Err* err) {
  delete err_;
  err_ = err;
  if (err) {
    set_has_err();
  } else {
    clear_has_err();
  }
}

// optional .com.mservice.momo.msg.Hello hello = 1001;
inline bool Base::has_hello() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Base::set_has_hello() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Base::clear_has_hello() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Base::clear_hello() {
  if (hello_ != NULL) hello_->::com::mservice::momo::msg::Hello::Clear();
  clear_has_hello();
}
inline const ::com::mservice::momo::msg::Hello& Base::hello() const {
  return hello_ != NULL ? *hello_ : *default_instance_->hello_;
}
inline ::com::mservice::momo::msg::Hello* Base::mutable_hello() {
  set_has_hello();
  if (hello_ == NULL) hello_ = new ::com::mservice::momo::msg::Hello;
  return hello_;
}
inline ::com::mservice::momo::msg::Hello* Base::release_hello() {
  clear_has_hello();
  ::com::mservice::momo::msg::Hello* temp = hello_;
  hello_ = NULL;
  return temp;
}
inline void Base::set_allocated_hello(::com::mservice::momo::msg::Hello* hello) {
  delete hello_;
  hello_ = hello;
  if (hello) {
    set_has_hello();
  } else {
    clear_has_hello();
  }
}

// optional .com.mservice.momo.msg.HelloReply hello_reply = 1002;
inline bool Base::has_hello_reply() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Base::set_has_hello_reply() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Base::clear_has_hello_reply() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Base::clear_hello_reply() {
  if (hello_reply_ != NULL) hello_reply_->::com::mservice::momo::msg::HelloReply::Clear();
  clear_has_hello_reply();
}
inline const ::com::mservice::momo::msg::HelloReply& Base::hello_reply() const {
  return hello_reply_ != NULL ? *hello_reply_ : *default_instance_->hello_reply_;
}
inline ::com::mservice::momo::msg::HelloReply* Base::mutable_hello_reply() {
  set_has_hello_reply();
  if (hello_reply_ == NULL) hello_reply_ = new ::com::mservice::momo::msg::HelloReply;
  return hello_reply_;
}
inline ::com::mservice::momo::msg::HelloReply* Base::release_hello_reply() {
  clear_has_hello_reply();
  ::com::mservice::momo::msg::HelloReply* temp = hello_reply_;
  hello_reply_ = NULL;
  return temp;
}
inline void Base::set_allocated_hello_reply(::com::mservice::momo::msg::HelloReply* hello_reply) {
  delete hello_reply_;
  hello_reply_ = hello_reply;
  if (hello_reply) {
    set_has_hello_reply();
  } else {
    clear_has_hello_reply();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace msg
}  // namespace momo
}  // namespace mservice
}  // namespace com

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::mservice::momo::msg::Err_ResultCode>() {
  return ::com::mservice::momo::msg::Err_ResultCode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::mservice::momo::msg::HelloReply_ResultCode>() {
  return ::com::mservice::momo::msg::HelloReply_ResultCode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::mservice::momo::msg::Base_MsgType>() {
  return ::com::mservice::momo::msg::Base_MsgType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_MomoMsg__INCLUDED
