// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SoapProto.proto

#ifndef PROTOBUF_SoapProto_2eproto__INCLUDED
#define PROTOBUF_SoapProto_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace com {
namespace mservice {
namespace momo {
namespace msg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_SoapProto_2eproto();
void protobuf_AssignDesc_SoapProto_2eproto();
void protobuf_ShutdownFile_SoapProto_2eproto();

class ZaloGroup;
class keyValuePair;
class commonAdjust;
class BankNetConfirm;
class RegisterInactiveAgent;
class BuyOther;
class BuyGameCard;
class BuyMobilityCard;
class AgentInfoModify;
class DepositCashOther;
class BillPayTelephone;
class BillPayTicketAirline;
class BillPayTicketTrain;
class BillPayInsurance;
class BillPayInternet;
class BillPayOther;
class Err;
class SendSms;
class SendSmsReply;
class RegStatus;
class GetAgentInfoReply;
class Register;
class LogIn;
class GetBillInfo;
class AgentInfo;
class BankOut;
class TopUp;
class TopUpString;
class TopUpReply;
class BankIn;
class M2CTransfer;
class PayOneBillOther;
class M2MTransfer;
class TransferMoney2Place;
class ChangePin;
class RecoveryNewPin;
class PayOneBill;
class PayMultiBills;
class ViewPaymentHistoryByBillId;
class TopUpGame;
class CheckPhoneDetail;
class GetStoreAround;
class QuickDeposit;
class QuickPayment;
class BankNetToMomo;
class BankNetVerifyOtp;
class Broadcast;

enum Err_ResultCode {
  Err_ResultCode_MSG_FORMAT_NOT_CORRECT = 1,
  Err_ResultCode_NUMBER_NOT_VALID = 2
};
bool Err_ResultCode_IsValid(int value);
const Err_ResultCode Err_ResultCode_ResultCode_MIN = Err_ResultCode_MSG_FORMAT_NOT_CORRECT;
const Err_ResultCode Err_ResultCode_ResultCode_MAX = Err_ResultCode_NUMBER_NOT_VALID;
const int Err_ResultCode_ResultCode_ARRAYSIZE = Err_ResultCode_ResultCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* Err_ResultCode_descriptor();
inline const ::std::string& Err_ResultCode_Name(Err_ResultCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    Err_ResultCode_descriptor(), value);
}
inline bool Err_ResultCode_Parse(
    const ::std::string& name, Err_ResultCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Err_ResultCode>(
    Err_ResultCode_descriptor(), name, value);
}
enum GetAgentInfoReply_ResultCode {
  GetAgentInfoReply_ResultCode_SYSTEM_ERROR = -1,
  GetAgentInfoReply_ResultCode_ALL_OK = 0,
  GetAgentInfoReply_ResultCode_PHONE_NUMBER_NOT_CORRECT = 2,
  GetAgentInfoReply_ResultCode_AGENT_NOT_FOUND = 11
};
bool GetAgentInfoReply_ResultCode_IsValid(int value);
const GetAgentInfoReply_ResultCode GetAgentInfoReply_ResultCode_ResultCode_MIN = GetAgentInfoReply_ResultCode_SYSTEM_ERROR;
const GetAgentInfoReply_ResultCode GetAgentInfoReply_ResultCode_ResultCode_MAX = GetAgentInfoReply_ResultCode_AGENT_NOT_FOUND;
const int GetAgentInfoReply_ResultCode_ResultCode_ARRAYSIZE = GetAgentInfoReply_ResultCode_ResultCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* GetAgentInfoReply_ResultCode_descriptor();
inline const ::std::string& GetAgentInfoReply_ResultCode_Name(GetAgentInfoReply_ResultCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    GetAgentInfoReply_ResultCode_descriptor(), value);
}
inline bool GetAgentInfoReply_ResultCode_Parse(
    const ::std::string& name, GetAgentInfoReply_ResultCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GetAgentInfoReply_ResultCode>(
    GetAgentInfoReply_ResultCode_descriptor(), name, value);
}
enum Broadcast_MsgType {
  Broadcast_MsgType_NOTICE = 1,
  Broadcast_MsgType_ADVERTISE = 2,
  Broadcast_MsgType_NEW_USER = 3,
  Broadcast_MsgType_MONEY_REQ = 4,
  Broadcast_MsgType_KILL_PREV = 5,
  Broadcast_MsgType_MONEY_RECV = 6,
  Broadcast_MsgType_TRANS_OUSIDE = 7,
  Broadcast_MsgType_NOTIFICATION = 8,
  Broadcast_MsgType_CHECK_PREV = 9,
  Broadcast_MsgType_PREV_RETURN = 10,
  Broadcast_MsgType_FORCE_UPDATE_AGENT_INFO = 11,
  Broadcast_MsgType_GET_TOKEN = 12
};
bool Broadcast_MsgType_IsValid(int value);
const Broadcast_MsgType Broadcast_MsgType_MsgType_MIN = Broadcast_MsgType_NOTICE;
const Broadcast_MsgType Broadcast_MsgType_MsgType_MAX = Broadcast_MsgType_GET_TOKEN;
const int Broadcast_MsgType_MsgType_ARRAYSIZE = Broadcast_MsgType_MsgType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Broadcast_MsgType_descriptor();
inline const ::std::string& Broadcast_MsgType_Name(Broadcast_MsgType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Broadcast_MsgType_descriptor(), value);
}
inline bool Broadcast_MsgType_Parse(
    const ::std::string& name, Broadcast_MsgType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Broadcast_MsgType>(
    Broadcast_MsgType_descriptor(), name, value);
}
enum MsgType {
  ERR = 5000,
  GET_AGENT_INFO_REPLY = 5002,
  SEND_SMS = 5003,
  SEND_SMS_REPLY = 5004,
  REGISTER = 5005,
  REGISTER_REPLY = 5006,
  LOG_IN = 5007,
  LOG_IN_REPLY = 5008,
  GET_BILL_INFO = 5009,
  BANK_OUT = 5011,
  BANK_IN = 5012,
  M2C_TRANSFER = 5013,
  M2M_TRANSFER = 5014,
  TOP_UP = 5015,
  TOP_UP_REPLY = 5016,
  CHANGE_PIN = 5017,
  TEST = 5018,
  RECOVERY_NEW_PIN = 5019,
  PAY_ONE_BILL = 5020,
  PAY_MULTI_BILLS = 5021,
  VIEW_PAYMENT_HISTORY_BY_BILL_ID = 5022,
  TOPUP_GAME = 5023,
  QUICK_DEPOSIT = 5024,
  QUICK_PAYMENT = 5025,
  BANK_NET_TO_MOMO = 5026,
  BANK_NET_VERIFY_OTP = 5027,
  BANK_NET_ADJUSTMENT = 5028,
  PAY_ONE_BILL_OTHER = 5029,
  TRANSFER_MONEY_TO_PLACE = 5030,
  BILL_PAY_TELEPHONE = 5031,
  BILL_PAY_TICKET_AIRLINE = 5032,
  BILL_PAY_TICKET_TRAIN = 5033,
  BILL_PAY_INSURANCE = 5034,
  BILL_PAY_INTERNET = 5035,
  BILL_PAY_OTHER = 5036,
  DEPOSIT_CASH_OTHER = 5037,
  BUY_MOBILITY_CARD = 5038,
  BUY_GAME_CARD = 5039,
  BUY_OTHER = 5040,
  AGENT_INFO_MODIFY = 5041,
  MUA_123_ADJUSTMENT = 5042,
  REGISTER_INACTIVE_AGENT = 5043,
  CHECK_USER_STATUS = 5044,
  BANK_NET_CONFIRM = 5045,
  MAP_AGENT_TO_ZALO_GROUP = 5046,
  TRA_THUONG_ZALO = 5047,
  GET_AGENT_INFO = 5048,
  GET_BILL_INFO_BY_SERVICE = 5049,
  ADJUSTMENT = 5050,
  TOP_UP_STR = 5051,
  MODIFY_AGENT_EXTRA = 5052,
  MAP_AGENT_TO_VISA_GROUP = 5053,
  MAP_AGENT_TO_DGD_GROUP = 5054,
  M2MERCHANT_TRANSFER = 5055,
  SET_AGENT_NAMED = 5056
};
bool MsgType_IsValid(int value);
const MsgType MsgType_MIN = ERR;
const MsgType MsgType_MAX = SET_AGENT_NAMED;
const int MsgType_ARRAYSIZE = MsgType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MsgType_descriptor();
inline const ::std::string& MsgType_Name(MsgType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgType_descriptor(), value);
}
inline bool MsgType_Parse(
    const ::std::string& name, MsgType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgType>(
    MsgType_descriptor(), name, value);
}
// ===================================================================

class ZaloGroup : public ::google::protobuf::Message {
 public:
  ZaloGroup();
  virtual ~ZaloGroup();

  ZaloGroup(const ZaloGroup& from);

  inline ZaloGroup& operator=(const ZaloGroup& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ZaloGroup& default_instance();

  void Swap(ZaloGroup* other);

  // implements Message ----------------------------------------------

  ZaloGroup* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ZaloGroup& from);
  void MergeFrom(const ZaloGroup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string zalo_group = 1;
  inline bool has_zalo_group() const;
  inline void clear_zalo_group();
  static const int kZaloGroupFieldNumber = 1;
  inline const ::std::string& zalo_group() const;
  inline void set_zalo_group(const ::std::string& value);
  inline void set_zalo_group(const char* value);
  inline void set_zalo_group(const char* value, size_t size);
  inline ::std::string* mutable_zalo_group();
  inline ::std::string* release_zalo_group();
  inline void set_allocated_zalo_group(::std::string* zalo_group);

  // optional string zalo_capset_id = 2;
  inline bool has_zalo_capset_id() const;
  inline void clear_zalo_capset_id();
  static const int kZaloCapsetIdFieldNumber = 2;
  inline const ::std::string& zalo_capset_id() const;
  inline void set_zalo_capset_id(const ::std::string& value);
  inline void set_zalo_capset_id(const char* value);
  inline void set_zalo_capset_id(const char* value, size_t size);
  inline ::std::string* mutable_zalo_capset_id();
  inline ::std::string* release_zalo_capset_id();
  inline void set_allocated_zalo_capset_id(::std::string* zalo_capset_id);

  // optional string zalo_upper_limit = 3;
  inline bool has_zalo_upper_limit() const;
  inline void clear_zalo_upper_limit();
  static const int kZaloUpperLimitFieldNumber = 3;
  inline const ::std::string& zalo_upper_limit() const;
  inline void set_zalo_upper_limit(const ::std::string& value);
  inline void set_zalo_upper_limit(const char* value);
  inline void set_zalo_upper_limit(const char* value, size_t size);
  inline ::std::string* mutable_zalo_upper_limit();
  inline ::std::string* release_zalo_upper_limit();
  inline void set_allocated_zalo_upper_limit(::std::string* zalo_upper_limit);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.ZaloGroup)
 private:
  inline void set_has_zalo_group();
  inline void clear_has_zalo_group();
  inline void set_has_zalo_capset_id();
  inline void clear_has_zalo_capset_id();
  inline void set_has_zalo_upper_limit();
  inline void clear_has_zalo_upper_limit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* zalo_group_;
  ::std::string* zalo_capset_id_;
  ::std::string* zalo_upper_limit_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_SoapProto_2eproto();
  friend void protobuf_AssignDesc_SoapProto_2eproto();
  friend void protobuf_ShutdownFile_SoapProto_2eproto();

  void InitAsDefaultInstance();
  static ZaloGroup* default_instance_;
};
// -------------------------------------------------------------------

class keyValuePair : public ::google::protobuf::Message {
 public:
  keyValuePair();
  virtual ~keyValuePair();

  keyValuePair(const keyValuePair& from);

  inline keyValuePair& operator=(const keyValuePair& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const keyValuePair& default_instance();

  void Swap(keyValuePair* other);

  // implements Message ----------------------------------------------

  keyValuePair* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const keyValuePair& from);
  void MergeFrom(const keyValuePair& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.keyValuePair)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_SoapProto_2eproto();
  friend void protobuf_AssignDesc_SoapProto_2eproto();
  friend void protobuf_ShutdownFile_SoapProto_2eproto();

  void InitAsDefaultInstance();
  static keyValuePair* default_instance_;
};
// -------------------------------------------------------------------

class commonAdjust : public ::google::protobuf::Message {
 public:
  commonAdjust();
  virtual ~commonAdjust();

  commonAdjust(const commonAdjust& from);

  inline commonAdjust& operator=(const commonAdjust& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const commonAdjust& default_instance();

  void Swap(commonAdjust* other);

  // implements Message ----------------------------------------------

  commonAdjust* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const commonAdjust& from);
  void MergeFrom(const commonAdjust& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string source = 1;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 1;
  inline const ::std::string& source() const;
  inline void set_source(const ::std::string& value);
  inline void set_source(const char* value);
  inline void set_source(const char* value, size_t size);
  inline ::std::string* mutable_source();
  inline ::std::string* release_source();
  inline void set_allocated_source(::std::string* source);

  // optional string target = 2;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 2;
  inline const ::std::string& target() const;
  inline void set_target(const ::std::string& value);
  inline void set_target(const char* value);
  inline void set_target(const char* value, size_t size);
  inline ::std::string* mutable_target();
  inline ::std::string* release_target();
  inline void set_allocated_target(::std::string* target);

  // optional uint64 amount = 3;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 3;
  inline ::google::protobuf::uint64 amount() const;
  inline void set_amount(::google::protobuf::uint64 value);

  // optional uint32 walletType = 4;
  inline bool has_wallettype() const;
  inline void clear_wallettype();
  static const int kWalletTypeFieldNumber = 4;
  inline ::google::protobuf::uint32 wallettype() const;
  inline void set_wallettype(::google::protobuf::uint32 value);

  // optional string description = 5;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 5;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // optional uint64 time = 6;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 6;
  inline ::google::protobuf::uint64 time() const;
  inline void set_time(::google::protobuf::uint64 value);

  // optional string phoneNumber = 7;
  inline bool has_phonenumber() const;
  inline void clear_phonenumber();
  static const int kPhoneNumberFieldNumber = 7;
  inline const ::std::string& phonenumber() const;
  inline void set_phonenumber(const ::std::string& value);
  inline void set_phonenumber(const char* value);
  inline void set_phonenumber(const char* value, size_t size);
  inline ::std::string* mutable_phonenumber();
  inline ::std::string* release_phonenumber();
  inline void set_allocated_phonenumber(::std::string* phonenumber);

  // repeated .com.mservice.momo.msg.keyValuePair extra_map = 8;
  inline int extra_map_size() const;
  inline void clear_extra_map();
  static const int kExtraMapFieldNumber = 8;
  inline const ::com::mservice::momo::msg::keyValuePair& extra_map(int index) const;
  inline ::com::mservice::momo::msg::keyValuePair* mutable_extra_map(int index);
  inline ::com::mservice::momo::msg::keyValuePair* add_extra_map();
  inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >&
      extra_map() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >*
      mutable_extra_map();

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.commonAdjust)
 private:
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_target();
  inline void clear_has_target();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_wallettype();
  inline void clear_has_wallettype();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_phonenumber();
  inline void clear_has_phonenumber();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* source_;
  ::std::string* target_;
  ::google::protobuf::uint64 amount_;
  ::std::string* description_;
  ::google::protobuf::uint64 time_;
  ::std::string* phonenumber_;
  ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair > extra_map_;
  ::google::protobuf::uint32 wallettype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_SoapProto_2eproto();
  friend void protobuf_AssignDesc_SoapProto_2eproto();
  friend void protobuf_ShutdownFile_SoapProto_2eproto();

  void InitAsDefaultInstance();
  static commonAdjust* default_instance_;
};
// -------------------------------------------------------------------

class BankNetConfirm : public ::google::protobuf::Message {
 public:
  BankNetConfirm();
  virtual ~BankNetConfirm();

  BankNetConfirm(const BankNetConfirm& from);

  inline BankNetConfirm& operator=(const BankNetConfirm& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BankNetConfirm& default_instance();

  void Swap(BankNetConfirm* other);

  // implements Message ----------------------------------------------

  BankNetConfirm* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BankNetConfirm& from);
  void MergeFrom(const BankNetConfirm& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string merchant_trans_id = 1;
  inline bool has_merchant_trans_id() const;
  inline void clear_merchant_trans_id();
  static const int kMerchantTransIdFieldNumber = 1;
  inline const ::std::string& merchant_trans_id() const;
  inline void set_merchant_trans_id(const ::std::string& value);
  inline void set_merchant_trans_id(const char* value);
  inline void set_merchant_trans_id(const char* value, size_t size);
  inline ::std::string* mutable_merchant_trans_id();
  inline ::std::string* release_merchant_trans_id();
  inline void set_allocated_merchant_trans_id(::std::string* merchant_trans_id);

  // optional string trans_id = 2;
  inline bool has_trans_id() const;
  inline void clear_trans_id();
  static const int kTransIdFieldNumber = 2;
  inline const ::std::string& trans_id() const;
  inline void set_trans_id(const ::std::string& value);
  inline void set_trans_id(const char* value);
  inline void set_trans_id(const char* value, size_t size);
  inline ::std::string* mutable_trans_id();
  inline ::std::string* release_trans_id();
  inline void set_allocated_trans_id(::std::string* trans_id);

  // optional uint32 adjustResult = 3;
  inline bool has_adjustresult() const;
  inline void clear_adjustresult();
  static const int kAdjustResultFieldNumber = 3;
  inline ::google::protobuf::uint32 adjustresult() const;
  inline void set_adjustresult(::google::protobuf::uint32 value);

  // repeated .com.mservice.momo.msg.keyValuePair extra_map = 4;
  inline int extra_map_size() const;
  inline void clear_extra_map();
  static const int kExtraMapFieldNumber = 4;
  inline const ::com::mservice::momo::msg::keyValuePair& extra_map(int index) const;
  inline ::com::mservice::momo::msg::keyValuePair* mutable_extra_map(int index);
  inline ::com::mservice::momo::msg::keyValuePair* add_extra_map();
  inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >&
      extra_map() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >*
      mutable_extra_map();

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.BankNetConfirm)
 private:
  inline void set_has_merchant_trans_id();
  inline void clear_has_merchant_trans_id();
  inline void set_has_trans_id();
  inline void clear_has_trans_id();
  inline void set_has_adjustresult();
  inline void clear_has_adjustresult();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* merchant_trans_id_;
  ::std::string* trans_id_;
  ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair > extra_map_;
  ::google::protobuf::uint32 adjustresult_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_SoapProto_2eproto();
  friend void protobuf_AssignDesc_SoapProto_2eproto();
  friend void protobuf_ShutdownFile_SoapProto_2eproto();

  void InitAsDefaultInstance();
  static BankNetConfirm* default_instance_;
};
// -------------------------------------------------------------------

class RegisterInactiveAgent : public ::google::protobuf::Message {
 public:
  RegisterInactiveAgent();
  virtual ~RegisterInactiveAgent();

  RegisterInactiveAgent(const RegisterInactiveAgent& from);

  inline RegisterInactiveAgent& operator=(const RegisterInactiveAgent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterInactiveAgent& default_instance();

  void Swap(RegisterInactiveAgent* other);

  // implements Message ----------------------------------------------

  RegisterInactiveAgent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterInactiveAgent& from);
  void MergeFrom(const RegisterInactiveAgent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string phone = 1;
  inline bool has_phone() const;
  inline void clear_phone();
  static const int kPhoneFieldNumber = 1;
  inline const ::std::string& phone() const;
  inline void set_phone(const ::std::string& value);
  inline void set_phone(const char* value);
  inline void set_phone(const char* value, size_t size);
  inline ::std::string* mutable_phone();
  inline ::std::string* release_phone();
  inline void set_allocated_phone(::std::string* phone);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string birthday = 3;
  inline bool has_birthday() const;
  inline void clear_birthday();
  static const int kBirthdayFieldNumber = 3;
  inline const ::std::string& birthday() const;
  inline void set_birthday(const ::std::string& value);
  inline void set_birthday(const char* value);
  inline void set_birthday(const char* value, size_t size);
  inline ::std::string* mutable_birthday();
  inline ::std::string* release_birthday();
  inline void set_allocated_birthday(::std::string* birthday);

  // optional string address = 4;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 4;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const char* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // optional string persionalId = 5;
  inline bool has_persionalid() const;
  inline void clear_persionalid();
  static const int kPersionalIdFieldNumber = 5;
  inline const ::std::string& persionalid() const;
  inline void set_persionalid(const ::std::string& value);
  inline void set_persionalid(const char* value);
  inline void set_persionalid(const char* value, size_t size);
  inline ::std::string* mutable_persionalid();
  inline ::std::string* release_persionalid();
  inline void set_allocated_persionalid(::std::string* persionalid);

  // optional string contact = 6;
  inline bool has_contact() const;
  inline void clear_contact();
  static const int kContactFieldNumber = 6;
  inline const ::std::string& contact() const;
  inline void set_contact(const ::std::string& value);
  inline void set_contact(const char* value);
  inline void set_contact(const char* value, size_t size);
  inline ::std::string* mutable_contact();
  inline ::std::string* release_contact();
  inline void set_allocated_contact(::std::string* contact);

  // optional string email = 7;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 7;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // optional string channel = 8;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 8;
  inline const ::std::string& channel() const;
  inline void set_channel(const ::std::string& value);
  inline void set_channel(const char* value);
  inline void set_channel(const char* value, size_t size);
  inline ::std::string* mutable_channel();
  inline ::std::string* release_channel();
  inline void set_allocated_channel(::std::string* channel);

  // optional string arr_capset = 9;
  inline bool has_arr_capset() const;
  inline void clear_arr_capset();
  static const int kArrCapsetFieldNumber = 9;
  inline const ::std::string& arr_capset() const;
  inline void set_arr_capset(const ::std::string& value);
  inline void set_arr_capset(const char* value);
  inline void set_arr_capset(const char* value, size_t size);
  inline ::std::string* mutable_arr_capset();
  inline ::std::string* release_arr_capset();
  inline void set_allocated_arr_capset(::std::string* arr_capset);

  // optional string upper_limit = 10;
  inline bool has_upper_limit() const;
  inline void clear_upper_limit();
  static const int kUpperLimitFieldNumber = 10;
  inline const ::std::string& upper_limit() const;
  inline void set_upper_limit(const ::std::string& value);
  inline void set_upper_limit(const char* value);
  inline void set_upper_limit(const char* value, size_t size);
  inline ::std::string* mutable_upper_limit();
  inline ::std::string* release_upper_limit();
  inline void set_allocated_upper_limit(::std::string* upper_limit);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.RegisterInactiveAgent)
 private:
  inline void set_has_phone();
  inline void clear_has_phone();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_birthday();
  inline void clear_has_birthday();
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_persionalid();
  inline void clear_has_persionalid();
  inline void set_has_contact();
  inline void clear_has_contact();
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_arr_capset();
  inline void clear_has_arr_capset();
  inline void set_has_upper_limit();
  inline void clear_has_upper_limit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* phone_;
  ::std::string* name_;
  ::std::string* birthday_;
  ::std::string* address_;
  ::std::string* persionalid_;
  ::std::string* contact_;
  ::std::string* email_;
  ::std::string* channel_;
  ::std::string* arr_capset_;
  ::std::string* upper_limit_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_SoapProto_2eproto();
  friend void protobuf_AssignDesc_SoapProto_2eproto();
  friend void protobuf_ShutdownFile_SoapProto_2eproto();

  void InitAsDefaultInstance();
  static RegisterInactiveAgent* default_instance_;
};
// -------------------------------------------------------------------

class BuyOther : public ::google::protobuf::Message {
 public:
  BuyOther();
  virtual ~BuyOther();

  BuyOther(const BuyOther& from);

  inline BuyOther& operator=(const BuyOther& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuyOther& default_instance();

  void Swap(BuyOther* other);

  // implements Message ----------------------------------------------

  BuyOther* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BuyOther& from);
  void MergeFrom(const BuyOther& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string providerId = 1;
  inline bool has_providerid() const;
  inline void clear_providerid();
  static const int kProviderIdFieldNumber = 1;
  inline const ::std::string& providerid() const;
  inline void set_providerid(const ::std::string& value);
  inline void set_providerid(const char* value);
  inline void set_providerid(const char* value, size_t size);
  inline ::std::string* mutable_providerid();
  inline ::std::string* release_providerid();
  inline void set_allocated_providerid(::std::string* providerid);

  // optional string amount = 2;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 2;
  inline const ::std::string& amount() const;
  inline void set_amount(const ::std::string& value);
  inline void set_amount(const char* value);
  inline void set_amount(const char* value, size_t size);
  inline ::std::string* mutable_amount();
  inline ::std::string* release_amount();
  inline void set_allocated_amount(::std::string* amount);

  // optional string pin = 3;
  inline bool has_pin() const;
  inline void clear_pin();
  static const int kPinFieldNumber = 3;
  inline const ::std::string& pin() const;
  inline void set_pin(const ::std::string& value);
  inline void set_pin(const char* value);
  inline void set_pin(const char* value, size_t size);
  inline ::std::string* mutable_pin();
  inline ::std::string* release_pin();
  inline void set_allocated_pin(::std::string* pin);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.BuyOther)
 private:
  inline void set_has_providerid();
  inline void clear_has_providerid();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_pin();
  inline void clear_has_pin();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* providerid_;
  ::std::string* amount_;
  ::std::string* pin_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_SoapProto_2eproto();
  friend void protobuf_AssignDesc_SoapProto_2eproto();
  friend void protobuf_ShutdownFile_SoapProto_2eproto();

  void InitAsDefaultInstance();
  static BuyOther* default_instance_;
};
// -------------------------------------------------------------------

class BuyGameCard : public ::google::protobuf::Message {
 public:
  BuyGameCard();
  virtual ~BuyGameCard();

  BuyGameCard(const BuyGameCard& from);

  inline BuyGameCard& operator=(const BuyGameCard& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuyGameCard& default_instance();

  void Swap(BuyGameCard* other);

  // implements Message ----------------------------------------------

  BuyGameCard* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BuyGameCard& from);
  void MergeFrom(const BuyGameCard& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string providerId = 1;
  inline bool has_providerid() const;
  inline void clear_providerid();
  static const int kProviderIdFieldNumber = 1;
  inline const ::std::string& providerid() const;
  inline void set_providerid(const ::std::string& value);
  inline void set_providerid(const char* value);
  inline void set_providerid(const char* value, size_t size);
  inline ::std::string* mutable_providerid();
  inline ::std::string* release_providerid();
  inline void set_allocated_providerid(::std::string* providerid);

  // optional string amount = 2;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 2;
  inline const ::std::string& amount() const;
  inline void set_amount(const ::std::string& value);
  inline void set_amount(const char* value);
  inline void set_amount(const char* value, size_t size);
  inline ::std::string* mutable_amount();
  inline ::std::string* release_amount();
  inline void set_allocated_amount(::std::string* amount);

  // optional string pin = 3;
  inline bool has_pin() const;
  inline void clear_pin();
  static const int kPinFieldNumber = 3;
  inline const ::std::string& pin() const;
  inline void set_pin(const ::std::string& value);
  inline void set_pin(const char* value);
  inline void set_pin(const char* value, size_t size);
  inline ::std::string* mutable_pin();
  inline ::std::string* release_pin();
  inline void set_allocated_pin(::std::string* pin);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.BuyGameCard)
 private:
  inline void set_has_providerid();
  inline void clear_has_providerid();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_pin();
  inline void clear_has_pin();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* providerid_;
  ::std::string* amount_;
  ::std::string* pin_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_SoapProto_2eproto();
  friend void protobuf_AssignDesc_SoapProto_2eproto();
  friend void protobuf_ShutdownFile_SoapProto_2eproto();

  void InitAsDefaultInstance();
  static BuyGameCard* default_instance_;
};
// -------------------------------------------------------------------

class BuyMobilityCard : public ::google::protobuf::Message {
 public:
  BuyMobilityCard();
  virtual ~BuyMobilityCard();

  BuyMobilityCard(const BuyMobilityCard& from);

  inline BuyMobilityCard& operator=(const BuyMobilityCard& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuyMobilityCard& default_instance();

  void Swap(BuyMobilityCard* other);

  // implements Message ----------------------------------------------

  BuyMobilityCard* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BuyMobilityCard& from);
  void MergeFrom(const BuyMobilityCard& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string providerId = 1;
  inline bool has_providerid() const;
  inline void clear_providerid();
  static const int kProviderIdFieldNumber = 1;
  inline const ::std::string& providerid() const;
  inline void set_providerid(const ::std::string& value);
  inline void set_providerid(const char* value);
  inline void set_providerid(const char* value, size_t size);
  inline ::std::string* mutable_providerid();
  inline ::std::string* release_providerid();
  inline void set_allocated_providerid(::std::string* providerid);

  // optional string amount = 2;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 2;
  inline const ::std::string& amount() const;
  inline void set_amount(const ::std::string& value);
  inline void set_amount(const char* value);
  inline void set_amount(const char* value, size_t size);
  inline ::std::string* mutable_amount();
  inline ::std::string* release_amount();
  inline void set_allocated_amount(::std::string* amount);

  // optional string pin = 3;
  inline bool has_pin() const;
  inline void clear_pin();
  static const int kPinFieldNumber = 3;
  inline const ::std::string& pin() const;
  inline void set_pin(const ::std::string& value);
  inline void set_pin(const char* value);
  inline void set_pin(const char* value, size_t size);
  inline ::std::string* mutable_pin();
  inline ::std::string* release_pin();
  inline void set_allocated_pin(::std::string* pin);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.BuyMobilityCard)
 private:
  inline void set_has_providerid();
  inline void clear_has_providerid();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_pin();
  inline void clear_has_pin();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* providerid_;
  ::std::string* amount_;
  ::std::string* pin_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_SoapProto_2eproto();
  friend void protobuf_AssignDesc_SoapProto_2eproto();
  friend void protobuf_ShutdownFile_SoapProto_2eproto();

  void InitAsDefaultInstance();
  static BuyMobilityCard* default_instance_;
};
// -------------------------------------------------------------------

class AgentInfoModify : public ::google::protobuf::Message {
 public:
  AgentInfoModify();
  virtual ~AgentInfoModify();

  AgentInfoModify(const AgentInfoModify& from);

  inline AgentInfoModify& operator=(const AgentInfoModify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AgentInfoModify& default_instance();

  void Swap(AgentInfoModify* other);

  // implements Message ----------------------------------------------

  AgentInfoModify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AgentInfoModify& from);
  void MergeFrom(const AgentInfoModify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string card_id = 2;
  inline bool has_card_id() const;
  inline void clear_card_id();
  static const int kCardIdFieldNumber = 2;
  inline const ::std::string& card_id() const;
  inline void set_card_id(const ::std::string& value);
  inline void set_card_id(const char* value);
  inline void set_card_id(const char* value, size_t size);
  inline ::std::string* mutable_card_id();
  inline ::std::string* release_card_id();
  inline void set_allocated_card_id(::std::string* card_id);

  // optional string address = 3;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 3;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const char* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // optional string email = 4;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 4;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // optional string dob = 5;
  inline bool has_dob() const;
  inline void clear_dob();
  static const int kDobFieldNumber = 5;
  inline const ::std::string& dob() const;
  inline void set_dob(const ::std::string& value);
  inline void set_dob(const char* value);
  inline void set_dob(const char* value, size_t size);
  inline ::std::string* mutable_dob();
  inline ::std::string* release_dob();
  inline void set_allocated_dob(::std::string* dob);

  // repeated .com.mservice.momo.msg.keyValuePair kvps = 6;
  inline int kvps_size() const;
  inline void clear_kvps();
  static const int kKvpsFieldNumber = 6;
  inline const ::com::mservice::momo::msg::keyValuePair& kvps(int index) const;
  inline ::com::mservice::momo::msg::keyValuePair* mutable_kvps(int index);
  inline ::com::mservice::momo::msg::keyValuePair* add_kvps();
  inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >&
      kvps() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >*
      mutable_kvps();

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.AgentInfoModify)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_card_id();
  inline void clear_has_card_id();
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_dob();
  inline void clear_has_dob();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* card_id_;
  ::std::string* address_;
  ::std::string* email_;
  ::std::string* dob_;
  ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair > kvps_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_SoapProto_2eproto();
  friend void protobuf_AssignDesc_SoapProto_2eproto();
  friend void protobuf_ShutdownFile_SoapProto_2eproto();

  void InitAsDefaultInstance();
  static AgentInfoModify* default_instance_;
};
// -------------------------------------------------------------------

class DepositCashOther : public ::google::protobuf::Message {
 public:
  DepositCashOther();
  virtual ~DepositCashOther();

  DepositCashOther(const DepositCashOther& from);

  inline DepositCashOther& operator=(const DepositCashOther& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DepositCashOther& default_instance();

  void Swap(DepositCashOther* other);

  // implements Message ----------------------------------------------

  DepositCashOther* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DepositCashOther& from);
  void MergeFrom(const DepositCashOther& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string providerId = 1;
  inline bool has_providerid() const;
  inline void clear_providerid();
  static const int kProviderIdFieldNumber = 1;
  inline const ::std::string& providerid() const;
  inline void set_providerid(const ::std::string& value);
  inline void set_providerid(const char* value);
  inline void set_providerid(const char* value, size_t size);
  inline ::std::string* mutable_providerid();
  inline ::std::string* release_providerid();
  inline void set_allocated_providerid(::std::string* providerid);

  // optional string customerAcc = 2;
  inline bool has_customeracc() const;
  inline void clear_customeracc();
  static const int kCustomerAccFieldNumber = 2;
  inline const ::std::string& customeracc() const;
  inline void set_customeracc(const ::std::string& value);
  inline void set_customeracc(const char* value);
  inline void set_customeracc(const char* value, size_t size);
  inline ::std::string* mutable_customeracc();
  inline ::std::string* release_customeracc();
  inline void set_allocated_customeracc(::std::string* customeracc);

  // optional string pin = 3;
  inline bool has_pin() const;
  inline void clear_pin();
  static const int kPinFieldNumber = 3;
  inline const ::std::string& pin() const;
  inline void set_pin(const ::std::string& value);
  inline void set_pin(const char* value);
  inline void set_pin(const char* value, size_t size);
  inline ::std::string* mutable_pin();
  inline ::std::string* release_pin();
  inline void set_allocated_pin(::std::string* pin);

  // optional uint64 amount = 4;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 4;
  inline ::google::protobuf::uint64 amount() const;
  inline void set_amount(::google::protobuf::uint64 value);

  // optional string channel = 5;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 5;
  inline const ::std::string& channel() const;
  inline void set_channel(const ::std::string& value);
  inline void set_channel(const char* value);
  inline void set_channel(const char* value, size_t size);
  inline ::std::string* mutable_channel();
  inline ::std::string* release_channel();
  inline void set_allocated_channel(::std::string* channel);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.DepositCashOther)
 private:
  inline void set_has_providerid();
  inline void clear_has_providerid();
  inline void set_has_customeracc();
  inline void clear_has_customeracc();
  inline void set_has_pin();
  inline void clear_has_pin();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_channel();
  inline void clear_has_channel();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* providerid_;
  ::std::string* customeracc_;
  ::std::string* pin_;
  ::google::protobuf::uint64 amount_;
  ::std::string* channel_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_SoapProto_2eproto();
  friend void protobuf_AssignDesc_SoapProto_2eproto();
  friend void protobuf_ShutdownFile_SoapProto_2eproto();

  void InitAsDefaultInstance();
  static DepositCashOther* default_instance_;
};
// -------------------------------------------------------------------

class BillPayTelephone : public ::google::protobuf::Message {
 public:
  BillPayTelephone();
  virtual ~BillPayTelephone();

  BillPayTelephone(const BillPayTelephone& from);

  inline BillPayTelephone& operator=(const BillPayTelephone& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BillPayTelephone& default_instance();

  void Swap(BillPayTelephone* other);

  // implements Message ----------------------------------------------

  BillPayTelephone* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BillPayTelephone& from);
  void MergeFrom(const BillPayTelephone& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string providerId = 1;
  inline bool has_providerid() const;
  inline void clear_providerid();
  static const int kProviderIdFieldNumber = 1;
  inline const ::std::string& providerid() const;
  inline void set_providerid(const ::std::string& value);
  inline void set_providerid(const char* value);
  inline void set_providerid(const char* value, size_t size);
  inline ::std::string* mutable_providerid();
  inline ::std::string* release_providerid();
  inline void set_allocated_providerid(::std::string* providerid);

  // optional string phone = 2;
  inline bool has_phone() const;
  inline void clear_phone();
  static const int kPhoneFieldNumber = 2;
  inline const ::std::string& phone() const;
  inline void set_phone(const ::std::string& value);
  inline void set_phone(const char* value);
  inline void set_phone(const char* value, size_t size);
  inline ::std::string* mutable_phone();
  inline ::std::string* release_phone();
  inline void set_allocated_phone(::std::string* phone);

  // optional string areaId = 3;
  inline bool has_areaid() const;
  inline void clear_areaid();
  static const int kAreaIdFieldNumber = 3;
  inline const ::std::string& areaid() const;
  inline void set_areaid(const ::std::string& value);
  inline void set_areaid(const char* value);
  inline void set_areaid(const char* value, size_t size);
  inline ::std::string* mutable_areaid();
  inline ::std::string* release_areaid();
  inline void set_allocated_areaid(::std::string* areaid);

  // optional string pin = 4;
  inline bool has_pin() const;
  inline void clear_pin();
  static const int kPinFieldNumber = 4;
  inline const ::std::string& pin() const;
  inline void set_pin(const ::std::string& value);
  inline void set_pin(const char* value);
  inline void set_pin(const char* value, size_t size);
  inline ::std::string* mutable_pin();
  inline ::std::string* release_pin();
  inline void set_allocated_pin(::std::string* pin);

  // optional uint64 amount = 5;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 5;
  inline ::google::protobuf::uint64 amount() const;
  inline void set_amount(::google::protobuf::uint64 value);

  // optional string channel = 6;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 6;
  inline const ::std::string& channel() const;
  inline void set_channel(const ::std::string& value);
  inline void set_channel(const char* value);
  inline void set_channel(const char* value, size_t size);
  inline ::std::string* mutable_channel();
  inline ::std::string* release_channel();
  inline void set_allocated_channel(::std::string* channel);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.BillPayTelephone)
 private:
  inline void set_has_providerid();
  inline void clear_has_providerid();
  inline void set_has_phone();
  inline void clear_has_phone();
  inline void set_has_areaid();
  inline void clear_has_areaid();
  inline void set_has_pin();
  inline void clear_has_pin();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_channel();
  inline void clear_has_channel();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* providerid_;
  ::std::string* phone_;
  ::std::string* areaid_;
  ::std::string* pin_;
  ::google::protobuf::uint64 amount_;
  ::std::string* channel_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_SoapProto_2eproto();
  friend void protobuf_AssignDesc_SoapProto_2eproto();
  friend void protobuf_ShutdownFile_SoapProto_2eproto();

  void InitAsDefaultInstance();
  static BillPayTelephone* default_instance_;
};
// -------------------------------------------------------------------

class BillPayTicketAirline : public ::google::protobuf::Message {
 public:
  BillPayTicketAirline();
  virtual ~BillPayTicketAirline();

  BillPayTicketAirline(const BillPayTicketAirline& from);

  inline BillPayTicketAirline& operator=(const BillPayTicketAirline& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BillPayTicketAirline& default_instance();

  void Swap(BillPayTicketAirline* other);

  // implements Message ----------------------------------------------

  BillPayTicketAirline* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BillPayTicketAirline& from);
  void MergeFrom(const BillPayTicketAirline& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string providerId = 1;
  inline bool has_providerid() const;
  inline void clear_providerid();
  static const int kProviderIdFieldNumber = 1;
  inline const ::std::string& providerid() const;
  inline void set_providerid(const ::std::string& value);
  inline void set_providerid(const char* value);
  inline void set_providerid(const char* value, size_t size);
  inline ::std::string* mutable_providerid();
  inline ::std::string* release_providerid();
  inline void set_allocated_providerid(::std::string* providerid);

  // optional string ticketId = 2;
  inline bool has_ticketid() const;
  inline void clear_ticketid();
  static const int kTicketIdFieldNumber = 2;
  inline const ::std::string& ticketid() const;
  inline void set_ticketid(const ::std::string& value);
  inline void set_ticketid(const char* value);
  inline void set_ticketid(const char* value, size_t size);
  inline ::std::string* mutable_ticketid();
  inline ::std::string* release_ticketid();
  inline void set_allocated_ticketid(::std::string* ticketid);

  // optional string pin = 3;
  inline bool has_pin() const;
  inline void clear_pin();
  static const int kPinFieldNumber = 3;
  inline const ::std::string& pin() const;
  inline void set_pin(const ::std::string& value);
  inline void set_pin(const char* value);
  inline void set_pin(const char* value, size_t size);
  inline ::std::string* mutable_pin();
  inline ::std::string* release_pin();
  inline void set_allocated_pin(::std::string* pin);

  // optional uint64 amount = 4;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 4;
  inline ::google::protobuf::uint64 amount() const;
  inline void set_amount(::google::protobuf::uint64 value);

  // optional string channel = 5;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 5;
  inline const ::std::string& channel() const;
  inline void set_channel(const ::std::string& value);
  inline void set_channel(const char* value);
  inline void set_channel(const char* value, size_t size);
  inline ::std::string* mutable_channel();
  inline ::std::string* release_channel();
  inline void set_allocated_channel(::std::string* channel);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.BillPayTicketAirline)
 private:
  inline void set_has_providerid();
  inline void clear_has_providerid();
  inline void set_has_ticketid();
  inline void clear_has_ticketid();
  inline void set_has_pin();
  inline void clear_has_pin();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_channel();
  inline void clear_has_channel();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* providerid_;
  ::std::string* ticketid_;
  ::std::string* pin_;
  ::google::protobuf::uint64 amount_;
  ::std::string* channel_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_SoapProto_2eproto();
  friend void protobuf_AssignDesc_SoapProto_2eproto();
  friend void protobuf_ShutdownFile_SoapProto_2eproto();

  void InitAsDefaultInstance();
  static BillPayTicketAirline* default_instance_;
};
// -------------------------------------------------------------------

class BillPayTicketTrain : public ::google::protobuf::Message {
 public:
  BillPayTicketTrain();
  virtual ~BillPayTicketTrain();

  BillPayTicketTrain(const BillPayTicketTrain& from);

  inline BillPayTicketTrain& operator=(const BillPayTicketTrain& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BillPayTicketTrain& default_instance();

  void Swap(BillPayTicketTrain* other);

  // implements Message ----------------------------------------------

  BillPayTicketTrain* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BillPayTicketTrain& from);
  void MergeFrom(const BillPayTicketTrain& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string placeId = 1;
  inline bool has_placeid() const;
  inline void clear_placeid();
  static const int kPlaceIdFieldNumber = 1;
  inline const ::std::string& placeid() const;
  inline void set_placeid(const ::std::string& value);
  inline void set_placeid(const char* value);
  inline void set_placeid(const char* value, size_t size);
  inline ::std::string* mutable_placeid();
  inline ::std::string* release_placeid();
  inline void set_allocated_placeid(::std::string* placeid);

  // optional string ticketId = 2;
  inline bool has_ticketid() const;
  inline void clear_ticketid();
  static const int kTicketIdFieldNumber = 2;
  inline const ::std::string& ticketid() const;
  inline void set_ticketid(const ::std::string& value);
  inline void set_ticketid(const char* value);
  inline void set_ticketid(const char* value, size_t size);
  inline ::std::string* mutable_ticketid();
  inline ::std::string* release_ticketid();
  inline void set_allocated_ticketid(::std::string* ticketid);

  // optional string pin = 3;
  inline bool has_pin() const;
  inline void clear_pin();
  static const int kPinFieldNumber = 3;
  inline const ::std::string& pin() const;
  inline void set_pin(const ::std::string& value);
  inline void set_pin(const char* value);
  inline void set_pin(const char* value, size_t size);
  inline ::std::string* mutable_pin();
  inline ::std::string* release_pin();
  inline void set_allocated_pin(::std::string* pin);

  // optional uint64 amount = 4;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 4;
  inline ::google::protobuf::uint64 amount() const;
  inline void set_amount(::google::protobuf::uint64 value);

  // optional string providerId = 5;
  inline bool has_providerid() const;
  inline void clear_providerid();
  static const int kProviderIdFieldNumber = 5;
  inline const ::std::string& providerid() const;
  inline void set_providerid(const ::std::string& value);
  inline void set_providerid(const char* value);
  inline void set_providerid(const char* value, size_t size);
  inline ::std::string* mutable_providerid();
  inline ::std::string* release_providerid();
  inline void set_allocated_providerid(::std::string* providerid);

  // optional string channel = 6;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 6;
  inline const ::std::string& channel() const;
  inline void set_channel(const ::std::string& value);
  inline void set_channel(const char* value);
  inline void set_channel(const char* value, size_t size);
  inline ::std::string* mutable_channel();
  inline ::std::string* release_channel();
  inline void set_allocated_channel(::std::string* channel);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.BillPayTicketTrain)
 private:
  inline void set_has_placeid();
  inline void clear_has_placeid();
  inline void set_has_ticketid();
  inline void clear_has_ticketid();
  inline void set_has_pin();
  inline void clear_has_pin();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_providerid();
  inline void clear_has_providerid();
  inline void set_has_channel();
  inline void clear_has_channel();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* placeid_;
  ::std::string* ticketid_;
  ::std::string* pin_;
  ::google::protobuf::uint64 amount_;
  ::std::string* providerid_;
  ::std::string* channel_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_SoapProto_2eproto();
  friend void protobuf_AssignDesc_SoapProto_2eproto();
  friend void protobuf_ShutdownFile_SoapProto_2eproto();

  void InitAsDefaultInstance();
  static BillPayTicketTrain* default_instance_;
};
// -------------------------------------------------------------------

class BillPayInsurance : public ::google::protobuf::Message {
 public:
  BillPayInsurance();
  virtual ~BillPayInsurance();

  BillPayInsurance(const BillPayInsurance& from);

  inline BillPayInsurance& operator=(const BillPayInsurance& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BillPayInsurance& default_instance();

  void Swap(BillPayInsurance* other);

  // implements Message ----------------------------------------------

  BillPayInsurance* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BillPayInsurance& from);
  void MergeFrom(const BillPayInsurance& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string providerId = 1;
  inline bool has_providerid() const;
  inline void clear_providerid();
  static const int kProviderIdFieldNumber = 1;
  inline const ::std::string& providerid() const;
  inline void set_providerid(const ::std::string& value);
  inline void set_providerid(const char* value);
  inline void set_providerid(const char* value, size_t size);
  inline ::std::string* mutable_providerid();
  inline ::std::string* release_providerid();
  inline void set_allocated_providerid(::std::string* providerid);

  // optional string insuranceAcc = 2;
  inline bool has_insuranceacc() const;
  inline void clear_insuranceacc();
  static const int kInsuranceAccFieldNumber = 2;
  inline const ::std::string& insuranceacc() const;
  inline void set_insuranceacc(const ::std::string& value);
  inline void set_insuranceacc(const char* value);
  inline void set_insuranceacc(const char* value, size_t size);
  inline ::std::string* mutable_insuranceacc();
  inline ::std::string* release_insuranceacc();
  inline void set_allocated_insuranceacc(::std::string* insuranceacc);

  // optional string pin = 3;
  inline bool has_pin() const;
  inline void clear_pin();
  static const int kPinFieldNumber = 3;
  inline const ::std::string& pin() const;
  inline void set_pin(const ::std::string& value);
  inline void set_pin(const char* value);
  inline void set_pin(const char* value, size_t size);
  inline ::std::string* mutable_pin();
  inline ::std::string* release_pin();
  inline void set_allocated_pin(::std::string* pin);

  // optional uint64 amount = 4;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 4;
  inline ::google::protobuf::uint64 amount() const;
  inline void set_amount(::google::protobuf::uint64 value);

  // optional string channel = 5;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 5;
  inline const ::std::string& channel() const;
  inline void set_channel(const ::std::string& value);
  inline void set_channel(const char* value);
  inline void set_channel(const char* value, size_t size);
  inline ::std::string* mutable_channel();
  inline ::std::string* release_channel();
  inline void set_allocated_channel(::std::string* channel);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.BillPayInsurance)
 private:
  inline void set_has_providerid();
  inline void clear_has_providerid();
  inline void set_has_insuranceacc();
  inline void clear_has_insuranceacc();
  inline void set_has_pin();
  inline void clear_has_pin();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_channel();
  inline void clear_has_channel();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* providerid_;
  ::std::string* insuranceacc_;
  ::std::string* pin_;
  ::google::protobuf::uint64 amount_;
  ::std::string* channel_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_SoapProto_2eproto();
  friend void protobuf_AssignDesc_SoapProto_2eproto();
  friend void protobuf_ShutdownFile_SoapProto_2eproto();

  void InitAsDefaultInstance();
  static BillPayInsurance* default_instance_;
};
// -------------------------------------------------------------------

class BillPayInternet : public ::google::protobuf::Message {
 public:
  BillPayInternet();
  virtual ~BillPayInternet();

  BillPayInternet(const BillPayInternet& from);

  inline BillPayInternet& operator=(const BillPayInternet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BillPayInternet& default_instance();

  void Swap(BillPayInternet* other);

  // implements Message ----------------------------------------------

  BillPayInternet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BillPayInternet& from);
  void MergeFrom(const BillPayInternet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string providerId = 1;
  inline bool has_providerid() const;
  inline void clear_providerid();
  static const int kProviderIdFieldNumber = 1;
  inline const ::std::string& providerid() const;
  inline void set_providerid(const ::std::string& value);
  inline void set_providerid(const char* value);
  inline void set_providerid(const char* value, size_t size);
  inline ::std::string* mutable_providerid();
  inline ::std::string* release_providerid();
  inline void set_allocated_providerid(::std::string* providerid);

  // optional string customerAcc = 2;
  inline bool has_customeracc() const;
  inline void clear_customeracc();
  static const int kCustomerAccFieldNumber = 2;
  inline const ::std::string& customeracc() const;
  inline void set_customeracc(const ::std::string& value);
  inline void set_customeracc(const char* value);
  inline void set_customeracc(const char* value, size_t size);
  inline ::std::string* mutable_customeracc();
  inline ::std::string* release_customeracc();
  inline void set_allocated_customeracc(::std::string* customeracc);

  // optional string areaId = 3;
  inline bool has_areaid() const;
  inline void clear_areaid();
  static const int kAreaIdFieldNumber = 3;
  inline const ::std::string& areaid() const;
  inline void set_areaid(const ::std::string& value);
  inline void set_areaid(const char* value);
  inline void set_areaid(const char* value, size_t size);
  inline ::std::string* mutable_areaid();
  inline ::std::string* release_areaid();
  inline void set_allocated_areaid(::std::string* areaid);

  // optional string pin = 4;
  inline bool has_pin() const;
  inline void clear_pin();
  static const int kPinFieldNumber = 4;
  inline const ::std::string& pin() const;
  inline void set_pin(const ::std::string& value);
  inline void set_pin(const char* value);
  inline void set_pin(const char* value, size_t size);
  inline ::std::string* mutable_pin();
  inline ::std::string* release_pin();
  inline void set_allocated_pin(::std::string* pin);

  // optional uint64 amount = 5;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 5;
  inline ::google::protobuf::uint64 amount() const;
  inline void set_amount(::google::protobuf::uint64 value);

  // optional string channel = 6;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 6;
  inline const ::std::string& channel() const;
  inline void set_channel(const ::std::string& value);
  inline void set_channel(const char* value);
  inline void set_channel(const char* value, size_t size);
  inline ::std::string* mutable_channel();
  inline ::std::string* release_channel();
  inline void set_allocated_channel(::std::string* channel);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.BillPayInternet)
 private:
  inline void set_has_providerid();
  inline void clear_has_providerid();
  inline void set_has_customeracc();
  inline void clear_has_customeracc();
  inline void set_has_areaid();
  inline void clear_has_areaid();
  inline void set_has_pin();
  inline void clear_has_pin();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_channel();
  inline void clear_has_channel();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* providerid_;
  ::std::string* customeracc_;
  ::std::string* areaid_;
  ::std::string* pin_;
  ::google::protobuf::uint64 amount_;
  ::std::string* channel_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_SoapProto_2eproto();
  friend void protobuf_AssignDesc_SoapProto_2eproto();
  friend void protobuf_ShutdownFile_SoapProto_2eproto();

  void InitAsDefaultInstance();
  static BillPayInternet* default_instance_;
};
// -------------------------------------------------------------------

class BillPayOther : public ::google::protobuf::Message {
 public:
  BillPayOther();
  virtual ~BillPayOther();

  BillPayOther(const BillPayOther& from);

  inline BillPayOther& operator=(const BillPayOther& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BillPayOther& default_instance();

  void Swap(BillPayOther* other);

  // implements Message ----------------------------------------------

  BillPayOther* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BillPayOther& from);
  void MergeFrom(const BillPayOther& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string providerId = 1;
  inline bool has_providerid() const;
  inline void clear_providerid();
  static const int kProviderIdFieldNumber = 1;
  inline const ::std::string& providerid() const;
  inline void set_providerid(const ::std::string& value);
  inline void set_providerid(const char* value);
  inline void set_providerid(const char* value, size_t size);
  inline ::std::string* mutable_providerid();
  inline ::std::string* release_providerid();
  inline void set_allocated_providerid(::std::string* providerid);

  // optional string billerId = 2;
  inline bool has_billerid() const;
  inline void clear_billerid();
  static const int kBillerIdFieldNumber = 2;
  inline const ::std::string& billerid() const;
  inline void set_billerid(const ::std::string& value);
  inline void set_billerid(const char* value);
  inline void set_billerid(const char* value, size_t size);
  inline ::std::string* mutable_billerid();
  inline ::std::string* release_billerid();
  inline void set_allocated_billerid(::std::string* billerid);

  // optional string areaId = 3;
  inline bool has_areaid() const;
  inline void clear_areaid();
  static const int kAreaIdFieldNumber = 3;
  inline const ::std::string& areaid() const;
  inline void set_areaid(const ::std::string& value);
  inline void set_areaid(const char* value);
  inline void set_areaid(const char* value, size_t size);
  inline ::std::string* mutable_areaid();
  inline ::std::string* release_areaid();
  inline void set_allocated_areaid(::std::string* areaid);

  // optional string pin = 4;
  inline bool has_pin() const;
  inline void clear_pin();
  static const int kPinFieldNumber = 4;
  inline const ::std::string& pin() const;
  inline void set_pin(const ::std::string& value);
  inline void set_pin(const char* value);
  inline void set_pin(const char* value, size_t size);
  inline ::std::string* mutable_pin();
  inline ::std::string* release_pin();
  inline void set_allocated_pin(::std::string* pin);

  // optional uint64 amount = 5;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 5;
  inline ::google::protobuf::uint64 amount() const;
  inline void set_amount(::google::protobuf::uint64 value);

  // optional string channel = 6;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 6;
  inline const ::std::string& channel() const;
  inline void set_channel(const ::std::string& value);
  inline void set_channel(const char* value);
  inline void set_channel(const char* value, size_t size);
  inline ::std::string* mutable_channel();
  inline ::std::string* release_channel();
  inline void set_allocated_channel(::std::string* channel);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.BillPayOther)
 private:
  inline void set_has_providerid();
  inline void clear_has_providerid();
  inline void set_has_billerid();
  inline void clear_has_billerid();
  inline void set_has_areaid();
  inline void clear_has_areaid();
  inline void set_has_pin();
  inline void clear_has_pin();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_channel();
  inline void clear_has_channel();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* providerid_;
  ::std::string* billerid_;
  ::std::string* areaid_;
  ::std::string* pin_;
  ::google::protobuf::uint64 amount_;
  ::std::string* channel_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_SoapProto_2eproto();
  friend void protobuf_AssignDesc_SoapProto_2eproto();
  friend void protobuf_ShutdownFile_SoapProto_2eproto();

  void InitAsDefaultInstance();
  static BillPayOther* default_instance_;
};
// -------------------------------------------------------------------

class Err : public ::google::protobuf::Message {
 public:
  Err();
  virtual ~Err();

  Err(const Err& from);

  inline Err& operator=(const Err& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Err& default_instance();

  void Swap(Err* other);

  // implements Message ----------------------------------------------

  Err* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Err& from);
  void MergeFrom(const Err& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Err_ResultCode ResultCode;
  static const ResultCode MSG_FORMAT_NOT_CORRECT = Err_ResultCode_MSG_FORMAT_NOT_CORRECT;
  static const ResultCode NUMBER_NOT_VALID = Err_ResultCode_NUMBER_NOT_VALID;
  static inline bool ResultCode_IsValid(int value) {
    return Err_ResultCode_IsValid(value);
  }
  static const ResultCode ResultCode_MIN =
    Err_ResultCode_ResultCode_MIN;
  static const ResultCode ResultCode_MAX =
    Err_ResultCode_ResultCode_MAX;
  static const int ResultCode_ARRAYSIZE =
    Err_ResultCode_ResultCode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ResultCode_descriptor() {
    return Err_ResultCode_descriptor();
  }
  static inline const ::std::string& ResultCode_Name(ResultCode value) {
    return Err_ResultCode_Name(value);
  }
  static inline bool ResultCode_Parse(const ::std::string& name,
      ResultCode* value) {
    return Err_ResultCode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional uint32 rcode = 1;
  inline bool has_rcode() const;
  inline void clear_rcode();
  static const int kRcodeFieldNumber = 1;
  inline ::google::protobuf::uint32 rcode() const;
  inline void set_rcode(::google::protobuf::uint32 value);

  // optional string rdesc = 2;
  inline bool has_rdesc() const;
  inline void clear_rdesc();
  static const int kRdescFieldNumber = 2;
  inline const ::std::string& rdesc() const;
  inline void set_rdesc(const ::std::string& value);
  inline void set_rdesc(const char* value);
  inline void set_rdesc(const char* value, size_t size);
  inline ::std::string* mutable_rdesc();
  inline ::std::string* release_rdesc();
  inline void set_allocated_rdesc(::std::string* rdesc);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.Err)
 private:
  inline void set_has_rcode();
  inline void clear_has_rcode();
  inline void set_has_rdesc();
  inline void clear_has_rdesc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* rdesc_;
  ::google::protobuf::uint32 rcode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_SoapProto_2eproto();
  friend void protobuf_AssignDesc_SoapProto_2eproto();
  friend void protobuf_ShutdownFile_SoapProto_2eproto();

  void InitAsDefaultInstance();
  static Err* default_instance_;
};
// -------------------------------------------------------------------

class SendSms : public ::google::protobuf::Message {
 public:
  SendSms();
  virtual ~SendSms();

  SendSms(const SendSms& from);

  inline SendSms& operator=(const SendSms& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SendSms& default_instance();

  void Swap(SendSms* other);

  // implements Message ----------------------------------------------

  SendSms* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SendSms& from);
  void MergeFrom(const SendSms& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 sms_id = 1;
  inline bool has_sms_id() const;
  inline void clear_sms_id();
  static const int kSmsIdFieldNumber = 1;
  inline ::google::protobuf::uint32 sms_id() const;
  inline void set_sms_id(::google::protobuf::uint32 value);

  // optional uint32 to_number = 2;
  inline bool has_to_number() const;
  inline void clear_to_number();
  static const int kToNumberFieldNumber = 2;
  inline ::google::protobuf::uint32 to_number() const;
  inline void set_to_number(::google::protobuf::uint32 value);

  // optional string content = 3;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 3;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.SendSms)
 private:
  inline void set_has_sms_id();
  inline void clear_has_sms_id();
  inline void set_has_to_number();
  inline void clear_has_to_number();
  inline void set_has_content();
  inline void clear_has_content();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 sms_id_;
  ::google::protobuf::uint32 to_number_;
  ::std::string* content_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_SoapProto_2eproto();
  friend void protobuf_AssignDesc_SoapProto_2eproto();
  friend void protobuf_ShutdownFile_SoapProto_2eproto();

  void InitAsDefaultInstance();
  static SendSms* default_instance_;
};
// -------------------------------------------------------------------

class SendSmsReply : public ::google::protobuf::Message {
 public:
  SendSmsReply();
  virtual ~SendSmsReply();

  SendSmsReply(const SendSmsReply& from);

  inline SendSmsReply& operator=(const SendSmsReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SendSmsReply& default_instance();

  void Swap(SendSmsReply* other);

  // implements Message ----------------------------------------------

  SendSmsReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SendSmsReply& from);
  void MergeFrom(const SendSmsReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 sms_id = 1;
  inline bool has_sms_id() const;
  inline void clear_sms_id();
  static const int kSmsIdFieldNumber = 1;
  inline ::google::protobuf::uint32 sms_id() const;
  inline void set_sms_id(::google::protobuf::uint32 value);

  // optional uint32 rcode = 2;
  inline bool has_rcode() const;
  inline void clear_rcode();
  static const int kRcodeFieldNumber = 2;
  inline ::google::protobuf::uint32 rcode() const;
  inline void set_rcode(::google::protobuf::uint32 value);

  // optional string rdesc = 3;
  inline bool has_rdesc() const;
  inline void clear_rdesc();
  static const int kRdescFieldNumber = 3;
  inline const ::std::string& rdesc() const;
  inline void set_rdesc(const ::std::string& value);
  inline void set_rdesc(const char* value);
  inline void set_rdesc(const char* value, size_t size);
  inline ::std::string* mutable_rdesc();
  inline ::std::string* release_rdesc();
  inline void set_allocated_rdesc(::std::string* rdesc);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.SendSmsReply)
 private:
  inline void set_has_sms_id();
  inline void clear_has_sms_id();
  inline void set_has_rcode();
  inline void clear_has_rcode();
  inline void set_has_rdesc();
  inline void clear_has_rdesc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 sms_id_;
  ::google::protobuf::uint32 rcode_;
  ::std::string* rdesc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_SoapProto_2eproto();
  friend void protobuf_AssignDesc_SoapProto_2eproto();
  friend void protobuf_ShutdownFile_SoapProto_2eproto();

  void InitAsDefaultInstance();
  static SendSmsReply* default_instance_;
};
// -------------------------------------------------------------------

class RegStatus : public ::google::protobuf::Message {
 public:
  RegStatus();
  virtual ~RegStatus();

  RegStatus(const RegStatus& from);

  inline RegStatus& operator=(const RegStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegStatus& default_instance();

  void Swap(RegStatus* other);

  // implements Message ----------------------------------------------

  RegStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegStatus& from);
  void MergeFrom(const RegStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_setup = 1;
  inline bool has_is_setup() const;
  inline void clear_is_setup();
  static const int kIsSetupFieldNumber = 1;
  inline bool is_setup() const;
  inline void set_is_setup(bool value);

  // optional bool is_reged = 2;
  inline bool has_is_reged() const;
  inline void clear_is_reged();
  static const int kIsRegedFieldNumber = 2;
  inline bool is_reged() const;
  inline void set_is_reged(bool value);

  // optional bool is_active = 3;
  inline bool has_is_active() const;
  inline void clear_is_active();
  static const int kIsActiveFieldNumber = 3;
  inline bool is_active() const;
  inline void set_is_active(bool value);

  // optional bool is_named = 4;
  inline bool has_is_named() const;
  inline void clear_is_named();
  static const int kIsNamedFieldNumber = 4;
  inline bool is_named() const;
  inline void set_is_named(bool value);

  // optional bool is_frozen = 5;
  inline bool has_is_frozen() const;
  inline void clear_is_frozen();
  static const int kIsFrozenFieldNumber = 5;
  inline bool is_frozen() const;
  inline void set_is_frozen(bool value);

  // optional bool is_suppend = 6;
  inline bool has_is_suppend() const;
  inline void clear_is_suppend();
  static const int kIsSuppendFieldNumber = 6;
  inline bool is_suppend() const;
  inline void set_is_suppend(bool value);

  // optional bool is_stopped = 7;
  inline bool has_is_stopped() const;
  inline void clear_is_stopped();
  static const int kIsStoppedFieldNumber = 7;
  inline bool is_stopped() const;
  inline void set_is_stopped(bool value);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.RegStatus)
 private:
  inline void set_has_is_setup();
  inline void clear_has_is_setup();
  inline void set_has_is_reged();
  inline void clear_has_is_reged();
  inline void set_has_is_active();
  inline void clear_has_is_active();
  inline void set_has_is_named();
  inline void clear_has_is_named();
  inline void set_has_is_frozen();
  inline void clear_has_is_frozen();
  inline void set_has_is_suppend();
  inline void clear_has_is_suppend();
  inline void set_has_is_stopped();
  inline void clear_has_is_stopped();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool is_setup_;
  bool is_reged_;
  bool is_active_;
  bool is_named_;
  bool is_frozen_;
  bool is_suppend_;
  bool is_stopped_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_SoapProto_2eproto();
  friend void protobuf_AssignDesc_SoapProto_2eproto();
  friend void protobuf_ShutdownFile_SoapProto_2eproto();

  void InitAsDefaultInstance();
  static RegStatus* default_instance_;
};
// -------------------------------------------------------------------

class GetAgentInfoReply : public ::google::protobuf::Message {
 public:
  GetAgentInfoReply();
  virtual ~GetAgentInfoReply();

  GetAgentInfoReply(const GetAgentInfoReply& from);

  inline GetAgentInfoReply& operator=(const GetAgentInfoReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetAgentInfoReply& default_instance();

  void Swap(GetAgentInfoReply* other);

  // implements Message ----------------------------------------------

  GetAgentInfoReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetAgentInfoReply& from);
  void MergeFrom(const GetAgentInfoReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GetAgentInfoReply_ResultCode ResultCode;
  static const ResultCode SYSTEM_ERROR = GetAgentInfoReply_ResultCode_SYSTEM_ERROR;
  static const ResultCode ALL_OK = GetAgentInfoReply_ResultCode_ALL_OK;
  static const ResultCode PHONE_NUMBER_NOT_CORRECT = GetAgentInfoReply_ResultCode_PHONE_NUMBER_NOT_CORRECT;
  static const ResultCode AGENT_NOT_FOUND = GetAgentInfoReply_ResultCode_AGENT_NOT_FOUND;
  static inline bool ResultCode_IsValid(int value) {
    return GetAgentInfoReply_ResultCode_IsValid(value);
  }
  static const ResultCode ResultCode_MIN =
    GetAgentInfoReply_ResultCode_ResultCode_MIN;
  static const ResultCode ResultCode_MAX =
    GetAgentInfoReply_ResultCode_ResultCode_MAX;
  static const int ResultCode_ARRAYSIZE =
    GetAgentInfoReply_ResultCode_ResultCode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ResultCode_descriptor() {
    return GetAgentInfoReply_ResultCode_descriptor();
  }
  static inline const ::std::string& ResultCode_Name(ResultCode value) {
    return GetAgentInfoReply_ResultCode_Name(value);
  }
  static inline bool ResultCode_Parse(const ::std::string& name,
      ResultCode* value) {
    return GetAgentInfoReply_ResultCode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional bool result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline bool result() const;
  inline void set_result(bool value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string card_id = 3;
  inline bool has_card_id() const;
  inline void clear_card_id();
  static const int kCardIdFieldNumber = 3;
  inline const ::std::string& card_id() const;
  inline void set_card_id(const ::std::string& value);
  inline void set_card_id(const char* value);
  inline void set_card_id(const char* value, size_t size);
  inline ::std::string* mutable_card_id();
  inline ::std::string* release_card_id();
  inline void set_allocated_card_id(::std::string* card_id);

  // optional double momo = 4;
  inline bool has_momo() const;
  inline void clear_momo();
  static const int kMomoFieldNumber = 4;
  inline double momo() const;
  inline void set_momo(double value);

  // optional double mload = 5;
  inline bool has_mload() const;
  inline void clear_mload();
  static const int kMloadFieldNumber = 5;
  inline double mload() const;
  inline void set_mload(double value);

  // optional string email = 6;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 6;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // optional .com.mservice.momo.msg.RegStatus regStatus = 7;
  inline bool has_regstatus() const;
  inline void clear_regstatus();
  static const int kRegStatusFieldNumber = 7;
  inline const ::com::mservice::momo::msg::RegStatus& regstatus() const;
  inline ::com::mservice::momo::msg::RegStatus* mutable_regstatus();
  inline ::com::mservice::momo::msg::RegStatus* release_regstatus();
  inline void set_allocated_regstatus(::com::mservice::momo::msg::RegStatus* regstatus);

  // optional uint64 point = 8;
  inline bool has_point() const;
  inline void clear_point();
  static const int kPointFieldNumber = 8;
  inline ::google::protobuf::uint64 point() const;
  inline void set_point(::google::protobuf::uint64 value);

  // optional string dateOfBirth = 9;
  inline bool has_dateofbirth() const;
  inline void clear_dateofbirth();
  static const int kDateOfBirthFieldNumber = 9;
  inline const ::std::string& dateofbirth() const;
  inline void set_dateofbirth(const ::std::string& value);
  inline void set_dateofbirth(const char* value);
  inline void set_dateofbirth(const char* value, size_t size);
  inline ::std::string* mutable_dateofbirth();
  inline ::std::string* release_dateofbirth();
  inline void set_allocated_dateofbirth(::std::string* dateofbirth);

  // optional string address = 10;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 10;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const char* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // optional uint32 rcode = 11;
  inline bool has_rcode() const;
  inline void clear_rcode();
  static const int kRcodeFieldNumber = 11;
  inline ::google::protobuf::uint32 rcode() const;
  inline void set_rcode(::google::protobuf::uint32 value);

  // optional string bank_name = 12;
  inline bool has_bank_name() const;
  inline void clear_bank_name();
  static const int kBankNameFieldNumber = 12;
  inline const ::std::string& bank_name() const;
  inline void set_bank_name(const ::std::string& value);
  inline void set_bank_name(const char* value);
  inline void set_bank_name(const char* value, size_t size);
  inline ::std::string* mutable_bank_name();
  inline ::std::string* release_bank_name();
  inline void set_allocated_bank_name(::std::string* bank_name);

  // optional string bank_acc = 13;
  inline bool has_bank_acc() const;
  inline void clear_bank_acc();
  static const int kBankAccFieldNumber = 13;
  inline const ::std::string& bank_acc() const;
  inline void set_bank_acc(const ::std::string& value);
  inline void set_bank_acc(const char* value);
  inline void set_bank_acc(const char* value, size_t size);
  inline ::std::string* mutable_bank_acc();
  inline ::std::string* release_bank_acc();
  inline void set_allocated_bank_acc(::std::string* bank_acc);

  // optional string bank_code = 14;
  inline bool has_bank_code() const;
  inline void clear_bank_code();
  static const int kBankCodeFieldNumber = 14;
  inline const ::std::string& bank_code() const;
  inline void set_bank_code(const ::std::string& value);
  inline void set_bank_code(const char* value);
  inline void set_bank_code(const char* value, size_t size);
  inline ::std::string* mutable_bank_code();
  inline ::std::string* release_bank_code();
  inline void set_allocated_bank_code(::std::string* bank_code);

  // optional uint64 agent_id = 15;
  inline bool has_agent_id() const;
  inline void clear_agent_id();
  static const int kAgentIdFieldNumber = 15;
  inline ::google::protobuf::uint64 agent_id() const;
  inline void set_agent_id(::google::protobuf::uint64 value);

  // optional uint64 createdDate = 16;
  inline bool has_createddate() const;
  inline void clear_createddate();
  static const int kCreatedDateFieldNumber = 16;
  inline ::google::protobuf::uint64 createddate() const;
  inline void set_createddate(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.GetAgentInfoReply)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_card_id();
  inline void clear_has_card_id();
  inline void set_has_momo();
  inline void clear_has_momo();
  inline void set_has_mload();
  inline void clear_has_mload();
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_regstatus();
  inline void clear_has_regstatus();
  inline void set_has_point();
  inline void clear_has_point();
  inline void set_has_dateofbirth();
  inline void clear_has_dateofbirth();
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_rcode();
  inline void clear_has_rcode();
  inline void set_has_bank_name();
  inline void clear_has_bank_name();
  inline void set_has_bank_acc();
  inline void clear_has_bank_acc();
  inline void set_has_bank_code();
  inline void clear_has_bank_code();
  inline void set_has_agent_id();
  inline void clear_has_agent_id();
  inline void set_has_createddate();
  inline void clear_has_createddate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* card_id_;
  double momo_;
  double mload_;
  ::std::string* email_;
  bool result_;
  ::google::protobuf::uint32 rcode_;
  ::com::mservice::momo::msg::RegStatus* regstatus_;
  ::google::protobuf::uint64 point_;
  ::std::string* dateofbirth_;
  ::std::string* address_;
  ::std::string* bank_name_;
  ::std::string* bank_acc_;
  ::std::string* bank_code_;
  ::google::protobuf::uint64 agent_id_;
  ::google::protobuf::uint64 createddate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];

  friend void  protobuf_AddDesc_SoapProto_2eproto();
  friend void protobuf_AssignDesc_SoapProto_2eproto();
  friend void protobuf_ShutdownFile_SoapProto_2eproto();

  void InitAsDefaultInstance();
  static GetAgentInfoReply* default_instance_;
};
// -------------------------------------------------------------------

class Register : public ::google::protobuf::Message {
 public:
  Register();
  virtual ~Register();

  Register(const Register& from);

  inline Register& operator=(const Register& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Register& default_instance();

  void Swap(Register* other);

  // implements Message ----------------------------------------------

  Register* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Register& from);
  void MergeFrom(const Register& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string id_card = 2;
  inline bool has_id_card() const;
  inline void clear_id_card();
  static const int kIdCardFieldNumber = 2;
  inline const ::std::string& id_card() const;
  inline void set_id_card(const ::std::string& value);
  inline void set_id_card(const char* value);
  inline void set_id_card(const char* value, size_t size);
  inline ::std::string* mutable_id_card();
  inline ::std::string* release_id_card();
  inline void set_allocated_id_card(::std::string* id_card);

  // optional string pin = 3;
  inline bool has_pin() const;
  inline void clear_pin();
  static const int kPinFieldNumber = 3;
  inline const ::std::string& pin() const;
  inline void set_pin(const ::std::string& value);
  inline void set_pin(const char* value);
  inline void set_pin(const char* value, size_t size);
  inline ::std::string* mutable_pin();
  inline ::std::string* release_pin();
  inline void set_allocated_pin(::std::string* pin);

  // optional string arr_group = 4;
  inline bool has_arr_group() const;
  inline void clear_arr_group();
  static const int kArrGroupFieldNumber = 4;
  inline const ::std::string& arr_group() const;
  inline void set_arr_group(const ::std::string& value);
  inline void set_arr_group(const char* value);
  inline void set_arr_group(const char* value, size_t size);
  inline ::std::string* mutable_arr_group();
  inline ::std::string* release_arr_group();
  inline void set_allocated_arr_group(::std::string* arr_group);

  // optional string arr_capset = 5;
  inline bool has_arr_capset() const;
  inline void clear_arr_capset();
  static const int kArrCapsetFieldNumber = 5;
  inline const ::std::string& arr_capset() const;
  inline void set_arr_capset(const ::std::string& value);
  inline void set_arr_capset(const char* value);
  inline void set_arr_capset(const char* value, size_t size);
  inline ::std::string* mutable_arr_capset();
  inline ::std::string* release_arr_capset();
  inline void set_allocated_arr_capset(::std::string* arr_capset);

  // optional string upper_limit = 6;
  inline bool has_upper_limit() const;
  inline void clear_upper_limit();
  static const int kUpperLimitFieldNumber = 6;
  inline const ::std::string& upper_limit() const;
  inline void set_upper_limit(const ::std::string& value);
  inline void set_upper_limit(const char* value);
  inline void set_upper_limit(const char* value, size_t size);
  inline ::std::string* mutable_upper_limit();
  inline ::std::string* release_upper_limit();
  inline void set_allocated_upper_limit(::std::string* upper_limit);

  // optional string email = 7;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 7;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // optional string question = 8;
  inline bool has_question() const;
  inline void clear_question();
  static const int kQuestionFieldNumber = 8;
  inline const ::std::string& question() const;
  inline void set_question(const ::std::string& value);
  inline void set_question(const char* value);
  inline void set_question(const char* value, size_t size);
  inline ::std::string* mutable_question();
  inline ::std::string* release_question();
  inline void set_allocated_question(::std::string* question);

  // optional string answer = 9;
  inline bool has_answer() const;
  inline void clear_answer();
  static const int kAnswerFieldNumber = 9;
  inline const ::std::string& answer() const;
  inline void set_answer(const ::std::string& value);
  inline void set_answer(const char* value);
  inline void set_answer(const char* value, size_t size);
  inline ::std::string* mutable_answer();
  inline ::std::string* release_answer();
  inline void set_allocated_answer(::std::string* answer);

  // optional string channel = 10;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 10;
  inline const ::std::string& channel() const;
  inline void set_channel(const ::std::string& value);
  inline void set_channel(const char* value);
  inline void set_channel(const char* value, size_t size);
  inline ::std::string* mutable_channel();
  inline ::std::string* release_channel();
  inline void set_allocated_channel(::std::string* channel);

  // optional string dateOfBirth = 11;
  inline bool has_dateofbirth() const;
  inline void clear_dateofbirth();
  static const int kDateOfBirthFieldNumber = 11;
  inline const ::std::string& dateofbirth() const;
  inline void set_dateofbirth(const ::std::string& value);
  inline void set_dateofbirth(const char* value);
  inline void set_dateofbirth(const char* value, size_t size);
  inline ::std::string* mutable_dateofbirth();
  inline ::std::string* release_dateofbirth();
  inline void set_allocated_dateofbirth(::std::string* dateofbirth);

  // optional string address = 12;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 12;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const char* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // repeated .com.mservice.momo.msg.keyValuePair kvps = 13;
  inline int kvps_size() const;
  inline void clear_kvps();
  static const int kKvpsFieldNumber = 13;
  inline const ::com::mservice::momo::msg::keyValuePair& kvps(int index) const;
  inline ::com::mservice::momo::msg::keyValuePair* mutable_kvps(int index);
  inline ::com::mservice::momo::msg::keyValuePair* add_kvps();
  inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >&
      kvps() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >*
      mutable_kvps();

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.Register)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_id_card();
  inline void clear_has_id_card();
  inline void set_has_pin();
  inline void clear_has_pin();
  inline void set_has_arr_group();
  inline void clear_has_arr_group();
  inline void set_has_arr_capset();
  inline void clear_has_arr_capset();
  inline void set_has_upper_limit();
  inline void clear_has_upper_limit();
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_question();
  inline void clear_has_question();
  inline void set_has_answer();
  inline void clear_has_answer();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_dateofbirth();
  inline void clear_has_dateofbirth();
  inline void set_has_address();
  inline void clear_has_address();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* id_card_;
  ::std::string* pin_;
  ::std::string* arr_group_;
  ::std::string* arr_capset_;
  ::std::string* upper_limit_;
  ::std::string* email_;
  ::std::string* question_;
  ::std::string* answer_;
  ::std::string* channel_;
  ::std::string* dateofbirth_;
  ::std::string* address_;
  ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair > kvps_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_SoapProto_2eproto();
  friend void protobuf_AssignDesc_SoapProto_2eproto();
  friend void protobuf_ShutdownFile_SoapProto_2eproto();

  void InitAsDefaultInstance();
  static Register* default_instance_;
};
// -------------------------------------------------------------------

class LogIn : public ::google::protobuf::Message {
 public:
  LogIn();
  virtual ~LogIn();

  LogIn(const LogIn& from);

  inline LogIn& operator=(const LogIn& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogIn& default_instance();

  void Swap(LogIn* other);

  // implements Message ----------------------------------------------

  LogIn* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogIn& from);
  void MergeFrom(const LogIn& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 number = 1;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 1;
  inline ::google::protobuf::uint32 number() const;
  inline void set_number(::google::protobuf::uint32 value);

  // optional string mpin = 2;
  inline bool has_mpin() const;
  inline void clear_mpin();
  static const int kMpinFieldNumber = 2;
  inline const ::std::string& mpin() const;
  inline void set_mpin(const ::std::string& value);
  inline void set_mpin(const char* value);
  inline void set_mpin(const char* value, size_t size);
  inline ::std::string* mutable_mpin();
  inline ::std::string* release_mpin();
  inline void set_allocated_mpin(::std::string* mpin);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.LogIn)
 private:
  inline void set_has_number();
  inline void clear_has_number();
  inline void set_has_mpin();
  inline void clear_has_mpin();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* mpin_;
  ::google::protobuf::uint32 number_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_SoapProto_2eproto();
  friend void protobuf_AssignDesc_SoapProto_2eproto();
  friend void protobuf_ShutdownFile_SoapProto_2eproto();

  void InitAsDefaultInstance();
  static LogIn* default_instance_;
};
// -------------------------------------------------------------------

class GetBillInfo : public ::google::protobuf::Message {
 public:
  GetBillInfo();
  virtual ~GetBillInfo();

  GetBillInfo(const GetBillInfo& from);

  inline GetBillInfo& operator=(const GetBillInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetBillInfo& default_instance();

  void Swap(GetBillInfo* other);

  // implements Message ----------------------------------------------

  GetBillInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetBillInfo& from);
  void MergeFrom(const GetBillInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string mpin = 1;
  inline bool has_mpin() const;
  inline void clear_mpin();
  static const int kMpinFieldNumber = 1;
  inline const ::std::string& mpin() const;
  inline void set_mpin(const ::std::string& value);
  inline void set_mpin(const char* value);
  inline void set_mpin(const char* value, size_t size);
  inline ::std::string* mutable_mpin();
  inline ::std::string* release_mpin();
  inline void set_allocated_mpin(::std::string* mpin);

  // optional string provider_id = 2;
  inline bool has_provider_id() const;
  inline void clear_provider_id();
  static const int kProviderIdFieldNumber = 2;
  inline const ::std::string& provider_id() const;
  inline void set_provider_id(const ::std::string& value);
  inline void set_provider_id(const char* value);
  inline void set_provider_id(const char* value, size_t size);
  inline ::std::string* mutable_provider_id();
  inline ::std::string* release_provider_id();
  inline void set_allocated_provider_id(::std::string* provider_id);

  // optional string bill_id = 3;
  inline bool has_bill_id() const;
  inline void clear_bill_id();
  static const int kBillIdFieldNumber = 3;
  inline const ::std::string& bill_id() const;
  inline void set_bill_id(const ::std::string& value);
  inline void set_bill_id(const char* value);
  inline void set_bill_id(const char* value, size_t size);
  inline ::std::string* mutable_bill_id();
  inline ::std::string* release_bill_id();
  inline void set_allocated_bill_id(::std::string* bill_id);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.GetBillInfo)
 private:
  inline void set_has_mpin();
  inline void clear_has_mpin();
  inline void set_has_provider_id();
  inline void clear_has_provider_id();
  inline void set_has_bill_id();
  inline void clear_has_bill_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* mpin_;
  ::std::string* provider_id_;
  ::std::string* bill_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_SoapProto_2eproto();
  friend void protobuf_AssignDesc_SoapProto_2eproto();
  friend void protobuf_ShutdownFile_SoapProto_2eproto();

  void InitAsDefaultInstance();
  static GetBillInfo* default_instance_;
};
// -------------------------------------------------------------------

class AgentInfo : public ::google::protobuf::Message {
 public:
  AgentInfo();
  virtual ~AgentInfo();

  AgentInfo(const AgentInfo& from);

  inline AgentInfo& operator=(const AgentInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AgentInfo& default_instance();

  void Swap(AgentInfo* other);

  // implements Message ----------------------------------------------

  AgentInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AgentInfo& from);
  void MergeFrom(const AgentInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string number = 1;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 1;
  inline const ::std::string& number() const;
  inline void set_number(const ::std::string& value);
  inline void set_number(const char* value);
  inline void set_number(const char* value, size_t size);
  inline ::std::string* mutable_number();
  inline ::std::string* release_number();
  inline void set_allocated_number(::std::string* number);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.AgentInfo)
 private:
  inline void set_has_number();
  inline void clear_has_number();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* number_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_SoapProto_2eproto();
  friend void protobuf_AssignDesc_SoapProto_2eproto();
  friend void protobuf_ShutdownFile_SoapProto_2eproto();

  void InitAsDefaultInstance();
  static AgentInfo* default_instance_;
};
// -------------------------------------------------------------------

class BankOut : public ::google::protobuf::Message {
 public:
  BankOut();
  virtual ~BankOut();

  BankOut(const BankOut& from);

  inline BankOut& operator=(const BankOut& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BankOut& default_instance();

  void Swap(BankOut* other);

  // implements Message ----------------------------------------------

  BankOut* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BankOut& from);
  void MergeFrom(const BankOut& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string mpin = 1;
  inline bool has_mpin() const;
  inline void clear_mpin();
  static const int kMpinFieldNumber = 1;
  inline const ::std::string& mpin() const;
  inline void set_mpin(const ::std::string& value);
  inline void set_mpin(const char* value);
  inline void set_mpin(const char* value, size_t size);
  inline ::std::string* mutable_mpin();
  inline ::std::string* release_mpin();
  inline void set_allocated_mpin(::std::string* mpin);

  // optional uint64 amount = 2;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 2;
  inline ::google::protobuf::uint64 amount() const;
  inline void set_amount(::google::protobuf::uint64 value);

  // optional string bank_code = 3;
  inline bool has_bank_code() const;
  inline void clear_bank_code();
  static const int kBankCodeFieldNumber = 3;
  inline const ::std::string& bank_code() const;
  inline void set_bank_code(const ::std::string& value);
  inline void set_bank_code(const char* value);
  inline void set_bank_code(const char* value, size_t size);
  inline ::std::string* mutable_bank_code();
  inline ::std::string* release_bank_code();
  inline void set_allocated_bank_code(::std::string* bank_code);

  // optional string channel = 4;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 4;
  inline const ::std::string& channel() const;
  inline void set_channel(const ::std::string& value);
  inline void set_channel(const char* value);
  inline void set_channel(const char* value, size_t size);
  inline ::std::string* mutable_channel();
  inline ::std::string* release_channel();
  inline void set_allocated_channel(::std::string* channel);

  // repeated .com.mservice.momo.msg.keyValuePair kvps = 5;
  inline int kvps_size() const;
  inline void clear_kvps();
  static const int kKvpsFieldNumber = 5;
  inline const ::com::mservice::momo::msg::keyValuePair& kvps(int index) const;
  inline ::com::mservice::momo::msg::keyValuePair* mutable_kvps(int index);
  inline ::com::mservice::momo::msg::keyValuePair* add_kvps();
  inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >&
      kvps() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >*
      mutable_kvps();

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.BankOut)
 private:
  inline void set_has_mpin();
  inline void clear_has_mpin();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_bank_code();
  inline void clear_has_bank_code();
  inline void set_has_channel();
  inline void clear_has_channel();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* mpin_;
  ::google::protobuf::uint64 amount_;
  ::std::string* bank_code_;
  ::std::string* channel_;
  ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair > kvps_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_SoapProto_2eproto();
  friend void protobuf_AssignDesc_SoapProto_2eproto();
  friend void protobuf_ShutdownFile_SoapProto_2eproto();

  void InitAsDefaultInstance();
  static BankOut* default_instance_;
};
// -------------------------------------------------------------------

class TopUp : public ::google::protobuf::Message {
 public:
  TopUp();
  virtual ~TopUp();

  TopUp(const TopUp& from);

  inline TopUp& operator=(const TopUp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TopUp& default_instance();

  void Swap(TopUp* other);

  // implements Message ----------------------------------------------

  TopUp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TopUp& from);
  void MergeFrom(const TopUp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 from_number = 1;
  inline bool has_from_number() const;
  inline void clear_from_number();
  static const int kFromNumberFieldNumber = 1;
  inline ::google::protobuf::uint32 from_number() const;
  inline void set_from_number(::google::protobuf::uint32 value);

  // optional string mpin = 2;
  inline bool has_mpin() const;
  inline void clear_mpin();
  static const int kMpinFieldNumber = 2;
  inline const ::std::string& mpin() const;
  inline void set_mpin(const ::std::string& value);
  inline void set_mpin(const char* value);
  inline void set_mpin(const char* value, size_t size);
  inline ::std::string* mutable_mpin();
  inline ::std::string* release_mpin();
  inline void set_allocated_mpin(::std::string* mpin);

  // optional uint32 to_number = 3;
  inline bool has_to_number() const;
  inline void clear_to_number();
  static const int kToNumberFieldNumber = 3;
  inline ::google::protobuf::uint32 to_number() const;
  inline void set_to_number(::google::protobuf::uint32 value);

  // optional uint64 amount = 4;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 4;
  inline ::google::protobuf::uint64 amount() const;
  inline void set_amount(::google::protobuf::uint64 value);

  // optional string channel = 5;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 5;
  inline const ::std::string& channel() const;
  inline void set_channel(const ::std::string& value);
  inline void set_channel(const char* value);
  inline void set_channel(const char* value, size_t size);
  inline ::std::string* mutable_channel();
  inline ::std::string* release_channel();
  inline void set_allocated_channel(::std::string* channel);

  // repeated .com.mservice.momo.msg.keyValuePair keyValuePairs = 6;
  inline int keyvaluepairs_size() const;
  inline void clear_keyvaluepairs();
  static const int kKeyValuePairsFieldNumber = 6;
  inline const ::com::mservice::momo::msg::keyValuePair& keyvaluepairs(int index) const;
  inline ::com::mservice::momo::msg::keyValuePair* mutable_keyvaluepairs(int index);
  inline ::com::mservice::momo::msg::keyValuePair* add_keyvaluepairs();
  inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >&
      keyvaluepairs() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >*
      mutable_keyvaluepairs();

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.TopUp)
 private:
  inline void set_has_from_number();
  inline void clear_has_from_number();
  inline void set_has_mpin();
  inline void clear_has_mpin();
  inline void set_has_to_number();
  inline void clear_has_to_number();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_channel();
  inline void clear_has_channel();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* mpin_;
  ::google::protobuf::uint32 from_number_;
  ::google::protobuf::uint32 to_number_;
  ::google::protobuf::uint64 amount_;
  ::std::string* channel_;
  ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair > keyvaluepairs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_SoapProto_2eproto();
  friend void protobuf_AssignDesc_SoapProto_2eproto();
  friend void protobuf_ShutdownFile_SoapProto_2eproto();

  void InitAsDefaultInstance();
  static TopUp* default_instance_;
};
// -------------------------------------------------------------------

class TopUpString : public ::google::protobuf::Message {
 public:
  TopUpString();
  virtual ~TopUpString();

  TopUpString(const TopUpString& from);

  inline TopUpString& operator=(const TopUpString& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TopUpString& default_instance();

  void Swap(TopUpString* other);

  // implements Message ----------------------------------------------

  TopUpString* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TopUpString& from);
  void MergeFrom(const TopUpString& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string from_number = 1;
  inline bool has_from_number() const;
  inline void clear_from_number();
  static const int kFromNumberFieldNumber = 1;
  inline const ::std::string& from_number() const;
  inline void set_from_number(const ::std::string& value);
  inline void set_from_number(const char* value);
  inline void set_from_number(const char* value, size_t size);
  inline ::std::string* mutable_from_number();
  inline ::std::string* release_from_number();
  inline void set_allocated_from_number(::std::string* from_number);

  // optional string mpin = 2;
  inline bool has_mpin() const;
  inline void clear_mpin();
  static const int kMpinFieldNumber = 2;
  inline const ::std::string& mpin() const;
  inline void set_mpin(const ::std::string& value);
  inline void set_mpin(const char* value);
  inline void set_mpin(const char* value, size_t size);
  inline ::std::string* mutable_mpin();
  inline ::std::string* release_mpin();
  inline void set_allocated_mpin(::std::string* mpin);

  // optional string to_number = 3;
  inline bool has_to_number() const;
  inline void clear_to_number();
  static const int kToNumberFieldNumber = 3;
  inline const ::std::string& to_number() const;
  inline void set_to_number(const ::std::string& value);
  inline void set_to_number(const char* value);
  inline void set_to_number(const char* value, size_t size);
  inline ::std::string* mutable_to_number();
  inline ::std::string* release_to_number();
  inline void set_allocated_to_number(::std::string* to_number);

  // optional uint64 amount = 4;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 4;
  inline ::google::protobuf::uint64 amount() const;
  inline void set_amount(::google::protobuf::uint64 value);

  // optional string channel = 5;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 5;
  inline const ::std::string& channel() const;
  inline void set_channel(const ::std::string& value);
  inline void set_channel(const char* value);
  inline void set_channel(const char* value, size_t size);
  inline ::std::string* mutable_channel();
  inline ::std::string* release_channel();
  inline void set_allocated_channel(::std::string* channel);

  // repeated .com.mservice.momo.msg.keyValuePair keyValuePairs = 6;
  inline int keyvaluepairs_size() const;
  inline void clear_keyvaluepairs();
  static const int kKeyValuePairsFieldNumber = 6;
  inline const ::com::mservice::momo::msg::keyValuePair& keyvaluepairs(int index) const;
  inline ::com::mservice::momo::msg::keyValuePair* mutable_keyvaluepairs(int index);
  inline ::com::mservice::momo::msg::keyValuePair* add_keyvaluepairs();
  inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >&
      keyvaluepairs() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >*
      mutable_keyvaluepairs();

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.TopUpString)
 private:
  inline void set_has_from_number();
  inline void clear_has_from_number();
  inline void set_has_mpin();
  inline void clear_has_mpin();
  inline void set_has_to_number();
  inline void clear_has_to_number();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_channel();
  inline void clear_has_channel();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* from_number_;
  ::std::string* mpin_;
  ::std::string* to_number_;
  ::google::protobuf::uint64 amount_;
  ::std::string* channel_;
  ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair > keyvaluepairs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_SoapProto_2eproto();
  friend void protobuf_AssignDesc_SoapProto_2eproto();
  friend void protobuf_ShutdownFile_SoapProto_2eproto();

  void InitAsDefaultInstance();
  static TopUpString* default_instance_;
};
// -------------------------------------------------------------------

class TopUpReply : public ::google::protobuf::Message {
 public:
  TopUpReply();
  virtual ~TopUpReply();

  TopUpReply(const TopUpReply& from);

  inline TopUpReply& operator=(const TopUpReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TopUpReply& default_instance();

  void Swap(TopUpReply* other);

  // implements Message ----------------------------------------------

  TopUpReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TopUpReply& from);
  void MergeFrom(const TopUpReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline bool result() const;
  inline void set_result(bool value);

  // optional uint32 rcode = 2;
  inline bool has_rcode() const;
  inline void clear_rcode();
  static const int kRcodeFieldNumber = 2;
  inline ::google::protobuf::uint32 rcode() const;
  inline void set_rcode(::google::protobuf::uint32 value);

  // optional string trans_id = 3;
  inline bool has_trans_id() const;
  inline void clear_trans_id();
  static const int kTransIdFieldNumber = 3;
  inline const ::std::string& trans_id() const;
  inline void set_trans_id(const ::std::string& value);
  inline void set_trans_id(const char* value);
  inline void set_trans_id(const char* value, size_t size);
  inline ::std::string* mutable_trans_id();
  inline ::std::string* release_trans_id();
  inline void set_allocated_trans_id(::std::string* trans_id);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.TopUpReply)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_rcode();
  inline void clear_has_rcode();
  inline void set_has_trans_id();
  inline void clear_has_trans_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool result_;
  ::google::protobuf::uint32 rcode_;
  ::std::string* trans_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_SoapProto_2eproto();
  friend void protobuf_AssignDesc_SoapProto_2eproto();
  friend void protobuf_ShutdownFile_SoapProto_2eproto();

  void InitAsDefaultInstance();
  static TopUpReply* default_instance_;
};
// -------------------------------------------------------------------

class BankIn : public ::google::protobuf::Message {
 public:
  BankIn();
  virtual ~BankIn();

  BankIn(const BankIn& from);

  inline BankIn& operator=(const BankIn& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BankIn& default_instance();

  void Swap(BankIn* other);

  // implements Message ----------------------------------------------

  BankIn* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BankIn& from);
  void MergeFrom(const BankIn& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string mpin = 1;
  inline bool has_mpin() const;
  inline void clear_mpin();
  static const int kMpinFieldNumber = 1;
  inline const ::std::string& mpin() const;
  inline void set_mpin(const ::std::string& value);
  inline void set_mpin(const char* value);
  inline void set_mpin(const char* value, size_t size);
  inline ::std::string* mutable_mpin();
  inline ::std::string* release_mpin();
  inline void set_allocated_mpin(::std::string* mpin);

  // optional uint64 amount = 2;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 2;
  inline ::google::protobuf::uint64 amount() const;
  inline void set_amount(::google::protobuf::uint64 value);

  // optional string bank_code = 3;
  inline bool has_bank_code() const;
  inline void clear_bank_code();
  static const int kBankCodeFieldNumber = 3;
  inline const ::std::string& bank_code() const;
  inline void set_bank_code(const ::std::string& value);
  inline void set_bank_code(const char* value);
  inline void set_bank_code(const char* value, size_t size);
  inline ::std::string* mutable_bank_code();
  inline ::std::string* release_bank_code();
  inline void set_allocated_bank_code(::std::string* bank_code);

  // optional string channel = 4;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 4;
  inline const ::std::string& channel() const;
  inline void set_channel(const ::std::string& value);
  inline void set_channel(const char* value);
  inline void set_channel(const char* value, size_t size);
  inline ::std::string* mutable_channel();
  inline ::std::string* release_channel();
  inline void set_allocated_channel(::std::string* channel);

  // repeated .com.mservice.momo.msg.keyValuePair kvps = 5;
  inline int kvps_size() const;
  inline void clear_kvps();
  static const int kKvpsFieldNumber = 5;
  inline const ::com::mservice::momo::msg::keyValuePair& kvps(int index) const;
  inline ::com::mservice::momo::msg::keyValuePair* mutable_kvps(int index);
  inline ::com::mservice::momo::msg::keyValuePair* add_kvps();
  inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >&
      kvps() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >*
      mutable_kvps();

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.BankIn)
 private:
  inline void set_has_mpin();
  inline void clear_has_mpin();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_bank_code();
  inline void clear_has_bank_code();
  inline void set_has_channel();
  inline void clear_has_channel();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* mpin_;
  ::google::protobuf::uint64 amount_;
  ::std::string* bank_code_;
  ::std::string* channel_;
  ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair > kvps_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_SoapProto_2eproto();
  friend void protobuf_AssignDesc_SoapProto_2eproto();
  friend void protobuf_ShutdownFile_SoapProto_2eproto();

  void InitAsDefaultInstance();
  static BankIn* default_instance_;
};
// -------------------------------------------------------------------

class M2CTransfer : public ::google::protobuf::Message {
 public:
  M2CTransfer();
  virtual ~M2CTransfer();

  M2CTransfer(const M2CTransfer& from);

  inline M2CTransfer& operator=(const M2CTransfer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const M2CTransfer& default_instance();

  void Swap(M2CTransfer* other);

  // implements Message ----------------------------------------------

  M2CTransfer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const M2CTransfer& from);
  void MergeFrom(const M2CTransfer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string agent = 1;
  inline bool has_agent() const;
  inline void clear_agent();
  static const int kAgentFieldNumber = 1;
  inline const ::std::string& agent() const;
  inline void set_agent(const ::std::string& value);
  inline void set_agent(const char* value);
  inline void set_agent(const char* value, size_t size);
  inline ::std::string* mutable_agent();
  inline ::std::string* release_agent();
  inline void set_allocated_agent(::std::string* agent);

  // optional string mpin = 2;
  inline bool has_mpin() const;
  inline void clear_mpin();
  static const int kMpinFieldNumber = 2;
  inline const ::std::string& mpin() const;
  inline void set_mpin(const ::std::string& value);
  inline void set_mpin(const char* value);
  inline void set_mpin(const char* value, size_t size);
  inline ::std::string* mutable_mpin();
  inline ::std::string* release_mpin();
  inline void set_allocated_mpin(::std::string* mpin);

  // optional string phone = 3;
  inline bool has_phone() const;
  inline void clear_phone();
  static const int kPhoneFieldNumber = 3;
  inline const ::std::string& phone() const;
  inline void set_phone(const ::std::string& value);
  inline void set_phone(const char* value);
  inline void set_phone(const char* value, size_t size);
  inline ::std::string* mutable_phone();
  inline ::std::string* release_phone();
  inline void set_allocated_phone(::std::string* phone);

  // optional string name = 4;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 4;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string card_id = 5;
  inline bool has_card_id() const;
  inline void clear_card_id();
  static const int kCardIdFieldNumber = 5;
  inline const ::std::string& card_id() const;
  inline void set_card_id(const ::std::string& value);
  inline void set_card_id(const char* value);
  inline void set_card_id(const char* value, size_t size);
  inline ::std::string* mutable_card_id();
  inline ::std::string* release_card_id();
  inline void set_allocated_card_id(::std::string* card_id);

  // optional uint64 amount = 6;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 6;
  inline ::google::protobuf::uint64 amount() const;
  inline void set_amount(::google::protobuf::uint64 value);

  // optional string notice = 7;
  inline bool has_notice() const;
  inline void clear_notice();
  static const int kNoticeFieldNumber = 7;
  inline const ::std::string& notice() const;
  inline void set_notice(const ::std::string& value);
  inline void set_notice(const char* value);
  inline void set_notice(const char* value, size_t size);
  inline ::std::string* mutable_notice();
  inline ::std::string* release_notice();
  inline void set_allocated_notice(::std::string* notice);

  // optional string channel = 8;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 8;
  inline const ::std::string& channel() const;
  inline void set_channel(const ::std::string& value);
  inline void set_channel(const char* value);
  inline void set_channel(const char* value, size_t size);
  inline ::std::string* mutable_channel();
  inline ::std::string* release_channel();
  inline void set_allocated_channel(::std::string* channel);

  // repeated .com.mservice.momo.msg.keyValuePair kvps = 9;
  inline int kvps_size() const;
  inline void clear_kvps();
  static const int kKvpsFieldNumber = 9;
  inline const ::com::mservice::momo::msg::keyValuePair& kvps(int index) const;
  inline ::com::mservice::momo::msg::keyValuePair* mutable_kvps(int index);
  inline ::com::mservice::momo::msg::keyValuePair* add_kvps();
  inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >&
      kvps() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >*
      mutable_kvps();

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.M2CTransfer)
 private:
  inline void set_has_agent();
  inline void clear_has_agent();
  inline void set_has_mpin();
  inline void clear_has_mpin();
  inline void set_has_phone();
  inline void clear_has_phone();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_card_id();
  inline void clear_has_card_id();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_notice();
  inline void clear_has_notice();
  inline void set_has_channel();
  inline void clear_has_channel();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* agent_;
  ::std::string* mpin_;
  ::std::string* phone_;
  ::std::string* name_;
  ::std::string* card_id_;
  ::google::protobuf::uint64 amount_;
  ::std::string* notice_;
  ::std::string* channel_;
  ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair > kvps_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_SoapProto_2eproto();
  friend void protobuf_AssignDesc_SoapProto_2eproto();
  friend void protobuf_ShutdownFile_SoapProto_2eproto();

  void InitAsDefaultInstance();
  static M2CTransfer* default_instance_;
};
// -------------------------------------------------------------------

class PayOneBillOther : public ::google::protobuf::Message {
 public:
  PayOneBillOther();
  virtual ~PayOneBillOther();

  PayOneBillOther(const PayOneBillOther& from);

  inline PayOneBillOther& operator=(const PayOneBillOther& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PayOneBillOther& default_instance();

  void Swap(PayOneBillOther* other);

  // implements Message ----------------------------------------------

  PayOneBillOther* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PayOneBillOther& from);
  void MergeFrom(const PayOneBillOther& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string agent = 1;
  inline bool has_agent() const;
  inline void clear_agent();
  static const int kAgentFieldNumber = 1;
  inline const ::std::string& agent() const;
  inline void set_agent(const ::std::string& value);
  inline void set_agent(const char* value);
  inline void set_agent(const char* value, size_t size);
  inline ::std::string* mutable_agent();
  inline ::std::string* release_agent();
  inline void set_allocated_agent(::std::string* agent);

  // optional string mpin = 2;
  inline bool has_mpin() const;
  inline void clear_mpin();
  static const int kMpinFieldNumber = 2;
  inline const ::std::string& mpin() const;
  inline void set_mpin(const ::std::string& value);
  inline void set_mpin(const char* value);
  inline void set_mpin(const char* value, size_t size);
  inline ::std::string* mutable_mpin();
  inline ::std::string* release_mpin();
  inline void set_allocated_mpin(::std::string* mpin);

  // optional string phone = 3;
  inline bool has_phone() const;
  inline void clear_phone();
  static const int kPhoneFieldNumber = 3;
  inline const ::std::string& phone() const;
  inline void set_phone(const ::std::string& value);
  inline void set_phone(const char* value);
  inline void set_phone(const char* value, size_t size);
  inline ::std::string* mutable_phone();
  inline ::std::string* release_phone();
  inline void set_allocated_phone(::std::string* phone);

  // optional string name = 4;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 4;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string card_id = 5;
  inline bool has_card_id() const;
  inline void clear_card_id();
  static const int kCardIdFieldNumber = 5;
  inline const ::std::string& card_id() const;
  inline void set_card_id(const ::std::string& value);
  inline void set_card_id(const char* value);
  inline void set_card_id(const char* value, size_t size);
  inline ::std::string* mutable_card_id();
  inline ::std::string* release_card_id();
  inline void set_allocated_card_id(::std::string* card_id);

  // optional uint64 amount = 6;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 6;
  inline ::google::protobuf::uint64 amount() const;
  inline void set_amount(::google::protobuf::uint64 value);

  // optional string notice = 7;
  inline bool has_notice() const;
  inline void clear_notice();
  static const int kNoticeFieldNumber = 7;
  inline const ::std::string& notice() const;
  inline void set_notice(const ::std::string& value);
  inline void set_notice(const char* value);
  inline void set_notice(const char* value, size_t size);
  inline ::std::string* mutable_notice();
  inline ::std::string* release_notice();
  inline void set_allocated_notice(::std::string* notice);

  // optional string channel = 8;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 8;
  inline const ::std::string& channel() const;
  inline void set_channel(const ::std::string& value);
  inline void set_channel(const char* value);
  inline void set_channel(const char* value, size_t size);
  inline ::std::string* mutable_channel();
  inline ::std::string* release_channel();
  inline void set_allocated_channel(::std::string* channel);

  // repeated .com.mservice.momo.msg.keyValuePair kvps = 9;
  inline int kvps_size() const;
  inline void clear_kvps();
  static const int kKvpsFieldNumber = 9;
  inline const ::com::mservice::momo::msg::keyValuePair& kvps(int index) const;
  inline ::com::mservice::momo::msg::keyValuePair* mutable_kvps(int index);
  inline ::com::mservice::momo::msg::keyValuePair* add_kvps();
  inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >&
      kvps() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >*
      mutable_kvps();

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.PayOneBillOther)
 private:
  inline void set_has_agent();
  inline void clear_has_agent();
  inline void set_has_mpin();
  inline void clear_has_mpin();
  inline void set_has_phone();
  inline void clear_has_phone();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_card_id();
  inline void clear_has_card_id();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_notice();
  inline void clear_has_notice();
  inline void set_has_channel();
  inline void clear_has_channel();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* agent_;
  ::std::string* mpin_;
  ::std::string* phone_;
  ::std::string* name_;
  ::std::string* card_id_;
  ::google::protobuf::uint64 amount_;
  ::std::string* notice_;
  ::std::string* channel_;
  ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair > kvps_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_SoapProto_2eproto();
  friend void protobuf_AssignDesc_SoapProto_2eproto();
  friend void protobuf_ShutdownFile_SoapProto_2eproto();

  void InitAsDefaultInstance();
  static PayOneBillOther* default_instance_;
};
// -------------------------------------------------------------------

class M2MTransfer : public ::google::protobuf::Message {
 public:
  M2MTransfer();
  virtual ~M2MTransfer();

  M2MTransfer(const M2MTransfer& from);

  inline M2MTransfer& operator=(const M2MTransfer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const M2MTransfer& default_instance();

  void Swap(M2MTransfer* other);

  // implements Message ----------------------------------------------

  M2MTransfer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const M2MTransfer& from);
  void MergeFrom(const M2MTransfer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string agent = 1;
  inline bool has_agent() const;
  inline void clear_agent();
  static const int kAgentFieldNumber = 1;
  inline const ::std::string& agent() const;
  inline void set_agent(const ::std::string& value);
  inline void set_agent(const char* value);
  inline void set_agent(const char* value, size_t size);
  inline ::std::string* mutable_agent();
  inline ::std::string* release_agent();
  inline void set_allocated_agent(::std::string* agent);

  // optional string mpin = 2;
  inline bool has_mpin() const;
  inline void clear_mpin();
  static const int kMpinFieldNumber = 2;
  inline const ::std::string& mpin() const;
  inline void set_mpin(const ::std::string& value);
  inline void set_mpin(const char* value);
  inline void set_mpin(const char* value, size_t size);
  inline ::std::string* mutable_mpin();
  inline ::std::string* release_mpin();
  inline void set_allocated_mpin(::std::string* mpin);

  // optional string phone = 3;
  inline bool has_phone() const;
  inline void clear_phone();
  static const int kPhoneFieldNumber = 3;
  inline const ::std::string& phone() const;
  inline void set_phone(const ::std::string& value);
  inline void set_phone(const char* value);
  inline void set_phone(const char* value, size_t size);
  inline ::std::string* mutable_phone();
  inline ::std::string* release_phone();
  inline void set_allocated_phone(::std::string* phone);

  // optional uint64 amount = 4;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 4;
  inline ::google::protobuf::uint64 amount() const;
  inline void set_amount(::google::protobuf::uint64 value);

  // optional string notice = 5;
  inline bool has_notice() const;
  inline void clear_notice();
  static const int kNoticeFieldNumber = 5;
  inline const ::std::string& notice() const;
  inline void set_notice(const ::std::string& value);
  inline void set_notice(const char* value);
  inline void set_notice(const char* value, size_t size);
  inline ::std::string* mutable_notice();
  inline ::std::string* release_notice();
  inline void set_allocated_notice(::std::string* notice);

  // optional string channel = 6;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 6;
  inline const ::std::string& channel() const;
  inline void set_channel(const ::std::string& value);
  inline void set_channel(const char* value);
  inline void set_channel(const char* value, size_t size);
  inline ::std::string* mutable_channel();
  inline ::std::string* release_channel();
  inline void set_allocated_channel(::std::string* channel);

  // repeated .com.mservice.momo.msg.keyValuePair kvps = 7;
  inline int kvps_size() const;
  inline void clear_kvps();
  static const int kKvpsFieldNumber = 7;
  inline const ::com::mservice::momo::msg::keyValuePair& kvps(int index) const;
  inline ::com::mservice::momo::msg::keyValuePair* mutable_kvps(int index);
  inline ::com::mservice::momo::msg::keyValuePair* add_kvps();
  inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >&
      kvps() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >*
      mutable_kvps();

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.M2MTransfer)
 private:
  inline void set_has_agent();
  inline void clear_has_agent();
  inline void set_has_mpin();
  inline void clear_has_mpin();
  inline void set_has_phone();
  inline void clear_has_phone();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_notice();
  inline void clear_has_notice();
  inline void set_has_channel();
  inline void clear_has_channel();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* agent_;
  ::std::string* mpin_;
  ::std::string* phone_;
  ::google::protobuf::uint64 amount_;
  ::std::string* notice_;
  ::std::string* channel_;
  ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair > kvps_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_SoapProto_2eproto();
  friend void protobuf_AssignDesc_SoapProto_2eproto();
  friend void protobuf_ShutdownFile_SoapProto_2eproto();

  void InitAsDefaultInstance();
  static M2MTransfer* default_instance_;
};
// -------------------------------------------------------------------

class TransferMoney2Place : public ::google::protobuf::Message {
 public:
  TransferMoney2Place();
  virtual ~TransferMoney2Place();

  TransferMoney2Place(const TransferMoney2Place& from);

  inline TransferMoney2Place& operator=(const TransferMoney2Place& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransferMoney2Place& default_instance();

  void Swap(TransferMoney2Place* other);

  // implements Message ----------------------------------------------

  TransferMoney2Place* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransferMoney2Place& from);
  void MergeFrom(const TransferMoney2Place& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string agent = 1;
  inline bool has_agent() const;
  inline void clear_agent();
  static const int kAgentFieldNumber = 1;
  inline const ::std::string& agent() const;
  inline void set_agent(const ::std::string& value);
  inline void set_agent(const char* value);
  inline void set_agent(const char* value, size_t size);
  inline ::std::string* mutable_agent();
  inline ::std::string* release_agent();
  inline void set_allocated_agent(::std::string* agent);

  // optional string mpin = 2;
  inline bool has_mpin() const;
  inline void clear_mpin();
  static const int kMpinFieldNumber = 2;
  inline const ::std::string& mpin() const;
  inline void set_mpin(const ::std::string& value);
  inline void set_mpin(const char* value);
  inline void set_mpin(const char* value, size_t size);
  inline ::std::string* mutable_mpin();
  inline ::std::string* release_mpin();
  inline void set_allocated_mpin(::std::string* mpin);

  // optional string phone = 3;
  inline bool has_phone() const;
  inline void clear_phone();
  static const int kPhoneFieldNumber = 3;
  inline const ::std::string& phone() const;
  inline void set_phone(const ::std::string& value);
  inline void set_phone(const char* value);
  inline void set_phone(const char* value, size_t size);
  inline ::std::string* mutable_phone();
  inline ::std::string* release_phone();
  inline void set_allocated_phone(::std::string* phone);

  // optional uint64 amount = 4;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 4;
  inline ::google::protobuf::uint64 amount() const;
  inline void set_amount(::google::protobuf::uint64 value);

  // optional string notice = 5;
  inline bool has_notice() const;
  inline void clear_notice();
  static const int kNoticeFieldNumber = 5;
  inline const ::std::string& notice() const;
  inline void set_notice(const ::std::string& value);
  inline void set_notice(const char* value);
  inline void set_notice(const char* value, size_t size);
  inline ::std::string* mutable_notice();
  inline ::std::string* release_notice();
  inline void set_allocated_notice(::std::string* notice);

  // optional string channel = 6;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 6;
  inline const ::std::string& channel() const;
  inline void set_channel(const ::std::string& value);
  inline void set_channel(const char* value);
  inline void set_channel(const char* value, size_t size);
  inline ::std::string* mutable_channel();
  inline ::std::string* release_channel();
  inline void set_allocated_channel(::std::string* channel);

  // repeated .com.mservice.momo.msg.keyValuePair kvps = 7;
  inline int kvps_size() const;
  inline void clear_kvps();
  static const int kKvpsFieldNumber = 7;
  inline const ::com::mservice::momo::msg::keyValuePair& kvps(int index) const;
  inline ::com::mservice::momo::msg::keyValuePair* mutable_kvps(int index);
  inline ::com::mservice::momo::msg::keyValuePair* add_kvps();
  inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >&
      kvps() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >*
      mutable_kvps();

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.TransferMoney2Place)
 private:
  inline void set_has_agent();
  inline void clear_has_agent();
  inline void set_has_mpin();
  inline void clear_has_mpin();
  inline void set_has_phone();
  inline void clear_has_phone();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_notice();
  inline void clear_has_notice();
  inline void set_has_channel();
  inline void clear_has_channel();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* agent_;
  ::std::string* mpin_;
  ::std::string* phone_;
  ::google::protobuf::uint64 amount_;
  ::std::string* notice_;
  ::std::string* channel_;
  ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair > kvps_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_SoapProto_2eproto();
  friend void protobuf_AssignDesc_SoapProto_2eproto();
  friend void protobuf_ShutdownFile_SoapProto_2eproto();

  void InitAsDefaultInstance();
  static TransferMoney2Place* default_instance_;
};
// -------------------------------------------------------------------

class ChangePin : public ::google::protobuf::Message {
 public:
  ChangePin();
  virtual ~ChangePin();

  ChangePin(const ChangePin& from);

  inline ChangePin& operator=(const ChangePin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangePin& default_instance();

  void Swap(ChangePin* other);

  // implements Message ----------------------------------------------

  ChangePin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChangePin& from);
  void MergeFrom(const ChangePin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string number = 1;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 1;
  inline const ::std::string& number() const;
  inline void set_number(const ::std::string& value);
  inline void set_number(const char* value);
  inline void set_number(const char* value, size_t size);
  inline ::std::string* mutable_number();
  inline ::std::string* release_number();
  inline void set_allocated_number(::std::string* number);

  // optional string old_pin = 2;
  inline bool has_old_pin() const;
  inline void clear_old_pin();
  static const int kOldPinFieldNumber = 2;
  inline const ::std::string& old_pin() const;
  inline void set_old_pin(const ::std::string& value);
  inline void set_old_pin(const char* value);
  inline void set_old_pin(const char* value, size_t size);
  inline ::std::string* mutable_old_pin();
  inline ::std::string* release_old_pin();
  inline void set_allocated_old_pin(::std::string* old_pin);

  // optional string new_pin = 3;
  inline bool has_new_pin() const;
  inline void clear_new_pin();
  static const int kNewPinFieldNumber = 3;
  inline const ::std::string& new_pin() const;
  inline void set_new_pin(const ::std::string& value);
  inline void set_new_pin(const char* value);
  inline void set_new_pin(const char* value, size_t size);
  inline ::std::string* mutable_new_pin();
  inline ::std::string* release_new_pin();
  inline void set_allocated_new_pin(::std::string* new_pin);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.ChangePin)
 private:
  inline void set_has_number();
  inline void clear_has_number();
  inline void set_has_old_pin();
  inline void clear_has_old_pin();
  inline void set_has_new_pin();
  inline void clear_has_new_pin();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* number_;
  ::std::string* old_pin_;
  ::std::string* new_pin_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_SoapProto_2eproto();
  friend void protobuf_AssignDesc_SoapProto_2eproto();
  friend void protobuf_ShutdownFile_SoapProto_2eproto();

  void InitAsDefaultInstance();
  static ChangePin* default_instance_;
};
// -------------------------------------------------------------------

class RecoveryNewPin : public ::google::protobuf::Message {
 public:
  RecoveryNewPin();
  virtual ~RecoveryNewPin();

  RecoveryNewPin(const RecoveryNewPin& from);

  inline RecoveryNewPin& operator=(const RecoveryNewPin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RecoveryNewPin& default_instance();

  void Swap(RecoveryNewPin* other);

  // implements Message ----------------------------------------------

  RecoveryNewPin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RecoveryNewPin& from);
  void MergeFrom(const RecoveryNewPin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string number = 1;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 1;
  inline const ::std::string& number() const;
  inline void set_number(const ::std::string& value);
  inline void set_number(const char* value);
  inline void set_number(const char* value, size_t size);
  inline ::std::string* mutable_number();
  inline ::std::string* release_number();
  inline void set_allocated_number(::std::string* number);

  // optional string old_pin = 2;
  inline bool has_old_pin() const;
  inline void clear_old_pin();
  static const int kOldPinFieldNumber = 2;
  inline const ::std::string& old_pin() const;
  inline void set_old_pin(const ::std::string& value);
  inline void set_old_pin(const char* value);
  inline void set_old_pin(const char* value, size_t size);
  inline ::std::string* mutable_old_pin();
  inline ::std::string* release_old_pin();
  inline void set_allocated_old_pin(::std::string* old_pin);

  // optional string new_pin = 3;
  inline bool has_new_pin() const;
  inline void clear_new_pin();
  static const int kNewPinFieldNumber = 3;
  inline const ::std::string& new_pin() const;
  inline void set_new_pin(const ::std::string& value);
  inline void set_new_pin(const char* value);
  inline void set_new_pin(const char* value, size_t size);
  inline ::std::string* mutable_new_pin();
  inline ::std::string* release_new_pin();
  inline void set_allocated_new_pin(::std::string* new_pin);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.RecoveryNewPin)
 private:
  inline void set_has_number();
  inline void clear_has_number();
  inline void set_has_old_pin();
  inline void clear_has_old_pin();
  inline void set_has_new_pin();
  inline void clear_has_new_pin();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* number_;
  ::std::string* old_pin_;
  ::std::string* new_pin_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_SoapProto_2eproto();
  friend void protobuf_AssignDesc_SoapProto_2eproto();
  friend void protobuf_ShutdownFile_SoapProto_2eproto();

  void InitAsDefaultInstance();
  static RecoveryNewPin* default_instance_;
};
// -------------------------------------------------------------------

class PayOneBill : public ::google::protobuf::Message {
 public:
  PayOneBill();
  virtual ~PayOneBill();

  PayOneBill(const PayOneBill& from);

  inline PayOneBill& operator=(const PayOneBill& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PayOneBill& default_instance();

  void Swap(PayOneBill* other);

  // implements Message ----------------------------------------------

  PayOneBill* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PayOneBill& from);
  void MergeFrom(const PayOneBill& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string pin = 1;
  inline bool has_pin() const;
  inline void clear_pin();
  static const int kPinFieldNumber = 1;
  inline const ::std::string& pin() const;
  inline void set_pin(const ::std::string& value);
  inline void set_pin(const char* value);
  inline void set_pin(const char* value, size_t size);
  inline ::std::string* mutable_pin();
  inline ::std::string* release_pin();
  inline void set_allocated_pin(::std::string* pin);

  // optional string providerId = 2;
  inline bool has_providerid() const;
  inline void clear_providerid();
  static const int kProviderIdFieldNumber = 2;
  inline const ::std::string& providerid() const;
  inline void set_providerid(const ::std::string& value);
  inline void set_providerid(const char* value);
  inline void set_providerid(const char* value, size_t size);
  inline ::std::string* mutable_providerid();
  inline ::std::string* release_providerid();
  inline void set_allocated_providerid(::std::string* providerid);

  // optional string billId = 3;
  inline bool has_billid() const;
  inline void clear_billid();
  static const int kBillIdFieldNumber = 3;
  inline const ::std::string& billid() const;
  inline void set_billid(const ::std::string& value);
  inline void set_billid(const char* value);
  inline void set_billid(const char* value, size_t size);
  inline ::std::string* mutable_billid();
  inline ::std::string* release_billid();
  inline void set_allocated_billid(::std::string* billid);

  // optional uint64 amount = 4;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 4;
  inline ::google::protobuf::uint64 amount() const;
  inline void set_amount(::google::protobuf::uint64 value);

  // optional string channel = 5;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 5;
  inline const ::std::string& channel() const;
  inline void set_channel(const ::std::string& value);
  inline void set_channel(const char* value);
  inline void set_channel(const char* value, size_t size);
  inline ::std::string* mutable_channel();
  inline ::std::string* release_channel();
  inline void set_allocated_channel(::std::string* channel);

  // repeated .com.mservice.momo.msg.keyValuePair keyValuePairs = 6;
  inline int keyvaluepairs_size() const;
  inline void clear_keyvaluepairs();
  static const int kKeyValuePairsFieldNumber = 6;
  inline const ::com::mservice::momo::msg::keyValuePair& keyvaluepairs(int index) const;
  inline ::com::mservice::momo::msg::keyValuePair* mutable_keyvaluepairs(int index);
  inline ::com::mservice::momo::msg::keyValuePair* add_keyvaluepairs();
  inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >&
      keyvaluepairs() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >*
      mutable_keyvaluepairs();

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.PayOneBill)
 private:
  inline void set_has_pin();
  inline void clear_has_pin();
  inline void set_has_providerid();
  inline void clear_has_providerid();
  inline void set_has_billid();
  inline void clear_has_billid();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_channel();
  inline void clear_has_channel();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* pin_;
  ::std::string* providerid_;
  ::std::string* billid_;
  ::google::protobuf::uint64 amount_;
  ::std::string* channel_;
  ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair > keyvaluepairs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_SoapProto_2eproto();
  friend void protobuf_AssignDesc_SoapProto_2eproto();
  friend void protobuf_ShutdownFile_SoapProto_2eproto();

  void InitAsDefaultInstance();
  static PayOneBill* default_instance_;
};
// -------------------------------------------------------------------

class PayMultiBills : public ::google::protobuf::Message {
 public:
  PayMultiBills();
  virtual ~PayMultiBills();

  PayMultiBills(const PayMultiBills& from);

  inline PayMultiBills& operator=(const PayMultiBills& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PayMultiBills& default_instance();

  void Swap(PayMultiBills* other);

  // implements Message ----------------------------------------------

  PayMultiBills* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PayMultiBills& from);
  void MergeFrom(const PayMultiBills& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string pin = 1;
  inline bool has_pin() const;
  inline void clear_pin();
  static const int kPinFieldNumber = 1;
  inline const ::std::string& pin() const;
  inline void set_pin(const ::std::string& value);
  inline void set_pin(const char* value);
  inline void set_pin(const char* value, size_t size);
  inline ::std::string* mutable_pin();
  inline ::std::string* release_pin();
  inline void set_allocated_pin(::std::string* pin);

  // optional string providerIds = 2;
  inline bool has_providerids() const;
  inline void clear_providerids();
  static const int kProviderIdsFieldNumber = 2;
  inline const ::std::string& providerids() const;
  inline void set_providerids(const ::std::string& value);
  inline void set_providerids(const char* value);
  inline void set_providerids(const char* value, size_t size);
  inline ::std::string* mutable_providerids();
  inline ::std::string* release_providerids();
  inline void set_allocated_providerids(::std::string* providerids);

  // optional string billIds = 3;
  inline bool has_billids() const;
  inline void clear_billids();
  static const int kBillIdsFieldNumber = 3;
  inline const ::std::string& billids() const;
  inline void set_billids(const ::std::string& value);
  inline void set_billids(const char* value);
  inline void set_billids(const char* value, size_t size);
  inline ::std::string* mutable_billids();
  inline ::std::string* release_billids();
  inline void set_allocated_billids(::std::string* billids);

  // optional string amounts = 4;
  inline bool has_amounts() const;
  inline void clear_amounts();
  static const int kAmountsFieldNumber = 4;
  inline const ::std::string& amounts() const;
  inline void set_amounts(const ::std::string& value);
  inline void set_amounts(const char* value);
  inline void set_amounts(const char* value, size_t size);
  inline ::std::string* mutable_amounts();
  inline ::std::string* release_amounts();
  inline void set_allocated_amounts(::std::string* amounts);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.PayMultiBills)
 private:
  inline void set_has_pin();
  inline void clear_has_pin();
  inline void set_has_providerids();
  inline void clear_has_providerids();
  inline void set_has_billids();
  inline void clear_has_billids();
  inline void set_has_amounts();
  inline void clear_has_amounts();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* pin_;
  ::std::string* providerids_;
  ::std::string* billids_;
  ::std::string* amounts_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_SoapProto_2eproto();
  friend void protobuf_AssignDesc_SoapProto_2eproto();
  friend void protobuf_ShutdownFile_SoapProto_2eproto();

  void InitAsDefaultInstance();
  static PayMultiBills* default_instance_;
};
// -------------------------------------------------------------------

class ViewPaymentHistoryByBillId : public ::google::protobuf::Message {
 public:
  ViewPaymentHistoryByBillId();
  virtual ~ViewPaymentHistoryByBillId();

  ViewPaymentHistoryByBillId(const ViewPaymentHistoryByBillId& from);

  inline ViewPaymentHistoryByBillId& operator=(const ViewPaymentHistoryByBillId& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ViewPaymentHistoryByBillId& default_instance();

  void Swap(ViewPaymentHistoryByBillId* other);

  // implements Message ----------------------------------------------

  ViewPaymentHistoryByBillId* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ViewPaymentHistoryByBillId& from);
  void MergeFrom(const ViewPaymentHistoryByBillId& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string pin = 1;
  inline bool has_pin() const;
  inline void clear_pin();
  static const int kPinFieldNumber = 1;
  inline const ::std::string& pin() const;
  inline void set_pin(const ::std::string& value);
  inline void set_pin(const char* value);
  inline void set_pin(const char* value, size_t size);
  inline ::std::string* mutable_pin();
  inline ::std::string* release_pin();
  inline void set_allocated_pin(::std::string* pin);

  // optional string billId = 2;
  inline bool has_billid() const;
  inline void clear_billid();
  static const int kBillIdFieldNumber = 2;
  inline const ::std::string& billid() const;
  inline void set_billid(const ::std::string& value);
  inline void set_billid(const char* value);
  inline void set_billid(const char* value, size_t size);
  inline ::std::string* mutable_billid();
  inline ::std::string* release_billid();
  inline void set_allocated_billid(::std::string* billid);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.ViewPaymentHistoryByBillId)
 private:
  inline void set_has_pin();
  inline void clear_has_pin();
  inline void set_has_billid();
  inline void clear_has_billid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* pin_;
  ::std::string* billid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_SoapProto_2eproto();
  friend void protobuf_AssignDesc_SoapProto_2eproto();
  friend void protobuf_ShutdownFile_SoapProto_2eproto();

  void InitAsDefaultInstance();
  static ViewPaymentHistoryByBillId* default_instance_;
};
// -------------------------------------------------------------------

class TopUpGame : public ::google::protobuf::Message {
 public:
  TopUpGame();
  virtual ~TopUpGame();

  TopUpGame(const TopUpGame& from);

  inline TopUpGame& operator=(const TopUpGame& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TopUpGame& default_instance();

  void Swap(TopUpGame* other);

  // implements Message ----------------------------------------------

  TopUpGame* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TopUpGame& from);
  void MergeFrom(const TopUpGame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string mpin = 1;
  inline bool has_mpin() const;
  inline void clear_mpin();
  static const int kMpinFieldNumber = 1;
  inline const ::std::string& mpin() const;
  inline void set_mpin(const ::std::string& value);
  inline void set_mpin(const char* value);
  inline void set_mpin(const char* value, size_t size);
  inline ::std::string* mutable_mpin();
  inline ::std::string* release_mpin();
  inline void set_allocated_mpin(::std::string* mpin);

  // optional string providerId = 2;
  inline bool has_providerid() const;
  inline void clear_providerid();
  static const int kProviderIdFieldNumber = 2;
  inline const ::std::string& providerid() const;
  inline void set_providerid(const ::std::string& value);
  inline void set_providerid(const char* value);
  inline void set_providerid(const char* value, size_t size);
  inline ::std::string* mutable_providerid();
  inline ::std::string* release_providerid();
  inline void set_allocated_providerid(::std::string* providerid);

  // optional uint64 amount = 3;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 3;
  inline ::google::protobuf::uint64 amount() const;
  inline void set_amount(::google::protobuf::uint64 value);

  // optional string game_account = 4;
  inline bool has_game_account() const;
  inline void clear_game_account();
  static const int kGameAccountFieldNumber = 4;
  inline const ::std::string& game_account() const;
  inline void set_game_account(const ::std::string& value);
  inline void set_game_account(const char* value);
  inline void set_game_account(const char* value, size_t size);
  inline ::std::string* mutable_game_account();
  inline ::std::string* release_game_account();
  inline void set_allocated_game_account(::std::string* game_account);

  // optional string channel = 5;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 5;
  inline const ::std::string& channel() const;
  inline void set_channel(const ::std::string& value);
  inline void set_channel(const char* value);
  inline void set_channel(const char* value, size_t size);
  inline ::std::string* mutable_channel();
  inline ::std::string* release_channel();
  inline void set_allocated_channel(::std::string* channel);

  // repeated .com.mservice.momo.msg.keyValuePair keyValuePairs = 6;
  inline int keyvaluepairs_size() const;
  inline void clear_keyvaluepairs();
  static const int kKeyValuePairsFieldNumber = 6;
  inline const ::com::mservice::momo::msg::keyValuePair& keyvaluepairs(int index) const;
  inline ::com::mservice::momo::msg::keyValuePair* mutable_keyvaluepairs(int index);
  inline ::com::mservice::momo::msg::keyValuePair* add_keyvaluepairs();
  inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >&
      keyvaluepairs() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >*
      mutable_keyvaluepairs();

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.TopUpGame)
 private:
  inline void set_has_mpin();
  inline void clear_has_mpin();
  inline void set_has_providerid();
  inline void clear_has_providerid();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_game_account();
  inline void clear_has_game_account();
  inline void set_has_channel();
  inline void clear_has_channel();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* mpin_;
  ::std::string* providerid_;
  ::google::protobuf::uint64 amount_;
  ::std::string* game_account_;
  ::std::string* channel_;
  ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair > keyvaluepairs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_SoapProto_2eproto();
  friend void protobuf_AssignDesc_SoapProto_2eproto();
  friend void protobuf_ShutdownFile_SoapProto_2eproto();

  void InitAsDefaultInstance();
  static TopUpGame* default_instance_;
};
// -------------------------------------------------------------------

class CheckPhoneDetail : public ::google::protobuf::Message {
 public:
  CheckPhoneDetail();
  virtual ~CheckPhoneDetail();

  CheckPhoneDetail(const CheckPhoneDetail& from);

  inline CheckPhoneDetail& operator=(const CheckPhoneDetail& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckPhoneDetail& default_instance();

  void Swap(CheckPhoneDetail* other);

  // implements Message ----------------------------------------------

  CheckPhoneDetail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CheckPhoneDetail& from);
  void MergeFrom(const CheckPhoneDetail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string number = 1;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 1;
  inline const ::std::string& number() const;
  inline void set_number(const ::std::string& value);
  inline void set_number(const char* value);
  inline void set_number(const char* value, size_t size);
  inline ::std::string* mutable_number();
  inline ::std::string* release_number();
  inline void set_allocated_number(::std::string* number);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.CheckPhoneDetail)
 private:
  inline void set_has_number();
  inline void clear_has_number();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* number_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_SoapProto_2eproto();
  friend void protobuf_AssignDesc_SoapProto_2eproto();
  friend void protobuf_ShutdownFile_SoapProto_2eproto();

  void InitAsDefaultInstance();
  static CheckPhoneDetail* default_instance_;
};
// -------------------------------------------------------------------

class GetStoreAround : public ::google::protobuf::Message {
 public:
  GetStoreAround();
  virtual ~GetStoreAround();

  GetStoreAround(const GetStoreAround& from);

  inline GetStoreAround& operator=(const GetStoreAround& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetStoreAround& default_instance();

  void Swap(GetStoreAround* other);

  // implements Message ----------------------------------------------

  GetStoreAround* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetStoreAround& from);
  void MergeFrom(const GetStoreAround& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double lng = 1;
  inline bool has_lng() const;
  inline void clear_lng();
  static const int kLngFieldNumber = 1;
  inline double lng() const;
  inline void set_lng(double value);

  // optional double lat = 2;
  inline bool has_lat() const;
  inline void clear_lat();
  static const int kLatFieldNumber = 2;
  inline double lat() const;
  inline void set_lat(double value);

  // optional string street = 3;
  inline bool has_street() const;
  inline void clear_street();
  static const int kStreetFieldNumber = 3;
  inline const ::std::string& street() const;
  inline void set_street(const ::std::string& value);
  inline void set_street(const char* value);
  inline void set_street(const char* value, size_t size);
  inline ::std::string* mutable_street();
  inline ::std::string* release_street();
  inline void set_allocated_street(::std::string* street);

  // optional string ward = 4;
  inline bool has_ward() const;
  inline void clear_ward();
  static const int kWardFieldNumber = 4;
  inline const ::std::string& ward() const;
  inline void set_ward(const ::std::string& value);
  inline void set_ward(const char* value);
  inline void set_ward(const char* value, size_t size);
  inline ::std::string* mutable_ward();
  inline ::std::string* release_ward();
  inline void set_allocated_ward(::std::string* ward);

  // optional string district = 5;
  inline bool has_district() const;
  inline void clear_district();
  static const int kDistrictFieldNumber = 5;
  inline const ::std::string& district() const;
  inline void set_district(const ::std::string& value);
  inline void set_district(const char* value);
  inline void set_district(const char* value, size_t size);
  inline ::std::string* mutable_district();
  inline ::std::string* release_district();
  inline void set_allocated_district(::std::string* district);

  // optional string city = 6;
  inline bool has_city() const;
  inline void clear_city();
  static const int kCityFieldNumber = 6;
  inline const ::std::string& city() const;
  inline void set_city(const ::std::string& value);
  inline void set_city(const char* value);
  inline void set_city(const char* value, size_t size);
  inline ::std::string* mutable_city();
  inline ::std::string* release_city();
  inline void set_allocated_city(::std::string* city);

  // optional string area = 7;
  inline bool has_area() const;
  inline void clear_area();
  static const int kAreaFieldNumber = 7;
  inline const ::std::string& area() const;
  inline void set_area(const ::std::string& value);
  inline void set_area(const char* value);
  inline void set_area(const char* value, size_t size);
  inline ::std::string* mutable_area();
  inline ::std::string* release_area();
  inline void set_allocated_area(::std::string* area);

  // optional uint32 limit = 8;
  inline bool has_limit() const;
  inline void clear_limit();
  static const int kLimitFieldNumber = 8;
  inline ::google::protobuf::uint32 limit() const;
  inline void set_limit(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.GetStoreAround)
 private:
  inline void set_has_lng();
  inline void clear_has_lng();
  inline void set_has_lat();
  inline void clear_has_lat();
  inline void set_has_street();
  inline void clear_has_street();
  inline void set_has_ward();
  inline void clear_has_ward();
  inline void set_has_district();
  inline void clear_has_district();
  inline void set_has_city();
  inline void clear_has_city();
  inline void set_has_area();
  inline void clear_has_area();
  inline void set_has_limit();
  inline void clear_has_limit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double lng_;
  double lat_;
  ::std::string* street_;
  ::std::string* ward_;
  ::std::string* district_;
  ::std::string* city_;
  ::std::string* area_;
  ::google::protobuf::uint32 limit_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_SoapProto_2eproto();
  friend void protobuf_AssignDesc_SoapProto_2eproto();
  friend void protobuf_ShutdownFile_SoapProto_2eproto();

  void InitAsDefaultInstance();
  static GetStoreAround* default_instance_;
};
// -------------------------------------------------------------------

class QuickDeposit : public ::google::protobuf::Message {
 public:
  QuickDeposit();
  virtual ~QuickDeposit();

  QuickDeposit(const QuickDeposit& from);

  inline QuickDeposit& operator=(const QuickDeposit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QuickDeposit& default_instance();

  void Swap(QuickDeposit* other);

  // implements Message ----------------------------------------------

  QuickDeposit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QuickDeposit& from);
  void MergeFrom(const QuickDeposit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string providerId = 1;
  inline bool has_providerid() const;
  inline void clear_providerid();
  static const int kProviderIdFieldNumber = 1;
  inline const ::std::string& providerid() const;
  inline void set_providerid(const ::std::string& value);
  inline void set_providerid(const char* value);
  inline void set_providerid(const char* value, size_t size);
  inline ::std::string* mutable_providerid();
  inline ::std::string* release_providerid();
  inline void set_allocated_providerid(::std::string* providerid);

  // optional string tellerId = 2;
  inline bool has_tellerid() const;
  inline void clear_tellerid();
  static const int kTellerIdFieldNumber = 2;
  inline const ::std::string& tellerid() const;
  inline void set_tellerid(const ::std::string& value);
  inline void set_tellerid(const char* value);
  inline void set_tellerid(const char* value, size_t size);
  inline ::std::string* mutable_tellerid();
  inline ::std::string* release_tellerid();
  inline void set_allocated_tellerid(::std::string* tellerid);

  // optional string billId = 3;
  inline bool has_billid() const;
  inline void clear_billid();
  static const int kBillIdFieldNumber = 3;
  inline const ::std::string& billid() const;
  inline void set_billid(const ::std::string& value);
  inline void set_billid(const char* value);
  inline void set_billid(const char* value, size_t size);
  inline ::std::string* mutable_billid();
  inline ::std::string* release_billid();
  inline void set_allocated_billid(::std::string* billid);

  // optional uint64 amount = 4;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 4;
  inline ::google::protobuf::uint64 amount() const;
  inline void set_amount(::google::protobuf::uint64 value);

  // optional string pin = 5;
  inline bool has_pin() const;
  inline void clear_pin();
  static const int kPinFieldNumber = 5;
  inline const ::std::string& pin() const;
  inline void set_pin(const ::std::string& value);
  inline void set_pin(const char* value);
  inline void set_pin(const char* value, size_t size);
  inline ::std::string* mutable_pin();
  inline ::std::string* release_pin();
  inline void set_allocated_pin(::std::string* pin);

  // optional string channel = 6;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 6;
  inline const ::std::string& channel() const;
  inline void set_channel(const ::std::string& value);
  inline void set_channel(const char* value);
  inline void set_channel(const char* value, size_t size);
  inline ::std::string* mutable_channel();
  inline ::std::string* release_channel();
  inline void set_allocated_channel(::std::string* channel);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.QuickDeposit)
 private:
  inline void set_has_providerid();
  inline void clear_has_providerid();
  inline void set_has_tellerid();
  inline void clear_has_tellerid();
  inline void set_has_billid();
  inline void clear_has_billid();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_pin();
  inline void clear_has_pin();
  inline void set_has_channel();
  inline void clear_has_channel();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* providerid_;
  ::std::string* tellerid_;
  ::std::string* billid_;
  ::google::protobuf::uint64 amount_;
  ::std::string* pin_;
  ::std::string* channel_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_SoapProto_2eproto();
  friend void protobuf_AssignDesc_SoapProto_2eproto();
  friend void protobuf_ShutdownFile_SoapProto_2eproto();

  void InitAsDefaultInstance();
  static QuickDeposit* default_instance_;
};
// -------------------------------------------------------------------

class QuickPayment : public ::google::protobuf::Message {
 public:
  QuickPayment();
  virtual ~QuickPayment();

  QuickPayment(const QuickPayment& from);

  inline QuickPayment& operator=(const QuickPayment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QuickPayment& default_instance();

  void Swap(QuickPayment* other);

  // implements Message ----------------------------------------------

  QuickPayment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QuickPayment& from);
  void MergeFrom(const QuickPayment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string providerId = 1;
  inline bool has_providerid() const;
  inline void clear_providerid();
  static const int kProviderIdFieldNumber = 1;
  inline const ::std::string& providerid() const;
  inline void set_providerid(const ::std::string& value);
  inline void set_providerid(const char* value);
  inline void set_providerid(const char* value, size_t size);
  inline ::std::string* mutable_providerid();
  inline ::std::string* release_providerid();
  inline void set_allocated_providerid(::std::string* providerid);

  // optional string tellerId = 2;
  inline bool has_tellerid() const;
  inline void clear_tellerid();
  static const int kTellerIdFieldNumber = 2;
  inline const ::std::string& tellerid() const;
  inline void set_tellerid(const ::std::string& value);
  inline void set_tellerid(const char* value);
  inline void set_tellerid(const char* value, size_t size);
  inline ::std::string* mutable_tellerid();
  inline ::std::string* release_tellerid();
  inline void set_allocated_tellerid(::std::string* tellerid);

  // optional string billId = 3;
  inline bool has_billid() const;
  inline void clear_billid();
  static const int kBillIdFieldNumber = 3;
  inline const ::std::string& billid() const;
  inline void set_billid(const ::std::string& value);
  inline void set_billid(const char* value);
  inline void set_billid(const char* value, size_t size);
  inline ::std::string* mutable_billid();
  inline ::std::string* release_billid();
  inline void set_allocated_billid(::std::string* billid);

  // optional uint64 amount = 4;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 4;
  inline ::google::protobuf::uint64 amount() const;
  inline void set_amount(::google::protobuf::uint64 value);

  // optional string pin = 5;
  inline bool has_pin() const;
  inline void clear_pin();
  static const int kPinFieldNumber = 5;
  inline const ::std::string& pin() const;
  inline void set_pin(const ::std::string& value);
  inline void set_pin(const char* value);
  inline void set_pin(const char* value, size_t size);
  inline ::std::string* mutable_pin();
  inline ::std::string* release_pin();
  inline void set_allocated_pin(::std::string* pin);

  // optional string channel = 6;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 6;
  inline const ::std::string& channel() const;
  inline void set_channel(const ::std::string& value);
  inline void set_channel(const char* value);
  inline void set_channel(const char* value, size_t size);
  inline ::std::string* mutable_channel();
  inline ::std::string* release_channel();
  inline void set_allocated_channel(::std::string* channel);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.QuickPayment)
 private:
  inline void set_has_providerid();
  inline void clear_has_providerid();
  inline void set_has_tellerid();
  inline void clear_has_tellerid();
  inline void set_has_billid();
  inline void clear_has_billid();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_pin();
  inline void clear_has_pin();
  inline void set_has_channel();
  inline void clear_has_channel();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* providerid_;
  ::std::string* tellerid_;
  ::std::string* billid_;
  ::google::protobuf::uint64 amount_;
  ::std::string* pin_;
  ::std::string* channel_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_SoapProto_2eproto();
  friend void protobuf_AssignDesc_SoapProto_2eproto();
  friend void protobuf_ShutdownFile_SoapProto_2eproto();

  void InitAsDefaultInstance();
  static QuickPayment* default_instance_;
};
// -------------------------------------------------------------------

class BankNetToMomo : public ::google::protobuf::Message {
 public:
  BankNetToMomo();
  virtual ~BankNetToMomo();

  BankNetToMomo(const BankNetToMomo& from);

  inline BankNetToMomo& operator=(const BankNetToMomo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BankNetToMomo& default_instance();

  void Swap(BankNetToMomo* other);

  // implements Message ----------------------------------------------

  BankNetToMomo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BankNetToMomo& from);
  void MergeFrom(const BankNetToMomo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 amount = 1;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 1;
  inline ::google::protobuf::uint64 amount() const;
  inline void set_amount(::google::protobuf::uint64 value);

  // optional string bankId = 2;
  inline bool has_bankid() const;
  inline void clear_bankid();
  static const int kBankIdFieldNumber = 2;
  inline const ::std::string& bankid() const;
  inline void set_bankid(const ::std::string& value);
  inline void set_bankid(const char* value);
  inline void set_bankid(const char* value, size_t size);
  inline ::std::string* mutable_bankid();
  inline ::std::string* release_bankid();
  inline void set_allocated_bankid(::std::string* bankid);

  // optional string card_holder_name = 3;
  inline bool has_card_holder_name() const;
  inline void clear_card_holder_name();
  static const int kCardHolderNameFieldNumber = 3;
  inline const ::std::string& card_holder_name() const;
  inline void set_card_holder_name(const ::std::string& value);
  inline void set_card_holder_name(const char* value);
  inline void set_card_holder_name(const char* value, size_t size);
  inline ::std::string* mutable_card_holder_name();
  inline ::std::string* release_card_holder_name();
  inline void set_allocated_card_holder_name(::std::string* card_holder_name);

  // optional string card_holder_number = 4;
  inline bool has_card_holder_number() const;
  inline void clear_card_holder_number();
  static const int kCardHolderNumberFieldNumber = 4;
  inline const ::std::string& card_holder_number() const;
  inline void set_card_holder_number(const ::std::string& value);
  inline void set_card_holder_number(const char* value);
  inline void set_card_holder_number(const char* value, size_t size);
  inline ::std::string* mutable_card_holder_number();
  inline ::std::string* release_card_holder_number();
  inline void set_allocated_card_holder_number(::std::string* card_holder_number);

  // optional string card_holder_month = 5;
  inline bool has_card_holder_month() const;
  inline void clear_card_holder_month();
  static const int kCardHolderMonthFieldNumber = 5;
  inline const ::std::string& card_holder_month() const;
  inline void set_card_holder_month(const ::std::string& value);
  inline void set_card_holder_month(const char* value);
  inline void set_card_holder_month(const char* value, size_t size);
  inline ::std::string* mutable_card_holder_month();
  inline ::std::string* release_card_holder_month();
  inline void set_allocated_card_holder_month(::std::string* card_holder_month);

  // optional string card_holder_year = 6;
  inline bool has_card_holder_year() const;
  inline void clear_card_holder_year();
  static const int kCardHolderYearFieldNumber = 6;
  inline const ::std::string& card_holder_year() const;
  inline void set_card_holder_year(const ::std::string& value);
  inline void set_card_holder_year(const char* value);
  inline void set_card_holder_year(const char* value, size_t size);
  inline ::std::string* mutable_card_holder_year();
  inline ::std::string* release_card_holder_year();
  inline void set_allocated_card_holder_year(::std::string* card_holder_year);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.BankNetToMomo)
 private:
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_bankid();
  inline void clear_has_bankid();
  inline void set_has_card_holder_name();
  inline void clear_has_card_holder_name();
  inline void set_has_card_holder_number();
  inline void clear_has_card_holder_number();
  inline void set_has_card_holder_month();
  inline void clear_has_card_holder_month();
  inline void set_has_card_holder_year();
  inline void clear_has_card_holder_year();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 amount_;
  ::std::string* bankid_;
  ::std::string* card_holder_name_;
  ::std::string* card_holder_number_;
  ::std::string* card_holder_month_;
  ::std::string* card_holder_year_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_SoapProto_2eproto();
  friend void protobuf_AssignDesc_SoapProto_2eproto();
  friend void protobuf_ShutdownFile_SoapProto_2eproto();

  void InitAsDefaultInstance();
  static BankNetToMomo* default_instance_;
};
// -------------------------------------------------------------------

class BankNetVerifyOtp : public ::google::protobuf::Message {
 public:
  BankNetVerifyOtp();
  virtual ~BankNetVerifyOtp();

  BankNetVerifyOtp(const BankNetVerifyOtp& from);

  inline BankNetVerifyOtp& operator=(const BankNetVerifyOtp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BankNetVerifyOtp& default_instance();

  void Swap(BankNetVerifyOtp* other);

  // implements Message ----------------------------------------------

  BankNetVerifyOtp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BankNetVerifyOtp& from);
  void MergeFrom(const BankNetVerifyOtp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string merchant_trans_id = 1;
  inline bool has_merchant_trans_id() const;
  inline void clear_merchant_trans_id();
  static const int kMerchantTransIdFieldNumber = 1;
  inline const ::std::string& merchant_trans_id() const;
  inline void set_merchant_trans_id(const ::std::string& value);
  inline void set_merchant_trans_id(const char* value);
  inline void set_merchant_trans_id(const char* value, size_t size);
  inline ::std::string* mutable_merchant_trans_id();
  inline ::std::string* release_merchant_trans_id();
  inline void set_allocated_merchant_trans_id(::std::string* merchant_trans_id);

  // optional string trans_id = 2;
  inline bool has_trans_id() const;
  inline void clear_trans_id();
  static const int kTransIdFieldNumber = 2;
  inline const ::std::string& trans_id() const;
  inline void set_trans_id(const ::std::string& value);
  inline void set_trans_id(const char* value);
  inline void set_trans_id(const char* value, size_t size);
  inline ::std::string* mutable_trans_id();
  inline ::std::string* release_trans_id();
  inline void set_allocated_trans_id(::std::string* trans_id);

  // optional uint64 amount = 3;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 3;
  inline ::google::protobuf::uint64 amount() const;
  inline void set_amount(::google::protobuf::uint64 value);

  // optional string otp = 4;
  inline bool has_otp() const;
  inline void clear_otp();
  static const int kOtpFieldNumber = 4;
  inline const ::std::string& otp() const;
  inline void set_otp(const ::std::string& value);
  inline void set_otp(const char* value);
  inline void set_otp(const char* value, size_t size);
  inline ::std::string* mutable_otp();
  inline ::std::string* release_otp();
  inline void set_allocated_otp(::std::string* otp);

  // repeated .com.mservice.momo.msg.keyValuePair kvps = 5;
  inline int kvps_size() const;
  inline void clear_kvps();
  static const int kKvpsFieldNumber = 5;
  inline const ::com::mservice::momo::msg::keyValuePair& kvps(int index) const;
  inline ::com::mservice::momo::msg::keyValuePair* mutable_kvps(int index);
  inline ::com::mservice::momo::msg::keyValuePair* add_kvps();
  inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >&
      kvps() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >*
      mutable_kvps();

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.BankNetVerifyOtp)
 private:
  inline void set_has_merchant_trans_id();
  inline void clear_has_merchant_trans_id();
  inline void set_has_trans_id();
  inline void clear_has_trans_id();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_otp();
  inline void clear_has_otp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* merchant_trans_id_;
  ::std::string* trans_id_;
  ::google::protobuf::uint64 amount_;
  ::std::string* otp_;
  ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair > kvps_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_SoapProto_2eproto();
  friend void protobuf_AssignDesc_SoapProto_2eproto();
  friend void protobuf_ShutdownFile_SoapProto_2eproto();

  void InitAsDefaultInstance();
  static BankNetVerifyOtp* default_instance_;
};
// -------------------------------------------------------------------

class Broadcast : public ::google::protobuf::Message {
 public:
  Broadcast();
  virtual ~Broadcast();

  Broadcast(const Broadcast& from);

  inline Broadcast& operator=(const Broadcast& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Broadcast& default_instance();

  void Swap(Broadcast* other);

  // implements Message ----------------------------------------------

  Broadcast* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Broadcast& from);
  void MergeFrom(const Broadcast& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Broadcast_MsgType MsgType;
  static const MsgType NOTICE = Broadcast_MsgType_NOTICE;
  static const MsgType ADVERTISE = Broadcast_MsgType_ADVERTISE;
  static const MsgType NEW_USER = Broadcast_MsgType_NEW_USER;
  static const MsgType MONEY_REQ = Broadcast_MsgType_MONEY_REQ;
  static const MsgType KILL_PREV = Broadcast_MsgType_KILL_PREV;
  static const MsgType MONEY_RECV = Broadcast_MsgType_MONEY_RECV;
  static const MsgType TRANS_OUSIDE = Broadcast_MsgType_TRANS_OUSIDE;
  static const MsgType NOTIFICATION = Broadcast_MsgType_NOTIFICATION;
  static const MsgType CHECK_PREV = Broadcast_MsgType_CHECK_PREV;
  static const MsgType PREV_RETURN = Broadcast_MsgType_PREV_RETURN;
  static const MsgType FORCE_UPDATE_AGENT_INFO = Broadcast_MsgType_FORCE_UPDATE_AGENT_INFO;
  static const MsgType GET_TOKEN = Broadcast_MsgType_GET_TOKEN;
  static inline bool MsgType_IsValid(int value) {
    return Broadcast_MsgType_IsValid(value);
  }
  static const MsgType MsgType_MIN =
    Broadcast_MsgType_MsgType_MIN;
  static const MsgType MsgType_MAX =
    Broadcast_MsgType_MsgType_MAX;
  static const int MsgType_ARRAYSIZE =
    Broadcast_MsgType_MsgType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MsgType_descriptor() {
    return Broadcast_MsgType_descriptor();
  }
  static inline const ::std::string& MsgType_Name(MsgType value) {
    return Broadcast_MsgType_Name(value);
  }
  static inline bool MsgType_Parse(const ::std::string& name,
      MsgType* value) {
    return Broadcast_MsgType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .com.mservice.momo.msg.Broadcast.MsgType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::com::mservice::momo::msg::Broadcast_MsgType type() const;
  inline void set_type(::com::mservice::momo::msg::Broadcast_MsgType value);

  // optional string sender = 2;
  inline bool has_sender() const;
  inline void clear_sender();
  static const int kSenderFieldNumber = 2;
  inline const ::std::string& sender() const;
  inline void set_sender(const ::std::string& value);
  inline void set_sender(const char* value);
  inline void set_sender(const char* value, size_t size);
  inline ::std::string* mutable_sender();
  inline ::std::string* release_sender();
  inline void set_allocated_sender(::std::string* sender);

  // optional string content = 3;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 3;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.Broadcast)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_sender();
  inline void clear_has_sender();
  inline void set_has_content();
  inline void clear_has_content();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* sender_;
  ::std::string* content_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_SoapProto_2eproto();
  friend void protobuf_AssignDesc_SoapProto_2eproto();
  friend void protobuf_ShutdownFile_SoapProto_2eproto();

  void InitAsDefaultInstance();
  static Broadcast* default_instance_;
};
// ===================================================================


// ===================================================================

// ZaloGroup

// optional string zalo_group = 1;
inline bool ZaloGroup::has_zalo_group() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ZaloGroup::set_has_zalo_group() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ZaloGroup::clear_has_zalo_group() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ZaloGroup::clear_zalo_group() {
  if (zalo_group_ != &::google::protobuf::internal::kEmptyString) {
    zalo_group_->clear();
  }
  clear_has_zalo_group();
}
inline const ::std::string& ZaloGroup::zalo_group() const {
  return *zalo_group_;
}
inline void ZaloGroup::set_zalo_group(const ::std::string& value) {
  set_has_zalo_group();
  if (zalo_group_ == &::google::protobuf::internal::kEmptyString) {
    zalo_group_ = new ::std::string;
  }
  zalo_group_->assign(value);
}
inline void ZaloGroup::set_zalo_group(const char* value) {
  set_has_zalo_group();
  if (zalo_group_ == &::google::protobuf::internal::kEmptyString) {
    zalo_group_ = new ::std::string;
  }
  zalo_group_->assign(value);
}
inline void ZaloGroup::set_zalo_group(const char* value, size_t size) {
  set_has_zalo_group();
  if (zalo_group_ == &::google::protobuf::internal::kEmptyString) {
    zalo_group_ = new ::std::string;
  }
  zalo_group_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZaloGroup::mutable_zalo_group() {
  set_has_zalo_group();
  if (zalo_group_ == &::google::protobuf::internal::kEmptyString) {
    zalo_group_ = new ::std::string;
  }
  return zalo_group_;
}
inline ::std::string* ZaloGroup::release_zalo_group() {
  clear_has_zalo_group();
  if (zalo_group_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = zalo_group_;
    zalo_group_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ZaloGroup::set_allocated_zalo_group(::std::string* zalo_group) {
  if (zalo_group_ != &::google::protobuf::internal::kEmptyString) {
    delete zalo_group_;
  }
  if (zalo_group) {
    set_has_zalo_group();
    zalo_group_ = zalo_group;
  } else {
    clear_has_zalo_group();
    zalo_group_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string zalo_capset_id = 2;
inline bool ZaloGroup::has_zalo_capset_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ZaloGroup::set_has_zalo_capset_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ZaloGroup::clear_has_zalo_capset_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ZaloGroup::clear_zalo_capset_id() {
  if (zalo_capset_id_ != &::google::protobuf::internal::kEmptyString) {
    zalo_capset_id_->clear();
  }
  clear_has_zalo_capset_id();
}
inline const ::std::string& ZaloGroup::zalo_capset_id() const {
  return *zalo_capset_id_;
}
inline void ZaloGroup::set_zalo_capset_id(const ::std::string& value) {
  set_has_zalo_capset_id();
  if (zalo_capset_id_ == &::google::protobuf::internal::kEmptyString) {
    zalo_capset_id_ = new ::std::string;
  }
  zalo_capset_id_->assign(value);
}
inline void ZaloGroup::set_zalo_capset_id(const char* value) {
  set_has_zalo_capset_id();
  if (zalo_capset_id_ == &::google::protobuf::internal::kEmptyString) {
    zalo_capset_id_ = new ::std::string;
  }
  zalo_capset_id_->assign(value);
}
inline void ZaloGroup::set_zalo_capset_id(const char* value, size_t size) {
  set_has_zalo_capset_id();
  if (zalo_capset_id_ == &::google::protobuf::internal::kEmptyString) {
    zalo_capset_id_ = new ::std::string;
  }
  zalo_capset_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZaloGroup::mutable_zalo_capset_id() {
  set_has_zalo_capset_id();
  if (zalo_capset_id_ == &::google::protobuf::internal::kEmptyString) {
    zalo_capset_id_ = new ::std::string;
  }
  return zalo_capset_id_;
}
inline ::std::string* ZaloGroup::release_zalo_capset_id() {
  clear_has_zalo_capset_id();
  if (zalo_capset_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = zalo_capset_id_;
    zalo_capset_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ZaloGroup::set_allocated_zalo_capset_id(::std::string* zalo_capset_id) {
  if (zalo_capset_id_ != &::google::protobuf::internal::kEmptyString) {
    delete zalo_capset_id_;
  }
  if (zalo_capset_id) {
    set_has_zalo_capset_id();
    zalo_capset_id_ = zalo_capset_id;
  } else {
    clear_has_zalo_capset_id();
    zalo_capset_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string zalo_upper_limit = 3;
inline bool ZaloGroup::has_zalo_upper_limit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ZaloGroup::set_has_zalo_upper_limit() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ZaloGroup::clear_has_zalo_upper_limit() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ZaloGroup::clear_zalo_upper_limit() {
  if (zalo_upper_limit_ != &::google::protobuf::internal::kEmptyString) {
    zalo_upper_limit_->clear();
  }
  clear_has_zalo_upper_limit();
}
inline const ::std::string& ZaloGroup::zalo_upper_limit() const {
  return *zalo_upper_limit_;
}
inline void ZaloGroup::set_zalo_upper_limit(const ::std::string& value) {
  set_has_zalo_upper_limit();
  if (zalo_upper_limit_ == &::google::protobuf::internal::kEmptyString) {
    zalo_upper_limit_ = new ::std::string;
  }
  zalo_upper_limit_->assign(value);
}
inline void ZaloGroup::set_zalo_upper_limit(const char* value) {
  set_has_zalo_upper_limit();
  if (zalo_upper_limit_ == &::google::protobuf::internal::kEmptyString) {
    zalo_upper_limit_ = new ::std::string;
  }
  zalo_upper_limit_->assign(value);
}
inline void ZaloGroup::set_zalo_upper_limit(const char* value, size_t size) {
  set_has_zalo_upper_limit();
  if (zalo_upper_limit_ == &::google::protobuf::internal::kEmptyString) {
    zalo_upper_limit_ = new ::std::string;
  }
  zalo_upper_limit_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZaloGroup::mutable_zalo_upper_limit() {
  set_has_zalo_upper_limit();
  if (zalo_upper_limit_ == &::google::protobuf::internal::kEmptyString) {
    zalo_upper_limit_ = new ::std::string;
  }
  return zalo_upper_limit_;
}
inline ::std::string* ZaloGroup::release_zalo_upper_limit() {
  clear_has_zalo_upper_limit();
  if (zalo_upper_limit_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = zalo_upper_limit_;
    zalo_upper_limit_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ZaloGroup::set_allocated_zalo_upper_limit(::std::string* zalo_upper_limit) {
  if (zalo_upper_limit_ != &::google::protobuf::internal::kEmptyString) {
    delete zalo_upper_limit_;
  }
  if (zalo_upper_limit) {
    set_has_zalo_upper_limit();
    zalo_upper_limit_ = zalo_upper_limit;
  } else {
    clear_has_zalo_upper_limit();
    zalo_upper_limit_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// keyValuePair

// optional string key = 1;
inline bool keyValuePair::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void keyValuePair::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void keyValuePair::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void keyValuePair::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& keyValuePair::key() const {
  return *key_;
}
inline void keyValuePair::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void keyValuePair::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void keyValuePair::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* keyValuePair::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* keyValuePair::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void keyValuePair::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string value = 2;
inline bool keyValuePair::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void keyValuePair::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void keyValuePair::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void keyValuePair::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& keyValuePair::value() const {
  return *value_;
}
inline void keyValuePair::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void keyValuePair::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void keyValuePair::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* keyValuePair::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* keyValuePair::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void keyValuePair::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// commonAdjust

// optional string source = 1;
inline bool commonAdjust::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void commonAdjust::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void commonAdjust::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void commonAdjust::clear_source() {
  if (source_ != &::google::protobuf::internal::kEmptyString) {
    source_->clear();
  }
  clear_has_source();
}
inline const ::std::string& commonAdjust::source() const {
  return *source_;
}
inline void commonAdjust::set_source(const ::std::string& value) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    source_ = new ::std::string;
  }
  source_->assign(value);
}
inline void commonAdjust::set_source(const char* value) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    source_ = new ::std::string;
  }
  source_->assign(value);
}
inline void commonAdjust::set_source(const char* value, size_t size) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    source_ = new ::std::string;
  }
  source_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* commonAdjust::mutable_source() {
  set_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    source_ = new ::std::string;
  }
  return source_;
}
inline ::std::string* commonAdjust::release_source() {
  clear_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = source_;
    source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void commonAdjust::set_allocated_source(::std::string* source) {
  if (source_ != &::google::protobuf::internal::kEmptyString) {
    delete source_;
  }
  if (source) {
    set_has_source();
    source_ = source;
  } else {
    clear_has_source();
    source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string target = 2;
inline bool commonAdjust::has_target() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void commonAdjust::set_has_target() {
  _has_bits_[0] |= 0x00000002u;
}
inline void commonAdjust::clear_has_target() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void commonAdjust::clear_target() {
  if (target_ != &::google::protobuf::internal::kEmptyString) {
    target_->clear();
  }
  clear_has_target();
}
inline const ::std::string& commonAdjust::target() const {
  return *target_;
}
inline void commonAdjust::set_target(const ::std::string& value) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(value);
}
inline void commonAdjust::set_target(const char* value) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(value);
}
inline void commonAdjust::set_target(const char* value, size_t size) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* commonAdjust::mutable_target() {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  return target_;
}
inline ::std::string* commonAdjust::release_target() {
  clear_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = target_;
    target_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void commonAdjust::set_allocated_target(::std::string* target) {
  if (target_ != &::google::protobuf::internal::kEmptyString) {
    delete target_;
  }
  if (target) {
    set_has_target();
    target_ = target;
  } else {
    clear_has_target();
    target_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 amount = 3;
inline bool commonAdjust::has_amount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void commonAdjust::set_has_amount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void commonAdjust::clear_has_amount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void commonAdjust::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 commonAdjust::amount() const {
  return amount_;
}
inline void commonAdjust::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
}

// optional uint32 walletType = 4;
inline bool commonAdjust::has_wallettype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void commonAdjust::set_has_wallettype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void commonAdjust::clear_has_wallettype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void commonAdjust::clear_wallettype() {
  wallettype_ = 0u;
  clear_has_wallettype();
}
inline ::google::protobuf::uint32 commonAdjust::wallettype() const {
  return wallettype_;
}
inline void commonAdjust::set_wallettype(::google::protobuf::uint32 value) {
  set_has_wallettype();
  wallettype_ = value;
}

// optional string description = 5;
inline bool commonAdjust::has_description() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void commonAdjust::set_has_description() {
  _has_bits_[0] |= 0x00000010u;
}
inline void commonAdjust::clear_has_description() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void commonAdjust::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& commonAdjust::description() const {
  return *description_;
}
inline void commonAdjust::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void commonAdjust::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void commonAdjust::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* commonAdjust::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* commonAdjust::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void commonAdjust::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 time = 6;
inline bool commonAdjust::has_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void commonAdjust::set_has_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void commonAdjust::clear_has_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void commonAdjust::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::uint64 commonAdjust::time() const {
  return time_;
}
inline void commonAdjust::set_time(::google::protobuf::uint64 value) {
  set_has_time();
  time_ = value;
}

// optional string phoneNumber = 7;
inline bool commonAdjust::has_phonenumber() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void commonAdjust::set_has_phonenumber() {
  _has_bits_[0] |= 0x00000040u;
}
inline void commonAdjust::clear_has_phonenumber() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void commonAdjust::clear_phonenumber() {
  if (phonenumber_ != &::google::protobuf::internal::kEmptyString) {
    phonenumber_->clear();
  }
  clear_has_phonenumber();
}
inline const ::std::string& commonAdjust::phonenumber() const {
  return *phonenumber_;
}
inline void commonAdjust::set_phonenumber(const ::std::string& value) {
  set_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::kEmptyString) {
    phonenumber_ = new ::std::string;
  }
  phonenumber_->assign(value);
}
inline void commonAdjust::set_phonenumber(const char* value) {
  set_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::kEmptyString) {
    phonenumber_ = new ::std::string;
  }
  phonenumber_->assign(value);
}
inline void commonAdjust::set_phonenumber(const char* value, size_t size) {
  set_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::kEmptyString) {
    phonenumber_ = new ::std::string;
  }
  phonenumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* commonAdjust::mutable_phonenumber() {
  set_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::kEmptyString) {
    phonenumber_ = new ::std::string;
  }
  return phonenumber_;
}
inline ::std::string* commonAdjust::release_phonenumber() {
  clear_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phonenumber_;
    phonenumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void commonAdjust::set_allocated_phonenumber(::std::string* phonenumber) {
  if (phonenumber_ != &::google::protobuf::internal::kEmptyString) {
    delete phonenumber_;
  }
  if (phonenumber) {
    set_has_phonenumber();
    phonenumber_ = phonenumber;
  } else {
    clear_has_phonenumber();
    phonenumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .com.mservice.momo.msg.keyValuePair extra_map = 8;
inline int commonAdjust::extra_map_size() const {
  return extra_map_.size();
}
inline void commonAdjust::clear_extra_map() {
  extra_map_.Clear();
}
inline const ::com::mservice::momo::msg::keyValuePair& commonAdjust::extra_map(int index) const {
  return extra_map_.Get(index);
}
inline ::com::mservice::momo::msg::keyValuePair* commonAdjust::mutable_extra_map(int index) {
  return extra_map_.Mutable(index);
}
inline ::com::mservice::momo::msg::keyValuePair* commonAdjust::add_extra_map() {
  return extra_map_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >&
commonAdjust::extra_map() const {
  return extra_map_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >*
commonAdjust::mutable_extra_map() {
  return &extra_map_;
}

// -------------------------------------------------------------------

// BankNetConfirm

// optional string merchant_trans_id = 1;
inline bool BankNetConfirm::has_merchant_trans_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BankNetConfirm::set_has_merchant_trans_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BankNetConfirm::clear_has_merchant_trans_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BankNetConfirm::clear_merchant_trans_id() {
  if (merchant_trans_id_ != &::google::protobuf::internal::kEmptyString) {
    merchant_trans_id_->clear();
  }
  clear_has_merchant_trans_id();
}
inline const ::std::string& BankNetConfirm::merchant_trans_id() const {
  return *merchant_trans_id_;
}
inline void BankNetConfirm::set_merchant_trans_id(const ::std::string& value) {
  set_has_merchant_trans_id();
  if (merchant_trans_id_ == &::google::protobuf::internal::kEmptyString) {
    merchant_trans_id_ = new ::std::string;
  }
  merchant_trans_id_->assign(value);
}
inline void BankNetConfirm::set_merchant_trans_id(const char* value) {
  set_has_merchant_trans_id();
  if (merchant_trans_id_ == &::google::protobuf::internal::kEmptyString) {
    merchant_trans_id_ = new ::std::string;
  }
  merchant_trans_id_->assign(value);
}
inline void BankNetConfirm::set_merchant_trans_id(const char* value, size_t size) {
  set_has_merchant_trans_id();
  if (merchant_trans_id_ == &::google::protobuf::internal::kEmptyString) {
    merchant_trans_id_ = new ::std::string;
  }
  merchant_trans_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BankNetConfirm::mutable_merchant_trans_id() {
  set_has_merchant_trans_id();
  if (merchant_trans_id_ == &::google::protobuf::internal::kEmptyString) {
    merchant_trans_id_ = new ::std::string;
  }
  return merchant_trans_id_;
}
inline ::std::string* BankNetConfirm::release_merchant_trans_id() {
  clear_has_merchant_trans_id();
  if (merchant_trans_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = merchant_trans_id_;
    merchant_trans_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BankNetConfirm::set_allocated_merchant_trans_id(::std::string* merchant_trans_id) {
  if (merchant_trans_id_ != &::google::protobuf::internal::kEmptyString) {
    delete merchant_trans_id_;
  }
  if (merchant_trans_id) {
    set_has_merchant_trans_id();
    merchant_trans_id_ = merchant_trans_id;
  } else {
    clear_has_merchant_trans_id();
    merchant_trans_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string trans_id = 2;
inline bool BankNetConfirm::has_trans_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BankNetConfirm::set_has_trans_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BankNetConfirm::clear_has_trans_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BankNetConfirm::clear_trans_id() {
  if (trans_id_ != &::google::protobuf::internal::kEmptyString) {
    trans_id_->clear();
  }
  clear_has_trans_id();
}
inline const ::std::string& BankNetConfirm::trans_id() const {
  return *trans_id_;
}
inline void BankNetConfirm::set_trans_id(const ::std::string& value) {
  set_has_trans_id();
  if (trans_id_ == &::google::protobuf::internal::kEmptyString) {
    trans_id_ = new ::std::string;
  }
  trans_id_->assign(value);
}
inline void BankNetConfirm::set_trans_id(const char* value) {
  set_has_trans_id();
  if (trans_id_ == &::google::protobuf::internal::kEmptyString) {
    trans_id_ = new ::std::string;
  }
  trans_id_->assign(value);
}
inline void BankNetConfirm::set_trans_id(const char* value, size_t size) {
  set_has_trans_id();
  if (trans_id_ == &::google::protobuf::internal::kEmptyString) {
    trans_id_ = new ::std::string;
  }
  trans_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BankNetConfirm::mutable_trans_id() {
  set_has_trans_id();
  if (trans_id_ == &::google::protobuf::internal::kEmptyString) {
    trans_id_ = new ::std::string;
  }
  return trans_id_;
}
inline ::std::string* BankNetConfirm::release_trans_id() {
  clear_has_trans_id();
  if (trans_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = trans_id_;
    trans_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BankNetConfirm::set_allocated_trans_id(::std::string* trans_id) {
  if (trans_id_ != &::google::protobuf::internal::kEmptyString) {
    delete trans_id_;
  }
  if (trans_id) {
    set_has_trans_id();
    trans_id_ = trans_id;
  } else {
    clear_has_trans_id();
    trans_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 adjustResult = 3;
inline bool BankNetConfirm::has_adjustresult() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BankNetConfirm::set_has_adjustresult() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BankNetConfirm::clear_has_adjustresult() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BankNetConfirm::clear_adjustresult() {
  adjustresult_ = 0u;
  clear_has_adjustresult();
}
inline ::google::protobuf::uint32 BankNetConfirm::adjustresult() const {
  return adjustresult_;
}
inline void BankNetConfirm::set_adjustresult(::google::protobuf::uint32 value) {
  set_has_adjustresult();
  adjustresult_ = value;
}

// repeated .com.mservice.momo.msg.keyValuePair extra_map = 4;
inline int BankNetConfirm::extra_map_size() const {
  return extra_map_.size();
}
inline void BankNetConfirm::clear_extra_map() {
  extra_map_.Clear();
}
inline const ::com::mservice::momo::msg::keyValuePair& BankNetConfirm::extra_map(int index) const {
  return extra_map_.Get(index);
}
inline ::com::mservice::momo::msg::keyValuePair* BankNetConfirm::mutable_extra_map(int index) {
  return extra_map_.Mutable(index);
}
inline ::com::mservice::momo::msg::keyValuePair* BankNetConfirm::add_extra_map() {
  return extra_map_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >&
BankNetConfirm::extra_map() const {
  return extra_map_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >*
BankNetConfirm::mutable_extra_map() {
  return &extra_map_;
}

// -------------------------------------------------------------------

// RegisterInactiveAgent

// optional string phone = 1;
inline bool RegisterInactiveAgent::has_phone() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterInactiveAgent::set_has_phone() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterInactiveAgent::clear_has_phone() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterInactiveAgent::clear_phone() {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    phone_->clear();
  }
  clear_has_phone();
}
inline const ::std::string& RegisterInactiveAgent::phone() const {
  return *phone_;
}
inline void RegisterInactiveAgent::set_phone(const ::std::string& value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void RegisterInactiveAgent::set_phone(const char* value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void RegisterInactiveAgent::set_phone(const char* value, size_t size) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterInactiveAgent::mutable_phone() {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  return phone_;
}
inline ::std::string* RegisterInactiveAgent::release_phone() {
  clear_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phone_;
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegisterInactiveAgent::set_allocated_phone(::std::string* phone) {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    delete phone_;
  }
  if (phone) {
    set_has_phone();
    phone_ = phone;
  } else {
    clear_has_phone();
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 2;
inline bool RegisterInactiveAgent::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegisterInactiveAgent::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegisterInactiveAgent::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegisterInactiveAgent::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& RegisterInactiveAgent::name() const {
  return *name_;
}
inline void RegisterInactiveAgent::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RegisterInactiveAgent::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RegisterInactiveAgent::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterInactiveAgent::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* RegisterInactiveAgent::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegisterInactiveAgent::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string birthday = 3;
inline bool RegisterInactiveAgent::has_birthday() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegisterInactiveAgent::set_has_birthday() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegisterInactiveAgent::clear_has_birthday() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegisterInactiveAgent::clear_birthday() {
  if (birthday_ != &::google::protobuf::internal::kEmptyString) {
    birthday_->clear();
  }
  clear_has_birthday();
}
inline const ::std::string& RegisterInactiveAgent::birthday() const {
  return *birthday_;
}
inline void RegisterInactiveAgent::set_birthday(const ::std::string& value) {
  set_has_birthday();
  if (birthday_ == &::google::protobuf::internal::kEmptyString) {
    birthday_ = new ::std::string;
  }
  birthday_->assign(value);
}
inline void RegisterInactiveAgent::set_birthday(const char* value) {
  set_has_birthday();
  if (birthday_ == &::google::protobuf::internal::kEmptyString) {
    birthday_ = new ::std::string;
  }
  birthday_->assign(value);
}
inline void RegisterInactiveAgent::set_birthday(const char* value, size_t size) {
  set_has_birthday();
  if (birthday_ == &::google::protobuf::internal::kEmptyString) {
    birthday_ = new ::std::string;
  }
  birthday_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterInactiveAgent::mutable_birthday() {
  set_has_birthday();
  if (birthday_ == &::google::protobuf::internal::kEmptyString) {
    birthday_ = new ::std::string;
  }
  return birthday_;
}
inline ::std::string* RegisterInactiveAgent::release_birthday() {
  clear_has_birthday();
  if (birthday_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = birthday_;
    birthday_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegisterInactiveAgent::set_allocated_birthday(::std::string* birthday) {
  if (birthday_ != &::google::protobuf::internal::kEmptyString) {
    delete birthday_;
  }
  if (birthday) {
    set_has_birthday();
    birthday_ = birthday;
  } else {
    clear_has_birthday();
    birthday_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string address = 4;
inline bool RegisterInactiveAgent::has_address() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RegisterInactiveAgent::set_has_address() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RegisterInactiveAgent::clear_has_address() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RegisterInactiveAgent::clear_address() {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& RegisterInactiveAgent::address() const {
  return *address_;
}
inline void RegisterInactiveAgent::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void RegisterInactiveAgent::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void RegisterInactiveAgent::set_address(const char* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterInactiveAgent::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  return address_;
}
inline ::std::string* RegisterInactiveAgent::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegisterInactiveAgent::set_allocated_address(::std::string* address) {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    delete address_;
  }
  if (address) {
    set_has_address();
    address_ = address;
  } else {
    clear_has_address();
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string persionalId = 5;
inline bool RegisterInactiveAgent::has_persionalid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RegisterInactiveAgent::set_has_persionalid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RegisterInactiveAgent::clear_has_persionalid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RegisterInactiveAgent::clear_persionalid() {
  if (persionalid_ != &::google::protobuf::internal::kEmptyString) {
    persionalid_->clear();
  }
  clear_has_persionalid();
}
inline const ::std::string& RegisterInactiveAgent::persionalid() const {
  return *persionalid_;
}
inline void RegisterInactiveAgent::set_persionalid(const ::std::string& value) {
  set_has_persionalid();
  if (persionalid_ == &::google::protobuf::internal::kEmptyString) {
    persionalid_ = new ::std::string;
  }
  persionalid_->assign(value);
}
inline void RegisterInactiveAgent::set_persionalid(const char* value) {
  set_has_persionalid();
  if (persionalid_ == &::google::protobuf::internal::kEmptyString) {
    persionalid_ = new ::std::string;
  }
  persionalid_->assign(value);
}
inline void RegisterInactiveAgent::set_persionalid(const char* value, size_t size) {
  set_has_persionalid();
  if (persionalid_ == &::google::protobuf::internal::kEmptyString) {
    persionalid_ = new ::std::string;
  }
  persionalid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterInactiveAgent::mutable_persionalid() {
  set_has_persionalid();
  if (persionalid_ == &::google::protobuf::internal::kEmptyString) {
    persionalid_ = new ::std::string;
  }
  return persionalid_;
}
inline ::std::string* RegisterInactiveAgent::release_persionalid() {
  clear_has_persionalid();
  if (persionalid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = persionalid_;
    persionalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegisterInactiveAgent::set_allocated_persionalid(::std::string* persionalid) {
  if (persionalid_ != &::google::protobuf::internal::kEmptyString) {
    delete persionalid_;
  }
  if (persionalid) {
    set_has_persionalid();
    persionalid_ = persionalid;
  } else {
    clear_has_persionalid();
    persionalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string contact = 6;
inline bool RegisterInactiveAgent::has_contact() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RegisterInactiveAgent::set_has_contact() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RegisterInactiveAgent::clear_has_contact() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RegisterInactiveAgent::clear_contact() {
  if (contact_ != &::google::protobuf::internal::kEmptyString) {
    contact_->clear();
  }
  clear_has_contact();
}
inline const ::std::string& RegisterInactiveAgent::contact() const {
  return *contact_;
}
inline void RegisterInactiveAgent::set_contact(const ::std::string& value) {
  set_has_contact();
  if (contact_ == &::google::protobuf::internal::kEmptyString) {
    contact_ = new ::std::string;
  }
  contact_->assign(value);
}
inline void RegisterInactiveAgent::set_contact(const char* value) {
  set_has_contact();
  if (contact_ == &::google::protobuf::internal::kEmptyString) {
    contact_ = new ::std::string;
  }
  contact_->assign(value);
}
inline void RegisterInactiveAgent::set_contact(const char* value, size_t size) {
  set_has_contact();
  if (contact_ == &::google::protobuf::internal::kEmptyString) {
    contact_ = new ::std::string;
  }
  contact_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterInactiveAgent::mutable_contact() {
  set_has_contact();
  if (contact_ == &::google::protobuf::internal::kEmptyString) {
    contact_ = new ::std::string;
  }
  return contact_;
}
inline ::std::string* RegisterInactiveAgent::release_contact() {
  clear_has_contact();
  if (contact_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = contact_;
    contact_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegisterInactiveAgent::set_allocated_contact(::std::string* contact) {
  if (contact_ != &::google::protobuf::internal::kEmptyString) {
    delete contact_;
  }
  if (contact) {
    set_has_contact();
    contact_ = contact;
  } else {
    clear_has_contact();
    contact_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string email = 7;
inline bool RegisterInactiveAgent::has_email() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RegisterInactiveAgent::set_has_email() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RegisterInactiveAgent::clear_has_email() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RegisterInactiveAgent::clear_email() {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& RegisterInactiveAgent::email() const {
  return *email_;
}
inline void RegisterInactiveAgent::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void RegisterInactiveAgent::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void RegisterInactiveAgent::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterInactiveAgent::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  return email_;
}
inline ::std::string* RegisterInactiveAgent::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegisterInactiveAgent::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string channel = 8;
inline bool RegisterInactiveAgent::has_channel() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RegisterInactiveAgent::set_has_channel() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RegisterInactiveAgent::clear_has_channel() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RegisterInactiveAgent::clear_channel() {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    channel_->clear();
  }
  clear_has_channel();
}
inline const ::std::string& RegisterInactiveAgent::channel() const {
  return *channel_;
}
inline void RegisterInactiveAgent::set_channel(const ::std::string& value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void RegisterInactiveAgent::set_channel(const char* value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void RegisterInactiveAgent::set_channel(const char* value, size_t size) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterInactiveAgent::mutable_channel() {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  return channel_;
}
inline ::std::string* RegisterInactiveAgent::release_channel() {
  clear_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_;
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegisterInactiveAgent::set_allocated_channel(::std::string* channel) {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_;
  }
  if (channel) {
    set_has_channel();
    channel_ = channel;
  } else {
    clear_has_channel();
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string arr_capset = 9;
inline bool RegisterInactiveAgent::has_arr_capset() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RegisterInactiveAgent::set_has_arr_capset() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RegisterInactiveAgent::clear_has_arr_capset() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RegisterInactiveAgent::clear_arr_capset() {
  if (arr_capset_ != &::google::protobuf::internal::kEmptyString) {
    arr_capset_->clear();
  }
  clear_has_arr_capset();
}
inline const ::std::string& RegisterInactiveAgent::arr_capset() const {
  return *arr_capset_;
}
inline void RegisterInactiveAgent::set_arr_capset(const ::std::string& value) {
  set_has_arr_capset();
  if (arr_capset_ == &::google::protobuf::internal::kEmptyString) {
    arr_capset_ = new ::std::string;
  }
  arr_capset_->assign(value);
}
inline void RegisterInactiveAgent::set_arr_capset(const char* value) {
  set_has_arr_capset();
  if (arr_capset_ == &::google::protobuf::internal::kEmptyString) {
    arr_capset_ = new ::std::string;
  }
  arr_capset_->assign(value);
}
inline void RegisterInactiveAgent::set_arr_capset(const char* value, size_t size) {
  set_has_arr_capset();
  if (arr_capset_ == &::google::protobuf::internal::kEmptyString) {
    arr_capset_ = new ::std::string;
  }
  arr_capset_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterInactiveAgent::mutable_arr_capset() {
  set_has_arr_capset();
  if (arr_capset_ == &::google::protobuf::internal::kEmptyString) {
    arr_capset_ = new ::std::string;
  }
  return arr_capset_;
}
inline ::std::string* RegisterInactiveAgent::release_arr_capset() {
  clear_has_arr_capset();
  if (arr_capset_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = arr_capset_;
    arr_capset_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegisterInactiveAgent::set_allocated_arr_capset(::std::string* arr_capset) {
  if (arr_capset_ != &::google::protobuf::internal::kEmptyString) {
    delete arr_capset_;
  }
  if (arr_capset) {
    set_has_arr_capset();
    arr_capset_ = arr_capset;
  } else {
    clear_has_arr_capset();
    arr_capset_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string upper_limit = 10;
inline bool RegisterInactiveAgent::has_upper_limit() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RegisterInactiveAgent::set_has_upper_limit() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RegisterInactiveAgent::clear_has_upper_limit() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RegisterInactiveAgent::clear_upper_limit() {
  if (upper_limit_ != &::google::protobuf::internal::kEmptyString) {
    upper_limit_->clear();
  }
  clear_has_upper_limit();
}
inline const ::std::string& RegisterInactiveAgent::upper_limit() const {
  return *upper_limit_;
}
inline void RegisterInactiveAgent::set_upper_limit(const ::std::string& value) {
  set_has_upper_limit();
  if (upper_limit_ == &::google::protobuf::internal::kEmptyString) {
    upper_limit_ = new ::std::string;
  }
  upper_limit_->assign(value);
}
inline void RegisterInactiveAgent::set_upper_limit(const char* value) {
  set_has_upper_limit();
  if (upper_limit_ == &::google::protobuf::internal::kEmptyString) {
    upper_limit_ = new ::std::string;
  }
  upper_limit_->assign(value);
}
inline void RegisterInactiveAgent::set_upper_limit(const char* value, size_t size) {
  set_has_upper_limit();
  if (upper_limit_ == &::google::protobuf::internal::kEmptyString) {
    upper_limit_ = new ::std::string;
  }
  upper_limit_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterInactiveAgent::mutable_upper_limit() {
  set_has_upper_limit();
  if (upper_limit_ == &::google::protobuf::internal::kEmptyString) {
    upper_limit_ = new ::std::string;
  }
  return upper_limit_;
}
inline ::std::string* RegisterInactiveAgent::release_upper_limit() {
  clear_has_upper_limit();
  if (upper_limit_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = upper_limit_;
    upper_limit_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegisterInactiveAgent::set_allocated_upper_limit(::std::string* upper_limit) {
  if (upper_limit_ != &::google::protobuf::internal::kEmptyString) {
    delete upper_limit_;
  }
  if (upper_limit) {
    set_has_upper_limit();
    upper_limit_ = upper_limit;
  } else {
    clear_has_upper_limit();
    upper_limit_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// BuyOther

// optional string providerId = 1;
inline bool BuyOther::has_providerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuyOther::set_has_providerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuyOther::clear_has_providerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuyOther::clear_providerid() {
  if (providerid_ != &::google::protobuf::internal::kEmptyString) {
    providerid_->clear();
  }
  clear_has_providerid();
}
inline const ::std::string& BuyOther::providerid() const {
  return *providerid_;
}
inline void BuyOther::set_providerid(const ::std::string& value) {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  providerid_->assign(value);
}
inline void BuyOther::set_providerid(const char* value) {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  providerid_->assign(value);
}
inline void BuyOther::set_providerid(const char* value, size_t size) {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  providerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BuyOther::mutable_providerid() {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  return providerid_;
}
inline ::std::string* BuyOther::release_providerid() {
  clear_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = providerid_;
    providerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BuyOther::set_allocated_providerid(::std::string* providerid) {
  if (providerid_ != &::google::protobuf::internal::kEmptyString) {
    delete providerid_;
  }
  if (providerid) {
    set_has_providerid();
    providerid_ = providerid;
  } else {
    clear_has_providerid();
    providerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string amount = 2;
inline bool BuyOther::has_amount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BuyOther::set_has_amount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BuyOther::clear_has_amount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BuyOther::clear_amount() {
  if (amount_ != &::google::protobuf::internal::kEmptyString) {
    amount_->clear();
  }
  clear_has_amount();
}
inline const ::std::string& BuyOther::amount() const {
  return *amount_;
}
inline void BuyOther::set_amount(const ::std::string& value) {
  set_has_amount();
  if (amount_ == &::google::protobuf::internal::kEmptyString) {
    amount_ = new ::std::string;
  }
  amount_->assign(value);
}
inline void BuyOther::set_amount(const char* value) {
  set_has_amount();
  if (amount_ == &::google::protobuf::internal::kEmptyString) {
    amount_ = new ::std::string;
  }
  amount_->assign(value);
}
inline void BuyOther::set_amount(const char* value, size_t size) {
  set_has_amount();
  if (amount_ == &::google::protobuf::internal::kEmptyString) {
    amount_ = new ::std::string;
  }
  amount_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BuyOther::mutable_amount() {
  set_has_amount();
  if (amount_ == &::google::protobuf::internal::kEmptyString) {
    amount_ = new ::std::string;
  }
  return amount_;
}
inline ::std::string* BuyOther::release_amount() {
  clear_has_amount();
  if (amount_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = amount_;
    amount_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BuyOther::set_allocated_amount(::std::string* amount) {
  if (amount_ != &::google::protobuf::internal::kEmptyString) {
    delete amount_;
  }
  if (amount) {
    set_has_amount();
    amount_ = amount;
  } else {
    clear_has_amount();
    amount_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string pin = 3;
inline bool BuyOther::has_pin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BuyOther::set_has_pin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BuyOther::clear_has_pin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BuyOther::clear_pin() {
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    pin_->clear();
  }
  clear_has_pin();
}
inline const ::std::string& BuyOther::pin() const {
  return *pin_;
}
inline void BuyOther::set_pin(const ::std::string& value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void BuyOther::set_pin(const char* value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void BuyOther::set_pin(const char* value, size_t size) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BuyOther::mutable_pin() {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  return pin_;
}
inline ::std::string* BuyOther::release_pin() {
  clear_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pin_;
    pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BuyOther::set_allocated_pin(::std::string* pin) {
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    delete pin_;
  }
  if (pin) {
    set_has_pin();
    pin_ = pin;
  } else {
    clear_has_pin();
    pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// BuyGameCard

// optional string providerId = 1;
inline bool BuyGameCard::has_providerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuyGameCard::set_has_providerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuyGameCard::clear_has_providerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuyGameCard::clear_providerid() {
  if (providerid_ != &::google::protobuf::internal::kEmptyString) {
    providerid_->clear();
  }
  clear_has_providerid();
}
inline const ::std::string& BuyGameCard::providerid() const {
  return *providerid_;
}
inline void BuyGameCard::set_providerid(const ::std::string& value) {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  providerid_->assign(value);
}
inline void BuyGameCard::set_providerid(const char* value) {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  providerid_->assign(value);
}
inline void BuyGameCard::set_providerid(const char* value, size_t size) {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  providerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BuyGameCard::mutable_providerid() {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  return providerid_;
}
inline ::std::string* BuyGameCard::release_providerid() {
  clear_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = providerid_;
    providerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BuyGameCard::set_allocated_providerid(::std::string* providerid) {
  if (providerid_ != &::google::protobuf::internal::kEmptyString) {
    delete providerid_;
  }
  if (providerid) {
    set_has_providerid();
    providerid_ = providerid;
  } else {
    clear_has_providerid();
    providerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string amount = 2;
inline bool BuyGameCard::has_amount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BuyGameCard::set_has_amount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BuyGameCard::clear_has_amount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BuyGameCard::clear_amount() {
  if (amount_ != &::google::protobuf::internal::kEmptyString) {
    amount_->clear();
  }
  clear_has_amount();
}
inline const ::std::string& BuyGameCard::amount() const {
  return *amount_;
}
inline void BuyGameCard::set_amount(const ::std::string& value) {
  set_has_amount();
  if (amount_ == &::google::protobuf::internal::kEmptyString) {
    amount_ = new ::std::string;
  }
  amount_->assign(value);
}
inline void BuyGameCard::set_amount(const char* value) {
  set_has_amount();
  if (amount_ == &::google::protobuf::internal::kEmptyString) {
    amount_ = new ::std::string;
  }
  amount_->assign(value);
}
inline void BuyGameCard::set_amount(const char* value, size_t size) {
  set_has_amount();
  if (amount_ == &::google::protobuf::internal::kEmptyString) {
    amount_ = new ::std::string;
  }
  amount_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BuyGameCard::mutable_amount() {
  set_has_amount();
  if (amount_ == &::google::protobuf::internal::kEmptyString) {
    amount_ = new ::std::string;
  }
  return amount_;
}
inline ::std::string* BuyGameCard::release_amount() {
  clear_has_amount();
  if (amount_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = amount_;
    amount_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BuyGameCard::set_allocated_amount(::std::string* amount) {
  if (amount_ != &::google::protobuf::internal::kEmptyString) {
    delete amount_;
  }
  if (amount) {
    set_has_amount();
    amount_ = amount;
  } else {
    clear_has_amount();
    amount_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string pin = 3;
inline bool BuyGameCard::has_pin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BuyGameCard::set_has_pin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BuyGameCard::clear_has_pin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BuyGameCard::clear_pin() {
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    pin_->clear();
  }
  clear_has_pin();
}
inline const ::std::string& BuyGameCard::pin() const {
  return *pin_;
}
inline void BuyGameCard::set_pin(const ::std::string& value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void BuyGameCard::set_pin(const char* value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void BuyGameCard::set_pin(const char* value, size_t size) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BuyGameCard::mutable_pin() {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  return pin_;
}
inline ::std::string* BuyGameCard::release_pin() {
  clear_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pin_;
    pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BuyGameCard::set_allocated_pin(::std::string* pin) {
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    delete pin_;
  }
  if (pin) {
    set_has_pin();
    pin_ = pin;
  } else {
    clear_has_pin();
    pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// BuyMobilityCard

// optional string providerId = 1;
inline bool BuyMobilityCard::has_providerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuyMobilityCard::set_has_providerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuyMobilityCard::clear_has_providerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuyMobilityCard::clear_providerid() {
  if (providerid_ != &::google::protobuf::internal::kEmptyString) {
    providerid_->clear();
  }
  clear_has_providerid();
}
inline const ::std::string& BuyMobilityCard::providerid() const {
  return *providerid_;
}
inline void BuyMobilityCard::set_providerid(const ::std::string& value) {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  providerid_->assign(value);
}
inline void BuyMobilityCard::set_providerid(const char* value) {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  providerid_->assign(value);
}
inline void BuyMobilityCard::set_providerid(const char* value, size_t size) {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  providerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BuyMobilityCard::mutable_providerid() {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  return providerid_;
}
inline ::std::string* BuyMobilityCard::release_providerid() {
  clear_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = providerid_;
    providerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BuyMobilityCard::set_allocated_providerid(::std::string* providerid) {
  if (providerid_ != &::google::protobuf::internal::kEmptyString) {
    delete providerid_;
  }
  if (providerid) {
    set_has_providerid();
    providerid_ = providerid;
  } else {
    clear_has_providerid();
    providerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string amount = 2;
inline bool BuyMobilityCard::has_amount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BuyMobilityCard::set_has_amount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BuyMobilityCard::clear_has_amount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BuyMobilityCard::clear_amount() {
  if (amount_ != &::google::protobuf::internal::kEmptyString) {
    amount_->clear();
  }
  clear_has_amount();
}
inline const ::std::string& BuyMobilityCard::amount() const {
  return *amount_;
}
inline void BuyMobilityCard::set_amount(const ::std::string& value) {
  set_has_amount();
  if (amount_ == &::google::protobuf::internal::kEmptyString) {
    amount_ = new ::std::string;
  }
  amount_->assign(value);
}
inline void BuyMobilityCard::set_amount(const char* value) {
  set_has_amount();
  if (amount_ == &::google::protobuf::internal::kEmptyString) {
    amount_ = new ::std::string;
  }
  amount_->assign(value);
}
inline void BuyMobilityCard::set_amount(const char* value, size_t size) {
  set_has_amount();
  if (amount_ == &::google::protobuf::internal::kEmptyString) {
    amount_ = new ::std::string;
  }
  amount_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BuyMobilityCard::mutable_amount() {
  set_has_amount();
  if (amount_ == &::google::protobuf::internal::kEmptyString) {
    amount_ = new ::std::string;
  }
  return amount_;
}
inline ::std::string* BuyMobilityCard::release_amount() {
  clear_has_amount();
  if (amount_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = amount_;
    amount_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BuyMobilityCard::set_allocated_amount(::std::string* amount) {
  if (amount_ != &::google::protobuf::internal::kEmptyString) {
    delete amount_;
  }
  if (amount) {
    set_has_amount();
    amount_ = amount;
  } else {
    clear_has_amount();
    amount_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string pin = 3;
inline bool BuyMobilityCard::has_pin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BuyMobilityCard::set_has_pin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BuyMobilityCard::clear_has_pin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BuyMobilityCard::clear_pin() {
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    pin_->clear();
  }
  clear_has_pin();
}
inline const ::std::string& BuyMobilityCard::pin() const {
  return *pin_;
}
inline void BuyMobilityCard::set_pin(const ::std::string& value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void BuyMobilityCard::set_pin(const char* value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void BuyMobilityCard::set_pin(const char* value, size_t size) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BuyMobilityCard::mutable_pin() {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  return pin_;
}
inline ::std::string* BuyMobilityCard::release_pin() {
  clear_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pin_;
    pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BuyMobilityCard::set_allocated_pin(::std::string* pin) {
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    delete pin_;
  }
  if (pin) {
    set_has_pin();
    pin_ = pin;
  } else {
    clear_has_pin();
    pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AgentInfoModify

// optional string name = 1;
inline bool AgentInfoModify::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AgentInfoModify::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AgentInfoModify::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AgentInfoModify::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& AgentInfoModify::name() const {
  return *name_;
}
inline void AgentInfoModify::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AgentInfoModify::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AgentInfoModify::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentInfoModify::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* AgentInfoModify::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AgentInfoModify::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string card_id = 2;
inline bool AgentInfoModify::has_card_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AgentInfoModify::set_has_card_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AgentInfoModify::clear_has_card_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AgentInfoModify::clear_card_id() {
  if (card_id_ != &::google::protobuf::internal::kEmptyString) {
    card_id_->clear();
  }
  clear_has_card_id();
}
inline const ::std::string& AgentInfoModify::card_id() const {
  return *card_id_;
}
inline void AgentInfoModify::set_card_id(const ::std::string& value) {
  set_has_card_id();
  if (card_id_ == &::google::protobuf::internal::kEmptyString) {
    card_id_ = new ::std::string;
  }
  card_id_->assign(value);
}
inline void AgentInfoModify::set_card_id(const char* value) {
  set_has_card_id();
  if (card_id_ == &::google::protobuf::internal::kEmptyString) {
    card_id_ = new ::std::string;
  }
  card_id_->assign(value);
}
inline void AgentInfoModify::set_card_id(const char* value, size_t size) {
  set_has_card_id();
  if (card_id_ == &::google::protobuf::internal::kEmptyString) {
    card_id_ = new ::std::string;
  }
  card_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentInfoModify::mutable_card_id() {
  set_has_card_id();
  if (card_id_ == &::google::protobuf::internal::kEmptyString) {
    card_id_ = new ::std::string;
  }
  return card_id_;
}
inline ::std::string* AgentInfoModify::release_card_id() {
  clear_has_card_id();
  if (card_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = card_id_;
    card_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AgentInfoModify::set_allocated_card_id(::std::string* card_id) {
  if (card_id_ != &::google::protobuf::internal::kEmptyString) {
    delete card_id_;
  }
  if (card_id) {
    set_has_card_id();
    card_id_ = card_id;
  } else {
    clear_has_card_id();
    card_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string address = 3;
inline bool AgentInfoModify::has_address() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AgentInfoModify::set_has_address() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AgentInfoModify::clear_has_address() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AgentInfoModify::clear_address() {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& AgentInfoModify::address() const {
  return *address_;
}
inline void AgentInfoModify::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void AgentInfoModify::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void AgentInfoModify::set_address(const char* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentInfoModify::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  return address_;
}
inline ::std::string* AgentInfoModify::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AgentInfoModify::set_allocated_address(::std::string* address) {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    delete address_;
  }
  if (address) {
    set_has_address();
    address_ = address;
  } else {
    clear_has_address();
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string email = 4;
inline bool AgentInfoModify::has_email() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AgentInfoModify::set_has_email() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AgentInfoModify::clear_has_email() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AgentInfoModify::clear_email() {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& AgentInfoModify::email() const {
  return *email_;
}
inline void AgentInfoModify::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void AgentInfoModify::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void AgentInfoModify::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentInfoModify::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  return email_;
}
inline ::std::string* AgentInfoModify::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AgentInfoModify::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string dob = 5;
inline bool AgentInfoModify::has_dob() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AgentInfoModify::set_has_dob() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AgentInfoModify::clear_has_dob() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AgentInfoModify::clear_dob() {
  if (dob_ != &::google::protobuf::internal::kEmptyString) {
    dob_->clear();
  }
  clear_has_dob();
}
inline const ::std::string& AgentInfoModify::dob() const {
  return *dob_;
}
inline void AgentInfoModify::set_dob(const ::std::string& value) {
  set_has_dob();
  if (dob_ == &::google::protobuf::internal::kEmptyString) {
    dob_ = new ::std::string;
  }
  dob_->assign(value);
}
inline void AgentInfoModify::set_dob(const char* value) {
  set_has_dob();
  if (dob_ == &::google::protobuf::internal::kEmptyString) {
    dob_ = new ::std::string;
  }
  dob_->assign(value);
}
inline void AgentInfoModify::set_dob(const char* value, size_t size) {
  set_has_dob();
  if (dob_ == &::google::protobuf::internal::kEmptyString) {
    dob_ = new ::std::string;
  }
  dob_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentInfoModify::mutable_dob() {
  set_has_dob();
  if (dob_ == &::google::protobuf::internal::kEmptyString) {
    dob_ = new ::std::string;
  }
  return dob_;
}
inline ::std::string* AgentInfoModify::release_dob() {
  clear_has_dob();
  if (dob_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dob_;
    dob_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AgentInfoModify::set_allocated_dob(::std::string* dob) {
  if (dob_ != &::google::protobuf::internal::kEmptyString) {
    delete dob_;
  }
  if (dob) {
    set_has_dob();
    dob_ = dob;
  } else {
    clear_has_dob();
    dob_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .com.mservice.momo.msg.keyValuePair kvps = 6;
inline int AgentInfoModify::kvps_size() const {
  return kvps_.size();
}
inline void AgentInfoModify::clear_kvps() {
  kvps_.Clear();
}
inline const ::com::mservice::momo::msg::keyValuePair& AgentInfoModify::kvps(int index) const {
  return kvps_.Get(index);
}
inline ::com::mservice::momo::msg::keyValuePair* AgentInfoModify::mutable_kvps(int index) {
  return kvps_.Mutable(index);
}
inline ::com::mservice::momo::msg::keyValuePair* AgentInfoModify::add_kvps() {
  return kvps_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >&
AgentInfoModify::kvps() const {
  return kvps_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >*
AgentInfoModify::mutable_kvps() {
  return &kvps_;
}

// -------------------------------------------------------------------

// DepositCashOther

// optional string providerId = 1;
inline bool DepositCashOther::has_providerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DepositCashOther::set_has_providerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DepositCashOther::clear_has_providerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DepositCashOther::clear_providerid() {
  if (providerid_ != &::google::protobuf::internal::kEmptyString) {
    providerid_->clear();
  }
  clear_has_providerid();
}
inline const ::std::string& DepositCashOther::providerid() const {
  return *providerid_;
}
inline void DepositCashOther::set_providerid(const ::std::string& value) {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  providerid_->assign(value);
}
inline void DepositCashOther::set_providerid(const char* value) {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  providerid_->assign(value);
}
inline void DepositCashOther::set_providerid(const char* value, size_t size) {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  providerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DepositCashOther::mutable_providerid() {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  return providerid_;
}
inline ::std::string* DepositCashOther::release_providerid() {
  clear_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = providerid_;
    providerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DepositCashOther::set_allocated_providerid(::std::string* providerid) {
  if (providerid_ != &::google::protobuf::internal::kEmptyString) {
    delete providerid_;
  }
  if (providerid) {
    set_has_providerid();
    providerid_ = providerid;
  } else {
    clear_has_providerid();
    providerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string customerAcc = 2;
inline bool DepositCashOther::has_customeracc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DepositCashOther::set_has_customeracc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DepositCashOther::clear_has_customeracc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DepositCashOther::clear_customeracc() {
  if (customeracc_ != &::google::protobuf::internal::kEmptyString) {
    customeracc_->clear();
  }
  clear_has_customeracc();
}
inline const ::std::string& DepositCashOther::customeracc() const {
  return *customeracc_;
}
inline void DepositCashOther::set_customeracc(const ::std::string& value) {
  set_has_customeracc();
  if (customeracc_ == &::google::protobuf::internal::kEmptyString) {
    customeracc_ = new ::std::string;
  }
  customeracc_->assign(value);
}
inline void DepositCashOther::set_customeracc(const char* value) {
  set_has_customeracc();
  if (customeracc_ == &::google::protobuf::internal::kEmptyString) {
    customeracc_ = new ::std::string;
  }
  customeracc_->assign(value);
}
inline void DepositCashOther::set_customeracc(const char* value, size_t size) {
  set_has_customeracc();
  if (customeracc_ == &::google::protobuf::internal::kEmptyString) {
    customeracc_ = new ::std::string;
  }
  customeracc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DepositCashOther::mutable_customeracc() {
  set_has_customeracc();
  if (customeracc_ == &::google::protobuf::internal::kEmptyString) {
    customeracc_ = new ::std::string;
  }
  return customeracc_;
}
inline ::std::string* DepositCashOther::release_customeracc() {
  clear_has_customeracc();
  if (customeracc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customeracc_;
    customeracc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DepositCashOther::set_allocated_customeracc(::std::string* customeracc) {
  if (customeracc_ != &::google::protobuf::internal::kEmptyString) {
    delete customeracc_;
  }
  if (customeracc) {
    set_has_customeracc();
    customeracc_ = customeracc;
  } else {
    clear_has_customeracc();
    customeracc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string pin = 3;
inline bool DepositCashOther::has_pin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DepositCashOther::set_has_pin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DepositCashOther::clear_has_pin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DepositCashOther::clear_pin() {
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    pin_->clear();
  }
  clear_has_pin();
}
inline const ::std::string& DepositCashOther::pin() const {
  return *pin_;
}
inline void DepositCashOther::set_pin(const ::std::string& value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void DepositCashOther::set_pin(const char* value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void DepositCashOther::set_pin(const char* value, size_t size) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DepositCashOther::mutable_pin() {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  return pin_;
}
inline ::std::string* DepositCashOther::release_pin() {
  clear_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pin_;
    pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DepositCashOther::set_allocated_pin(::std::string* pin) {
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    delete pin_;
  }
  if (pin) {
    set_has_pin();
    pin_ = pin;
  } else {
    clear_has_pin();
    pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 amount = 4;
inline bool DepositCashOther::has_amount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DepositCashOther::set_has_amount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DepositCashOther::clear_has_amount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DepositCashOther::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 DepositCashOther::amount() const {
  return amount_;
}
inline void DepositCashOther::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
}

// optional string channel = 5;
inline bool DepositCashOther::has_channel() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DepositCashOther::set_has_channel() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DepositCashOther::clear_has_channel() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DepositCashOther::clear_channel() {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    channel_->clear();
  }
  clear_has_channel();
}
inline const ::std::string& DepositCashOther::channel() const {
  return *channel_;
}
inline void DepositCashOther::set_channel(const ::std::string& value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void DepositCashOther::set_channel(const char* value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void DepositCashOther::set_channel(const char* value, size_t size) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DepositCashOther::mutable_channel() {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  return channel_;
}
inline ::std::string* DepositCashOther::release_channel() {
  clear_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_;
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DepositCashOther::set_allocated_channel(::std::string* channel) {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_;
  }
  if (channel) {
    set_has_channel();
    channel_ = channel;
  } else {
    clear_has_channel();
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// BillPayTelephone

// optional string providerId = 1;
inline bool BillPayTelephone::has_providerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BillPayTelephone::set_has_providerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BillPayTelephone::clear_has_providerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BillPayTelephone::clear_providerid() {
  if (providerid_ != &::google::protobuf::internal::kEmptyString) {
    providerid_->clear();
  }
  clear_has_providerid();
}
inline const ::std::string& BillPayTelephone::providerid() const {
  return *providerid_;
}
inline void BillPayTelephone::set_providerid(const ::std::string& value) {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  providerid_->assign(value);
}
inline void BillPayTelephone::set_providerid(const char* value) {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  providerid_->assign(value);
}
inline void BillPayTelephone::set_providerid(const char* value, size_t size) {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  providerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BillPayTelephone::mutable_providerid() {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  return providerid_;
}
inline ::std::string* BillPayTelephone::release_providerid() {
  clear_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = providerid_;
    providerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BillPayTelephone::set_allocated_providerid(::std::string* providerid) {
  if (providerid_ != &::google::protobuf::internal::kEmptyString) {
    delete providerid_;
  }
  if (providerid) {
    set_has_providerid();
    providerid_ = providerid;
  } else {
    clear_has_providerid();
    providerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string phone = 2;
inline bool BillPayTelephone::has_phone() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BillPayTelephone::set_has_phone() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BillPayTelephone::clear_has_phone() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BillPayTelephone::clear_phone() {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    phone_->clear();
  }
  clear_has_phone();
}
inline const ::std::string& BillPayTelephone::phone() const {
  return *phone_;
}
inline void BillPayTelephone::set_phone(const ::std::string& value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void BillPayTelephone::set_phone(const char* value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void BillPayTelephone::set_phone(const char* value, size_t size) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BillPayTelephone::mutable_phone() {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  return phone_;
}
inline ::std::string* BillPayTelephone::release_phone() {
  clear_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phone_;
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BillPayTelephone::set_allocated_phone(::std::string* phone) {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    delete phone_;
  }
  if (phone) {
    set_has_phone();
    phone_ = phone;
  } else {
    clear_has_phone();
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string areaId = 3;
inline bool BillPayTelephone::has_areaid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BillPayTelephone::set_has_areaid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BillPayTelephone::clear_has_areaid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BillPayTelephone::clear_areaid() {
  if (areaid_ != &::google::protobuf::internal::kEmptyString) {
    areaid_->clear();
  }
  clear_has_areaid();
}
inline const ::std::string& BillPayTelephone::areaid() const {
  return *areaid_;
}
inline void BillPayTelephone::set_areaid(const ::std::string& value) {
  set_has_areaid();
  if (areaid_ == &::google::protobuf::internal::kEmptyString) {
    areaid_ = new ::std::string;
  }
  areaid_->assign(value);
}
inline void BillPayTelephone::set_areaid(const char* value) {
  set_has_areaid();
  if (areaid_ == &::google::protobuf::internal::kEmptyString) {
    areaid_ = new ::std::string;
  }
  areaid_->assign(value);
}
inline void BillPayTelephone::set_areaid(const char* value, size_t size) {
  set_has_areaid();
  if (areaid_ == &::google::protobuf::internal::kEmptyString) {
    areaid_ = new ::std::string;
  }
  areaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BillPayTelephone::mutable_areaid() {
  set_has_areaid();
  if (areaid_ == &::google::protobuf::internal::kEmptyString) {
    areaid_ = new ::std::string;
  }
  return areaid_;
}
inline ::std::string* BillPayTelephone::release_areaid() {
  clear_has_areaid();
  if (areaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = areaid_;
    areaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BillPayTelephone::set_allocated_areaid(::std::string* areaid) {
  if (areaid_ != &::google::protobuf::internal::kEmptyString) {
    delete areaid_;
  }
  if (areaid) {
    set_has_areaid();
    areaid_ = areaid;
  } else {
    clear_has_areaid();
    areaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string pin = 4;
inline bool BillPayTelephone::has_pin() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BillPayTelephone::set_has_pin() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BillPayTelephone::clear_has_pin() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BillPayTelephone::clear_pin() {
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    pin_->clear();
  }
  clear_has_pin();
}
inline const ::std::string& BillPayTelephone::pin() const {
  return *pin_;
}
inline void BillPayTelephone::set_pin(const ::std::string& value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void BillPayTelephone::set_pin(const char* value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void BillPayTelephone::set_pin(const char* value, size_t size) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BillPayTelephone::mutable_pin() {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  return pin_;
}
inline ::std::string* BillPayTelephone::release_pin() {
  clear_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pin_;
    pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BillPayTelephone::set_allocated_pin(::std::string* pin) {
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    delete pin_;
  }
  if (pin) {
    set_has_pin();
    pin_ = pin;
  } else {
    clear_has_pin();
    pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 amount = 5;
inline bool BillPayTelephone::has_amount() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BillPayTelephone::set_has_amount() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BillPayTelephone::clear_has_amount() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BillPayTelephone::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 BillPayTelephone::amount() const {
  return amount_;
}
inline void BillPayTelephone::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
}

// optional string channel = 6;
inline bool BillPayTelephone::has_channel() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BillPayTelephone::set_has_channel() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BillPayTelephone::clear_has_channel() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BillPayTelephone::clear_channel() {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    channel_->clear();
  }
  clear_has_channel();
}
inline const ::std::string& BillPayTelephone::channel() const {
  return *channel_;
}
inline void BillPayTelephone::set_channel(const ::std::string& value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void BillPayTelephone::set_channel(const char* value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void BillPayTelephone::set_channel(const char* value, size_t size) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BillPayTelephone::mutable_channel() {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  return channel_;
}
inline ::std::string* BillPayTelephone::release_channel() {
  clear_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_;
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BillPayTelephone::set_allocated_channel(::std::string* channel) {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_;
  }
  if (channel) {
    set_has_channel();
    channel_ = channel;
  } else {
    clear_has_channel();
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// BillPayTicketAirline

// optional string providerId = 1;
inline bool BillPayTicketAirline::has_providerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BillPayTicketAirline::set_has_providerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BillPayTicketAirline::clear_has_providerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BillPayTicketAirline::clear_providerid() {
  if (providerid_ != &::google::protobuf::internal::kEmptyString) {
    providerid_->clear();
  }
  clear_has_providerid();
}
inline const ::std::string& BillPayTicketAirline::providerid() const {
  return *providerid_;
}
inline void BillPayTicketAirline::set_providerid(const ::std::string& value) {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  providerid_->assign(value);
}
inline void BillPayTicketAirline::set_providerid(const char* value) {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  providerid_->assign(value);
}
inline void BillPayTicketAirline::set_providerid(const char* value, size_t size) {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  providerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BillPayTicketAirline::mutable_providerid() {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  return providerid_;
}
inline ::std::string* BillPayTicketAirline::release_providerid() {
  clear_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = providerid_;
    providerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BillPayTicketAirline::set_allocated_providerid(::std::string* providerid) {
  if (providerid_ != &::google::protobuf::internal::kEmptyString) {
    delete providerid_;
  }
  if (providerid) {
    set_has_providerid();
    providerid_ = providerid;
  } else {
    clear_has_providerid();
    providerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ticketId = 2;
inline bool BillPayTicketAirline::has_ticketid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BillPayTicketAirline::set_has_ticketid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BillPayTicketAirline::clear_has_ticketid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BillPayTicketAirline::clear_ticketid() {
  if (ticketid_ != &::google::protobuf::internal::kEmptyString) {
    ticketid_->clear();
  }
  clear_has_ticketid();
}
inline const ::std::string& BillPayTicketAirline::ticketid() const {
  return *ticketid_;
}
inline void BillPayTicketAirline::set_ticketid(const ::std::string& value) {
  set_has_ticketid();
  if (ticketid_ == &::google::protobuf::internal::kEmptyString) {
    ticketid_ = new ::std::string;
  }
  ticketid_->assign(value);
}
inline void BillPayTicketAirline::set_ticketid(const char* value) {
  set_has_ticketid();
  if (ticketid_ == &::google::protobuf::internal::kEmptyString) {
    ticketid_ = new ::std::string;
  }
  ticketid_->assign(value);
}
inline void BillPayTicketAirline::set_ticketid(const char* value, size_t size) {
  set_has_ticketid();
  if (ticketid_ == &::google::protobuf::internal::kEmptyString) {
    ticketid_ = new ::std::string;
  }
  ticketid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BillPayTicketAirline::mutable_ticketid() {
  set_has_ticketid();
  if (ticketid_ == &::google::protobuf::internal::kEmptyString) {
    ticketid_ = new ::std::string;
  }
  return ticketid_;
}
inline ::std::string* BillPayTicketAirline::release_ticketid() {
  clear_has_ticketid();
  if (ticketid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ticketid_;
    ticketid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BillPayTicketAirline::set_allocated_ticketid(::std::string* ticketid) {
  if (ticketid_ != &::google::protobuf::internal::kEmptyString) {
    delete ticketid_;
  }
  if (ticketid) {
    set_has_ticketid();
    ticketid_ = ticketid;
  } else {
    clear_has_ticketid();
    ticketid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string pin = 3;
inline bool BillPayTicketAirline::has_pin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BillPayTicketAirline::set_has_pin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BillPayTicketAirline::clear_has_pin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BillPayTicketAirline::clear_pin() {
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    pin_->clear();
  }
  clear_has_pin();
}
inline const ::std::string& BillPayTicketAirline::pin() const {
  return *pin_;
}
inline void BillPayTicketAirline::set_pin(const ::std::string& value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void BillPayTicketAirline::set_pin(const char* value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void BillPayTicketAirline::set_pin(const char* value, size_t size) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BillPayTicketAirline::mutable_pin() {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  return pin_;
}
inline ::std::string* BillPayTicketAirline::release_pin() {
  clear_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pin_;
    pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BillPayTicketAirline::set_allocated_pin(::std::string* pin) {
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    delete pin_;
  }
  if (pin) {
    set_has_pin();
    pin_ = pin;
  } else {
    clear_has_pin();
    pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 amount = 4;
inline bool BillPayTicketAirline::has_amount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BillPayTicketAirline::set_has_amount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BillPayTicketAirline::clear_has_amount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BillPayTicketAirline::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 BillPayTicketAirline::amount() const {
  return amount_;
}
inline void BillPayTicketAirline::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
}

// optional string channel = 5;
inline bool BillPayTicketAirline::has_channel() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BillPayTicketAirline::set_has_channel() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BillPayTicketAirline::clear_has_channel() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BillPayTicketAirline::clear_channel() {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    channel_->clear();
  }
  clear_has_channel();
}
inline const ::std::string& BillPayTicketAirline::channel() const {
  return *channel_;
}
inline void BillPayTicketAirline::set_channel(const ::std::string& value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void BillPayTicketAirline::set_channel(const char* value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void BillPayTicketAirline::set_channel(const char* value, size_t size) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BillPayTicketAirline::mutable_channel() {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  return channel_;
}
inline ::std::string* BillPayTicketAirline::release_channel() {
  clear_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_;
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BillPayTicketAirline::set_allocated_channel(::std::string* channel) {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_;
  }
  if (channel) {
    set_has_channel();
    channel_ = channel;
  } else {
    clear_has_channel();
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// BillPayTicketTrain

// optional string placeId = 1;
inline bool BillPayTicketTrain::has_placeid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BillPayTicketTrain::set_has_placeid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BillPayTicketTrain::clear_has_placeid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BillPayTicketTrain::clear_placeid() {
  if (placeid_ != &::google::protobuf::internal::kEmptyString) {
    placeid_->clear();
  }
  clear_has_placeid();
}
inline const ::std::string& BillPayTicketTrain::placeid() const {
  return *placeid_;
}
inline void BillPayTicketTrain::set_placeid(const ::std::string& value) {
  set_has_placeid();
  if (placeid_ == &::google::protobuf::internal::kEmptyString) {
    placeid_ = new ::std::string;
  }
  placeid_->assign(value);
}
inline void BillPayTicketTrain::set_placeid(const char* value) {
  set_has_placeid();
  if (placeid_ == &::google::protobuf::internal::kEmptyString) {
    placeid_ = new ::std::string;
  }
  placeid_->assign(value);
}
inline void BillPayTicketTrain::set_placeid(const char* value, size_t size) {
  set_has_placeid();
  if (placeid_ == &::google::protobuf::internal::kEmptyString) {
    placeid_ = new ::std::string;
  }
  placeid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BillPayTicketTrain::mutable_placeid() {
  set_has_placeid();
  if (placeid_ == &::google::protobuf::internal::kEmptyString) {
    placeid_ = new ::std::string;
  }
  return placeid_;
}
inline ::std::string* BillPayTicketTrain::release_placeid() {
  clear_has_placeid();
  if (placeid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = placeid_;
    placeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BillPayTicketTrain::set_allocated_placeid(::std::string* placeid) {
  if (placeid_ != &::google::protobuf::internal::kEmptyString) {
    delete placeid_;
  }
  if (placeid) {
    set_has_placeid();
    placeid_ = placeid;
  } else {
    clear_has_placeid();
    placeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ticketId = 2;
inline bool BillPayTicketTrain::has_ticketid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BillPayTicketTrain::set_has_ticketid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BillPayTicketTrain::clear_has_ticketid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BillPayTicketTrain::clear_ticketid() {
  if (ticketid_ != &::google::protobuf::internal::kEmptyString) {
    ticketid_->clear();
  }
  clear_has_ticketid();
}
inline const ::std::string& BillPayTicketTrain::ticketid() const {
  return *ticketid_;
}
inline void BillPayTicketTrain::set_ticketid(const ::std::string& value) {
  set_has_ticketid();
  if (ticketid_ == &::google::protobuf::internal::kEmptyString) {
    ticketid_ = new ::std::string;
  }
  ticketid_->assign(value);
}
inline void BillPayTicketTrain::set_ticketid(const char* value) {
  set_has_ticketid();
  if (ticketid_ == &::google::protobuf::internal::kEmptyString) {
    ticketid_ = new ::std::string;
  }
  ticketid_->assign(value);
}
inline void BillPayTicketTrain::set_ticketid(const char* value, size_t size) {
  set_has_ticketid();
  if (ticketid_ == &::google::protobuf::internal::kEmptyString) {
    ticketid_ = new ::std::string;
  }
  ticketid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BillPayTicketTrain::mutable_ticketid() {
  set_has_ticketid();
  if (ticketid_ == &::google::protobuf::internal::kEmptyString) {
    ticketid_ = new ::std::string;
  }
  return ticketid_;
}
inline ::std::string* BillPayTicketTrain::release_ticketid() {
  clear_has_ticketid();
  if (ticketid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ticketid_;
    ticketid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BillPayTicketTrain::set_allocated_ticketid(::std::string* ticketid) {
  if (ticketid_ != &::google::protobuf::internal::kEmptyString) {
    delete ticketid_;
  }
  if (ticketid) {
    set_has_ticketid();
    ticketid_ = ticketid;
  } else {
    clear_has_ticketid();
    ticketid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string pin = 3;
inline bool BillPayTicketTrain::has_pin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BillPayTicketTrain::set_has_pin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BillPayTicketTrain::clear_has_pin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BillPayTicketTrain::clear_pin() {
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    pin_->clear();
  }
  clear_has_pin();
}
inline const ::std::string& BillPayTicketTrain::pin() const {
  return *pin_;
}
inline void BillPayTicketTrain::set_pin(const ::std::string& value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void BillPayTicketTrain::set_pin(const char* value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void BillPayTicketTrain::set_pin(const char* value, size_t size) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BillPayTicketTrain::mutable_pin() {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  return pin_;
}
inline ::std::string* BillPayTicketTrain::release_pin() {
  clear_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pin_;
    pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BillPayTicketTrain::set_allocated_pin(::std::string* pin) {
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    delete pin_;
  }
  if (pin) {
    set_has_pin();
    pin_ = pin;
  } else {
    clear_has_pin();
    pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 amount = 4;
inline bool BillPayTicketTrain::has_amount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BillPayTicketTrain::set_has_amount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BillPayTicketTrain::clear_has_amount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BillPayTicketTrain::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 BillPayTicketTrain::amount() const {
  return amount_;
}
inline void BillPayTicketTrain::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
}

// optional string providerId = 5;
inline bool BillPayTicketTrain::has_providerid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BillPayTicketTrain::set_has_providerid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BillPayTicketTrain::clear_has_providerid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BillPayTicketTrain::clear_providerid() {
  if (providerid_ != &::google::protobuf::internal::kEmptyString) {
    providerid_->clear();
  }
  clear_has_providerid();
}
inline const ::std::string& BillPayTicketTrain::providerid() const {
  return *providerid_;
}
inline void BillPayTicketTrain::set_providerid(const ::std::string& value) {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  providerid_->assign(value);
}
inline void BillPayTicketTrain::set_providerid(const char* value) {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  providerid_->assign(value);
}
inline void BillPayTicketTrain::set_providerid(const char* value, size_t size) {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  providerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BillPayTicketTrain::mutable_providerid() {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  return providerid_;
}
inline ::std::string* BillPayTicketTrain::release_providerid() {
  clear_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = providerid_;
    providerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BillPayTicketTrain::set_allocated_providerid(::std::string* providerid) {
  if (providerid_ != &::google::protobuf::internal::kEmptyString) {
    delete providerid_;
  }
  if (providerid) {
    set_has_providerid();
    providerid_ = providerid;
  } else {
    clear_has_providerid();
    providerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string channel = 6;
inline bool BillPayTicketTrain::has_channel() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BillPayTicketTrain::set_has_channel() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BillPayTicketTrain::clear_has_channel() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BillPayTicketTrain::clear_channel() {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    channel_->clear();
  }
  clear_has_channel();
}
inline const ::std::string& BillPayTicketTrain::channel() const {
  return *channel_;
}
inline void BillPayTicketTrain::set_channel(const ::std::string& value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void BillPayTicketTrain::set_channel(const char* value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void BillPayTicketTrain::set_channel(const char* value, size_t size) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BillPayTicketTrain::mutable_channel() {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  return channel_;
}
inline ::std::string* BillPayTicketTrain::release_channel() {
  clear_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_;
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BillPayTicketTrain::set_allocated_channel(::std::string* channel) {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_;
  }
  if (channel) {
    set_has_channel();
    channel_ = channel;
  } else {
    clear_has_channel();
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// BillPayInsurance

// optional string providerId = 1;
inline bool BillPayInsurance::has_providerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BillPayInsurance::set_has_providerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BillPayInsurance::clear_has_providerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BillPayInsurance::clear_providerid() {
  if (providerid_ != &::google::protobuf::internal::kEmptyString) {
    providerid_->clear();
  }
  clear_has_providerid();
}
inline const ::std::string& BillPayInsurance::providerid() const {
  return *providerid_;
}
inline void BillPayInsurance::set_providerid(const ::std::string& value) {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  providerid_->assign(value);
}
inline void BillPayInsurance::set_providerid(const char* value) {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  providerid_->assign(value);
}
inline void BillPayInsurance::set_providerid(const char* value, size_t size) {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  providerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BillPayInsurance::mutable_providerid() {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  return providerid_;
}
inline ::std::string* BillPayInsurance::release_providerid() {
  clear_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = providerid_;
    providerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BillPayInsurance::set_allocated_providerid(::std::string* providerid) {
  if (providerid_ != &::google::protobuf::internal::kEmptyString) {
    delete providerid_;
  }
  if (providerid) {
    set_has_providerid();
    providerid_ = providerid;
  } else {
    clear_has_providerid();
    providerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string insuranceAcc = 2;
inline bool BillPayInsurance::has_insuranceacc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BillPayInsurance::set_has_insuranceacc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BillPayInsurance::clear_has_insuranceacc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BillPayInsurance::clear_insuranceacc() {
  if (insuranceacc_ != &::google::protobuf::internal::kEmptyString) {
    insuranceacc_->clear();
  }
  clear_has_insuranceacc();
}
inline const ::std::string& BillPayInsurance::insuranceacc() const {
  return *insuranceacc_;
}
inline void BillPayInsurance::set_insuranceacc(const ::std::string& value) {
  set_has_insuranceacc();
  if (insuranceacc_ == &::google::protobuf::internal::kEmptyString) {
    insuranceacc_ = new ::std::string;
  }
  insuranceacc_->assign(value);
}
inline void BillPayInsurance::set_insuranceacc(const char* value) {
  set_has_insuranceacc();
  if (insuranceacc_ == &::google::protobuf::internal::kEmptyString) {
    insuranceacc_ = new ::std::string;
  }
  insuranceacc_->assign(value);
}
inline void BillPayInsurance::set_insuranceacc(const char* value, size_t size) {
  set_has_insuranceacc();
  if (insuranceacc_ == &::google::protobuf::internal::kEmptyString) {
    insuranceacc_ = new ::std::string;
  }
  insuranceacc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BillPayInsurance::mutable_insuranceacc() {
  set_has_insuranceacc();
  if (insuranceacc_ == &::google::protobuf::internal::kEmptyString) {
    insuranceacc_ = new ::std::string;
  }
  return insuranceacc_;
}
inline ::std::string* BillPayInsurance::release_insuranceacc() {
  clear_has_insuranceacc();
  if (insuranceacc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = insuranceacc_;
    insuranceacc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BillPayInsurance::set_allocated_insuranceacc(::std::string* insuranceacc) {
  if (insuranceacc_ != &::google::protobuf::internal::kEmptyString) {
    delete insuranceacc_;
  }
  if (insuranceacc) {
    set_has_insuranceacc();
    insuranceacc_ = insuranceacc;
  } else {
    clear_has_insuranceacc();
    insuranceacc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string pin = 3;
inline bool BillPayInsurance::has_pin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BillPayInsurance::set_has_pin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BillPayInsurance::clear_has_pin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BillPayInsurance::clear_pin() {
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    pin_->clear();
  }
  clear_has_pin();
}
inline const ::std::string& BillPayInsurance::pin() const {
  return *pin_;
}
inline void BillPayInsurance::set_pin(const ::std::string& value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void BillPayInsurance::set_pin(const char* value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void BillPayInsurance::set_pin(const char* value, size_t size) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BillPayInsurance::mutable_pin() {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  return pin_;
}
inline ::std::string* BillPayInsurance::release_pin() {
  clear_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pin_;
    pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BillPayInsurance::set_allocated_pin(::std::string* pin) {
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    delete pin_;
  }
  if (pin) {
    set_has_pin();
    pin_ = pin;
  } else {
    clear_has_pin();
    pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 amount = 4;
inline bool BillPayInsurance::has_amount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BillPayInsurance::set_has_amount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BillPayInsurance::clear_has_amount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BillPayInsurance::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 BillPayInsurance::amount() const {
  return amount_;
}
inline void BillPayInsurance::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
}

// optional string channel = 5;
inline bool BillPayInsurance::has_channel() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BillPayInsurance::set_has_channel() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BillPayInsurance::clear_has_channel() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BillPayInsurance::clear_channel() {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    channel_->clear();
  }
  clear_has_channel();
}
inline const ::std::string& BillPayInsurance::channel() const {
  return *channel_;
}
inline void BillPayInsurance::set_channel(const ::std::string& value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void BillPayInsurance::set_channel(const char* value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void BillPayInsurance::set_channel(const char* value, size_t size) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BillPayInsurance::mutable_channel() {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  return channel_;
}
inline ::std::string* BillPayInsurance::release_channel() {
  clear_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_;
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BillPayInsurance::set_allocated_channel(::std::string* channel) {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_;
  }
  if (channel) {
    set_has_channel();
    channel_ = channel;
  } else {
    clear_has_channel();
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// BillPayInternet

// optional string providerId = 1;
inline bool BillPayInternet::has_providerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BillPayInternet::set_has_providerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BillPayInternet::clear_has_providerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BillPayInternet::clear_providerid() {
  if (providerid_ != &::google::protobuf::internal::kEmptyString) {
    providerid_->clear();
  }
  clear_has_providerid();
}
inline const ::std::string& BillPayInternet::providerid() const {
  return *providerid_;
}
inline void BillPayInternet::set_providerid(const ::std::string& value) {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  providerid_->assign(value);
}
inline void BillPayInternet::set_providerid(const char* value) {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  providerid_->assign(value);
}
inline void BillPayInternet::set_providerid(const char* value, size_t size) {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  providerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BillPayInternet::mutable_providerid() {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  return providerid_;
}
inline ::std::string* BillPayInternet::release_providerid() {
  clear_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = providerid_;
    providerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BillPayInternet::set_allocated_providerid(::std::string* providerid) {
  if (providerid_ != &::google::protobuf::internal::kEmptyString) {
    delete providerid_;
  }
  if (providerid) {
    set_has_providerid();
    providerid_ = providerid;
  } else {
    clear_has_providerid();
    providerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string customerAcc = 2;
inline bool BillPayInternet::has_customeracc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BillPayInternet::set_has_customeracc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BillPayInternet::clear_has_customeracc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BillPayInternet::clear_customeracc() {
  if (customeracc_ != &::google::protobuf::internal::kEmptyString) {
    customeracc_->clear();
  }
  clear_has_customeracc();
}
inline const ::std::string& BillPayInternet::customeracc() const {
  return *customeracc_;
}
inline void BillPayInternet::set_customeracc(const ::std::string& value) {
  set_has_customeracc();
  if (customeracc_ == &::google::protobuf::internal::kEmptyString) {
    customeracc_ = new ::std::string;
  }
  customeracc_->assign(value);
}
inline void BillPayInternet::set_customeracc(const char* value) {
  set_has_customeracc();
  if (customeracc_ == &::google::protobuf::internal::kEmptyString) {
    customeracc_ = new ::std::string;
  }
  customeracc_->assign(value);
}
inline void BillPayInternet::set_customeracc(const char* value, size_t size) {
  set_has_customeracc();
  if (customeracc_ == &::google::protobuf::internal::kEmptyString) {
    customeracc_ = new ::std::string;
  }
  customeracc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BillPayInternet::mutable_customeracc() {
  set_has_customeracc();
  if (customeracc_ == &::google::protobuf::internal::kEmptyString) {
    customeracc_ = new ::std::string;
  }
  return customeracc_;
}
inline ::std::string* BillPayInternet::release_customeracc() {
  clear_has_customeracc();
  if (customeracc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customeracc_;
    customeracc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BillPayInternet::set_allocated_customeracc(::std::string* customeracc) {
  if (customeracc_ != &::google::protobuf::internal::kEmptyString) {
    delete customeracc_;
  }
  if (customeracc) {
    set_has_customeracc();
    customeracc_ = customeracc;
  } else {
    clear_has_customeracc();
    customeracc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string areaId = 3;
inline bool BillPayInternet::has_areaid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BillPayInternet::set_has_areaid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BillPayInternet::clear_has_areaid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BillPayInternet::clear_areaid() {
  if (areaid_ != &::google::protobuf::internal::kEmptyString) {
    areaid_->clear();
  }
  clear_has_areaid();
}
inline const ::std::string& BillPayInternet::areaid() const {
  return *areaid_;
}
inline void BillPayInternet::set_areaid(const ::std::string& value) {
  set_has_areaid();
  if (areaid_ == &::google::protobuf::internal::kEmptyString) {
    areaid_ = new ::std::string;
  }
  areaid_->assign(value);
}
inline void BillPayInternet::set_areaid(const char* value) {
  set_has_areaid();
  if (areaid_ == &::google::protobuf::internal::kEmptyString) {
    areaid_ = new ::std::string;
  }
  areaid_->assign(value);
}
inline void BillPayInternet::set_areaid(const char* value, size_t size) {
  set_has_areaid();
  if (areaid_ == &::google::protobuf::internal::kEmptyString) {
    areaid_ = new ::std::string;
  }
  areaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BillPayInternet::mutable_areaid() {
  set_has_areaid();
  if (areaid_ == &::google::protobuf::internal::kEmptyString) {
    areaid_ = new ::std::string;
  }
  return areaid_;
}
inline ::std::string* BillPayInternet::release_areaid() {
  clear_has_areaid();
  if (areaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = areaid_;
    areaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BillPayInternet::set_allocated_areaid(::std::string* areaid) {
  if (areaid_ != &::google::protobuf::internal::kEmptyString) {
    delete areaid_;
  }
  if (areaid) {
    set_has_areaid();
    areaid_ = areaid;
  } else {
    clear_has_areaid();
    areaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string pin = 4;
inline bool BillPayInternet::has_pin() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BillPayInternet::set_has_pin() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BillPayInternet::clear_has_pin() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BillPayInternet::clear_pin() {
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    pin_->clear();
  }
  clear_has_pin();
}
inline const ::std::string& BillPayInternet::pin() const {
  return *pin_;
}
inline void BillPayInternet::set_pin(const ::std::string& value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void BillPayInternet::set_pin(const char* value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void BillPayInternet::set_pin(const char* value, size_t size) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BillPayInternet::mutable_pin() {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  return pin_;
}
inline ::std::string* BillPayInternet::release_pin() {
  clear_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pin_;
    pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BillPayInternet::set_allocated_pin(::std::string* pin) {
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    delete pin_;
  }
  if (pin) {
    set_has_pin();
    pin_ = pin;
  } else {
    clear_has_pin();
    pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 amount = 5;
inline bool BillPayInternet::has_amount() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BillPayInternet::set_has_amount() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BillPayInternet::clear_has_amount() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BillPayInternet::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 BillPayInternet::amount() const {
  return amount_;
}
inline void BillPayInternet::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
}

// optional string channel = 6;
inline bool BillPayInternet::has_channel() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BillPayInternet::set_has_channel() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BillPayInternet::clear_has_channel() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BillPayInternet::clear_channel() {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    channel_->clear();
  }
  clear_has_channel();
}
inline const ::std::string& BillPayInternet::channel() const {
  return *channel_;
}
inline void BillPayInternet::set_channel(const ::std::string& value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void BillPayInternet::set_channel(const char* value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void BillPayInternet::set_channel(const char* value, size_t size) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BillPayInternet::mutable_channel() {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  return channel_;
}
inline ::std::string* BillPayInternet::release_channel() {
  clear_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_;
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BillPayInternet::set_allocated_channel(::std::string* channel) {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_;
  }
  if (channel) {
    set_has_channel();
    channel_ = channel;
  } else {
    clear_has_channel();
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// BillPayOther

// optional string providerId = 1;
inline bool BillPayOther::has_providerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BillPayOther::set_has_providerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BillPayOther::clear_has_providerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BillPayOther::clear_providerid() {
  if (providerid_ != &::google::protobuf::internal::kEmptyString) {
    providerid_->clear();
  }
  clear_has_providerid();
}
inline const ::std::string& BillPayOther::providerid() const {
  return *providerid_;
}
inline void BillPayOther::set_providerid(const ::std::string& value) {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  providerid_->assign(value);
}
inline void BillPayOther::set_providerid(const char* value) {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  providerid_->assign(value);
}
inline void BillPayOther::set_providerid(const char* value, size_t size) {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  providerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BillPayOther::mutable_providerid() {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  return providerid_;
}
inline ::std::string* BillPayOther::release_providerid() {
  clear_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = providerid_;
    providerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BillPayOther::set_allocated_providerid(::std::string* providerid) {
  if (providerid_ != &::google::protobuf::internal::kEmptyString) {
    delete providerid_;
  }
  if (providerid) {
    set_has_providerid();
    providerid_ = providerid;
  } else {
    clear_has_providerid();
    providerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string billerId = 2;
inline bool BillPayOther::has_billerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BillPayOther::set_has_billerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BillPayOther::clear_has_billerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BillPayOther::clear_billerid() {
  if (billerid_ != &::google::protobuf::internal::kEmptyString) {
    billerid_->clear();
  }
  clear_has_billerid();
}
inline const ::std::string& BillPayOther::billerid() const {
  return *billerid_;
}
inline void BillPayOther::set_billerid(const ::std::string& value) {
  set_has_billerid();
  if (billerid_ == &::google::protobuf::internal::kEmptyString) {
    billerid_ = new ::std::string;
  }
  billerid_->assign(value);
}
inline void BillPayOther::set_billerid(const char* value) {
  set_has_billerid();
  if (billerid_ == &::google::protobuf::internal::kEmptyString) {
    billerid_ = new ::std::string;
  }
  billerid_->assign(value);
}
inline void BillPayOther::set_billerid(const char* value, size_t size) {
  set_has_billerid();
  if (billerid_ == &::google::protobuf::internal::kEmptyString) {
    billerid_ = new ::std::string;
  }
  billerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BillPayOther::mutable_billerid() {
  set_has_billerid();
  if (billerid_ == &::google::protobuf::internal::kEmptyString) {
    billerid_ = new ::std::string;
  }
  return billerid_;
}
inline ::std::string* BillPayOther::release_billerid() {
  clear_has_billerid();
  if (billerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = billerid_;
    billerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BillPayOther::set_allocated_billerid(::std::string* billerid) {
  if (billerid_ != &::google::protobuf::internal::kEmptyString) {
    delete billerid_;
  }
  if (billerid) {
    set_has_billerid();
    billerid_ = billerid;
  } else {
    clear_has_billerid();
    billerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string areaId = 3;
inline bool BillPayOther::has_areaid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BillPayOther::set_has_areaid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BillPayOther::clear_has_areaid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BillPayOther::clear_areaid() {
  if (areaid_ != &::google::protobuf::internal::kEmptyString) {
    areaid_->clear();
  }
  clear_has_areaid();
}
inline const ::std::string& BillPayOther::areaid() const {
  return *areaid_;
}
inline void BillPayOther::set_areaid(const ::std::string& value) {
  set_has_areaid();
  if (areaid_ == &::google::protobuf::internal::kEmptyString) {
    areaid_ = new ::std::string;
  }
  areaid_->assign(value);
}
inline void BillPayOther::set_areaid(const char* value) {
  set_has_areaid();
  if (areaid_ == &::google::protobuf::internal::kEmptyString) {
    areaid_ = new ::std::string;
  }
  areaid_->assign(value);
}
inline void BillPayOther::set_areaid(const char* value, size_t size) {
  set_has_areaid();
  if (areaid_ == &::google::protobuf::internal::kEmptyString) {
    areaid_ = new ::std::string;
  }
  areaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BillPayOther::mutable_areaid() {
  set_has_areaid();
  if (areaid_ == &::google::protobuf::internal::kEmptyString) {
    areaid_ = new ::std::string;
  }
  return areaid_;
}
inline ::std::string* BillPayOther::release_areaid() {
  clear_has_areaid();
  if (areaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = areaid_;
    areaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BillPayOther::set_allocated_areaid(::std::string* areaid) {
  if (areaid_ != &::google::protobuf::internal::kEmptyString) {
    delete areaid_;
  }
  if (areaid) {
    set_has_areaid();
    areaid_ = areaid;
  } else {
    clear_has_areaid();
    areaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string pin = 4;
inline bool BillPayOther::has_pin() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BillPayOther::set_has_pin() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BillPayOther::clear_has_pin() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BillPayOther::clear_pin() {
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    pin_->clear();
  }
  clear_has_pin();
}
inline const ::std::string& BillPayOther::pin() const {
  return *pin_;
}
inline void BillPayOther::set_pin(const ::std::string& value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void BillPayOther::set_pin(const char* value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void BillPayOther::set_pin(const char* value, size_t size) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BillPayOther::mutable_pin() {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  return pin_;
}
inline ::std::string* BillPayOther::release_pin() {
  clear_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pin_;
    pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BillPayOther::set_allocated_pin(::std::string* pin) {
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    delete pin_;
  }
  if (pin) {
    set_has_pin();
    pin_ = pin;
  } else {
    clear_has_pin();
    pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 amount = 5;
inline bool BillPayOther::has_amount() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BillPayOther::set_has_amount() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BillPayOther::clear_has_amount() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BillPayOther::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 BillPayOther::amount() const {
  return amount_;
}
inline void BillPayOther::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
}

// optional string channel = 6;
inline bool BillPayOther::has_channel() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BillPayOther::set_has_channel() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BillPayOther::clear_has_channel() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BillPayOther::clear_channel() {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    channel_->clear();
  }
  clear_has_channel();
}
inline const ::std::string& BillPayOther::channel() const {
  return *channel_;
}
inline void BillPayOther::set_channel(const ::std::string& value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void BillPayOther::set_channel(const char* value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void BillPayOther::set_channel(const char* value, size_t size) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BillPayOther::mutable_channel() {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  return channel_;
}
inline ::std::string* BillPayOther::release_channel() {
  clear_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_;
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BillPayOther::set_allocated_channel(::std::string* channel) {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_;
  }
  if (channel) {
    set_has_channel();
    channel_ = channel;
  } else {
    clear_has_channel();
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Err

// optional uint32 rcode = 1;
inline bool Err::has_rcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Err::set_has_rcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Err::clear_has_rcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Err::clear_rcode() {
  rcode_ = 0u;
  clear_has_rcode();
}
inline ::google::protobuf::uint32 Err::rcode() const {
  return rcode_;
}
inline void Err::set_rcode(::google::protobuf::uint32 value) {
  set_has_rcode();
  rcode_ = value;
}

// optional string rdesc = 2;
inline bool Err::has_rdesc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Err::set_has_rdesc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Err::clear_has_rdesc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Err::clear_rdesc() {
  if (rdesc_ != &::google::protobuf::internal::kEmptyString) {
    rdesc_->clear();
  }
  clear_has_rdesc();
}
inline const ::std::string& Err::rdesc() const {
  return *rdesc_;
}
inline void Err::set_rdesc(const ::std::string& value) {
  set_has_rdesc();
  if (rdesc_ == &::google::protobuf::internal::kEmptyString) {
    rdesc_ = new ::std::string;
  }
  rdesc_->assign(value);
}
inline void Err::set_rdesc(const char* value) {
  set_has_rdesc();
  if (rdesc_ == &::google::protobuf::internal::kEmptyString) {
    rdesc_ = new ::std::string;
  }
  rdesc_->assign(value);
}
inline void Err::set_rdesc(const char* value, size_t size) {
  set_has_rdesc();
  if (rdesc_ == &::google::protobuf::internal::kEmptyString) {
    rdesc_ = new ::std::string;
  }
  rdesc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Err::mutable_rdesc() {
  set_has_rdesc();
  if (rdesc_ == &::google::protobuf::internal::kEmptyString) {
    rdesc_ = new ::std::string;
  }
  return rdesc_;
}
inline ::std::string* Err::release_rdesc() {
  clear_has_rdesc();
  if (rdesc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rdesc_;
    rdesc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Err::set_allocated_rdesc(::std::string* rdesc) {
  if (rdesc_ != &::google::protobuf::internal::kEmptyString) {
    delete rdesc_;
  }
  if (rdesc) {
    set_has_rdesc();
    rdesc_ = rdesc;
  } else {
    clear_has_rdesc();
    rdesc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SendSms

// optional uint32 sms_id = 1;
inline bool SendSms::has_sms_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SendSms::set_has_sms_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SendSms::clear_has_sms_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SendSms::clear_sms_id() {
  sms_id_ = 0u;
  clear_has_sms_id();
}
inline ::google::protobuf::uint32 SendSms::sms_id() const {
  return sms_id_;
}
inline void SendSms::set_sms_id(::google::protobuf::uint32 value) {
  set_has_sms_id();
  sms_id_ = value;
}

// optional uint32 to_number = 2;
inline bool SendSms::has_to_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SendSms::set_has_to_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SendSms::clear_has_to_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SendSms::clear_to_number() {
  to_number_ = 0u;
  clear_has_to_number();
}
inline ::google::protobuf::uint32 SendSms::to_number() const {
  return to_number_;
}
inline void SendSms::set_to_number(::google::protobuf::uint32 value) {
  set_has_to_number();
  to_number_ = value;
}

// optional string content = 3;
inline bool SendSms::has_content() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SendSms::set_has_content() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SendSms::clear_has_content() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SendSms::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& SendSms::content() const {
  return *content_;
}
inline void SendSms::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void SendSms::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void SendSms::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SendSms::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* SendSms::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SendSms::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SendSmsReply

// optional uint32 sms_id = 1;
inline bool SendSmsReply::has_sms_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SendSmsReply::set_has_sms_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SendSmsReply::clear_has_sms_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SendSmsReply::clear_sms_id() {
  sms_id_ = 0u;
  clear_has_sms_id();
}
inline ::google::protobuf::uint32 SendSmsReply::sms_id() const {
  return sms_id_;
}
inline void SendSmsReply::set_sms_id(::google::protobuf::uint32 value) {
  set_has_sms_id();
  sms_id_ = value;
}

// optional uint32 rcode = 2;
inline bool SendSmsReply::has_rcode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SendSmsReply::set_has_rcode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SendSmsReply::clear_has_rcode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SendSmsReply::clear_rcode() {
  rcode_ = 0u;
  clear_has_rcode();
}
inline ::google::protobuf::uint32 SendSmsReply::rcode() const {
  return rcode_;
}
inline void SendSmsReply::set_rcode(::google::protobuf::uint32 value) {
  set_has_rcode();
  rcode_ = value;
}

// optional string rdesc = 3;
inline bool SendSmsReply::has_rdesc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SendSmsReply::set_has_rdesc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SendSmsReply::clear_has_rdesc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SendSmsReply::clear_rdesc() {
  if (rdesc_ != &::google::protobuf::internal::kEmptyString) {
    rdesc_->clear();
  }
  clear_has_rdesc();
}
inline const ::std::string& SendSmsReply::rdesc() const {
  return *rdesc_;
}
inline void SendSmsReply::set_rdesc(const ::std::string& value) {
  set_has_rdesc();
  if (rdesc_ == &::google::protobuf::internal::kEmptyString) {
    rdesc_ = new ::std::string;
  }
  rdesc_->assign(value);
}
inline void SendSmsReply::set_rdesc(const char* value) {
  set_has_rdesc();
  if (rdesc_ == &::google::protobuf::internal::kEmptyString) {
    rdesc_ = new ::std::string;
  }
  rdesc_->assign(value);
}
inline void SendSmsReply::set_rdesc(const char* value, size_t size) {
  set_has_rdesc();
  if (rdesc_ == &::google::protobuf::internal::kEmptyString) {
    rdesc_ = new ::std::string;
  }
  rdesc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SendSmsReply::mutable_rdesc() {
  set_has_rdesc();
  if (rdesc_ == &::google::protobuf::internal::kEmptyString) {
    rdesc_ = new ::std::string;
  }
  return rdesc_;
}
inline ::std::string* SendSmsReply::release_rdesc() {
  clear_has_rdesc();
  if (rdesc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rdesc_;
    rdesc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SendSmsReply::set_allocated_rdesc(::std::string* rdesc) {
  if (rdesc_ != &::google::protobuf::internal::kEmptyString) {
    delete rdesc_;
  }
  if (rdesc) {
    set_has_rdesc();
    rdesc_ = rdesc;
  } else {
    clear_has_rdesc();
    rdesc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RegStatus

// optional bool is_setup = 1;
inline bool RegStatus::has_is_setup() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegStatus::set_has_is_setup() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegStatus::clear_has_is_setup() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegStatus::clear_is_setup() {
  is_setup_ = false;
  clear_has_is_setup();
}
inline bool RegStatus::is_setup() const {
  return is_setup_;
}
inline void RegStatus::set_is_setup(bool value) {
  set_has_is_setup();
  is_setup_ = value;
}

// optional bool is_reged = 2;
inline bool RegStatus::has_is_reged() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegStatus::set_has_is_reged() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegStatus::clear_has_is_reged() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegStatus::clear_is_reged() {
  is_reged_ = false;
  clear_has_is_reged();
}
inline bool RegStatus::is_reged() const {
  return is_reged_;
}
inline void RegStatus::set_is_reged(bool value) {
  set_has_is_reged();
  is_reged_ = value;
}

// optional bool is_active = 3;
inline bool RegStatus::has_is_active() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegStatus::set_has_is_active() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegStatus::clear_has_is_active() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegStatus::clear_is_active() {
  is_active_ = false;
  clear_has_is_active();
}
inline bool RegStatus::is_active() const {
  return is_active_;
}
inline void RegStatus::set_is_active(bool value) {
  set_has_is_active();
  is_active_ = value;
}

// optional bool is_named = 4;
inline bool RegStatus::has_is_named() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RegStatus::set_has_is_named() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RegStatus::clear_has_is_named() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RegStatus::clear_is_named() {
  is_named_ = false;
  clear_has_is_named();
}
inline bool RegStatus::is_named() const {
  return is_named_;
}
inline void RegStatus::set_is_named(bool value) {
  set_has_is_named();
  is_named_ = value;
}

// optional bool is_frozen = 5;
inline bool RegStatus::has_is_frozen() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RegStatus::set_has_is_frozen() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RegStatus::clear_has_is_frozen() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RegStatus::clear_is_frozen() {
  is_frozen_ = false;
  clear_has_is_frozen();
}
inline bool RegStatus::is_frozen() const {
  return is_frozen_;
}
inline void RegStatus::set_is_frozen(bool value) {
  set_has_is_frozen();
  is_frozen_ = value;
}

// optional bool is_suppend = 6;
inline bool RegStatus::has_is_suppend() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RegStatus::set_has_is_suppend() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RegStatus::clear_has_is_suppend() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RegStatus::clear_is_suppend() {
  is_suppend_ = false;
  clear_has_is_suppend();
}
inline bool RegStatus::is_suppend() const {
  return is_suppend_;
}
inline void RegStatus::set_is_suppend(bool value) {
  set_has_is_suppend();
  is_suppend_ = value;
}

// optional bool is_stopped = 7;
inline bool RegStatus::has_is_stopped() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RegStatus::set_has_is_stopped() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RegStatus::clear_has_is_stopped() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RegStatus::clear_is_stopped() {
  is_stopped_ = false;
  clear_has_is_stopped();
}
inline bool RegStatus::is_stopped() const {
  return is_stopped_;
}
inline void RegStatus::set_is_stopped(bool value) {
  set_has_is_stopped();
  is_stopped_ = value;
}

// -------------------------------------------------------------------

// GetAgentInfoReply

// optional bool result = 1;
inline bool GetAgentInfoReply::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetAgentInfoReply::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetAgentInfoReply::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetAgentInfoReply::clear_result() {
  result_ = false;
  clear_has_result();
}
inline bool GetAgentInfoReply::result() const {
  return result_;
}
inline void GetAgentInfoReply::set_result(bool value) {
  set_has_result();
  result_ = value;
}

// optional string name = 2;
inline bool GetAgentInfoReply::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetAgentInfoReply::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetAgentInfoReply::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetAgentInfoReply::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& GetAgentInfoReply::name() const {
  return *name_;
}
inline void GetAgentInfoReply::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void GetAgentInfoReply::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void GetAgentInfoReply::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetAgentInfoReply::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* GetAgentInfoReply::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetAgentInfoReply::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string card_id = 3;
inline bool GetAgentInfoReply::has_card_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetAgentInfoReply::set_has_card_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetAgentInfoReply::clear_has_card_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetAgentInfoReply::clear_card_id() {
  if (card_id_ != &::google::protobuf::internal::kEmptyString) {
    card_id_->clear();
  }
  clear_has_card_id();
}
inline const ::std::string& GetAgentInfoReply::card_id() const {
  return *card_id_;
}
inline void GetAgentInfoReply::set_card_id(const ::std::string& value) {
  set_has_card_id();
  if (card_id_ == &::google::protobuf::internal::kEmptyString) {
    card_id_ = new ::std::string;
  }
  card_id_->assign(value);
}
inline void GetAgentInfoReply::set_card_id(const char* value) {
  set_has_card_id();
  if (card_id_ == &::google::protobuf::internal::kEmptyString) {
    card_id_ = new ::std::string;
  }
  card_id_->assign(value);
}
inline void GetAgentInfoReply::set_card_id(const char* value, size_t size) {
  set_has_card_id();
  if (card_id_ == &::google::protobuf::internal::kEmptyString) {
    card_id_ = new ::std::string;
  }
  card_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetAgentInfoReply::mutable_card_id() {
  set_has_card_id();
  if (card_id_ == &::google::protobuf::internal::kEmptyString) {
    card_id_ = new ::std::string;
  }
  return card_id_;
}
inline ::std::string* GetAgentInfoReply::release_card_id() {
  clear_has_card_id();
  if (card_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = card_id_;
    card_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetAgentInfoReply::set_allocated_card_id(::std::string* card_id) {
  if (card_id_ != &::google::protobuf::internal::kEmptyString) {
    delete card_id_;
  }
  if (card_id) {
    set_has_card_id();
    card_id_ = card_id;
  } else {
    clear_has_card_id();
    card_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double momo = 4;
inline bool GetAgentInfoReply::has_momo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetAgentInfoReply::set_has_momo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetAgentInfoReply::clear_has_momo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetAgentInfoReply::clear_momo() {
  momo_ = 0;
  clear_has_momo();
}
inline double GetAgentInfoReply::momo() const {
  return momo_;
}
inline void GetAgentInfoReply::set_momo(double value) {
  set_has_momo();
  momo_ = value;
}

// optional double mload = 5;
inline bool GetAgentInfoReply::has_mload() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetAgentInfoReply::set_has_mload() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetAgentInfoReply::clear_has_mload() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetAgentInfoReply::clear_mload() {
  mload_ = 0;
  clear_has_mload();
}
inline double GetAgentInfoReply::mload() const {
  return mload_;
}
inline void GetAgentInfoReply::set_mload(double value) {
  set_has_mload();
  mload_ = value;
}

// optional string email = 6;
inline bool GetAgentInfoReply::has_email() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GetAgentInfoReply::set_has_email() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GetAgentInfoReply::clear_has_email() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GetAgentInfoReply::clear_email() {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& GetAgentInfoReply::email() const {
  return *email_;
}
inline void GetAgentInfoReply::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void GetAgentInfoReply::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void GetAgentInfoReply::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetAgentInfoReply::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  return email_;
}
inline ::std::string* GetAgentInfoReply::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetAgentInfoReply::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .com.mservice.momo.msg.RegStatus regStatus = 7;
inline bool GetAgentInfoReply::has_regstatus() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GetAgentInfoReply::set_has_regstatus() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GetAgentInfoReply::clear_has_regstatus() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GetAgentInfoReply::clear_regstatus() {
  if (regstatus_ != NULL) regstatus_->::com::mservice::momo::msg::RegStatus::Clear();
  clear_has_regstatus();
}
inline const ::com::mservice::momo::msg::RegStatus& GetAgentInfoReply::regstatus() const {
  return regstatus_ != NULL ? *regstatus_ : *default_instance_->regstatus_;
}
inline ::com::mservice::momo::msg::RegStatus* GetAgentInfoReply::mutable_regstatus() {
  set_has_regstatus();
  if (regstatus_ == NULL) regstatus_ = new ::com::mservice::momo::msg::RegStatus;
  return regstatus_;
}
inline ::com::mservice::momo::msg::RegStatus* GetAgentInfoReply::release_regstatus() {
  clear_has_regstatus();
  ::com::mservice::momo::msg::RegStatus* temp = regstatus_;
  regstatus_ = NULL;
  return temp;
}
inline void GetAgentInfoReply::set_allocated_regstatus(::com::mservice::momo::msg::RegStatus* regstatus) {
  delete regstatus_;
  regstatus_ = regstatus;
  if (regstatus) {
    set_has_regstatus();
  } else {
    clear_has_regstatus();
  }
}

// optional uint64 point = 8;
inline bool GetAgentInfoReply::has_point() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GetAgentInfoReply::set_has_point() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GetAgentInfoReply::clear_has_point() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GetAgentInfoReply::clear_point() {
  point_ = GOOGLE_ULONGLONG(0);
  clear_has_point();
}
inline ::google::protobuf::uint64 GetAgentInfoReply::point() const {
  return point_;
}
inline void GetAgentInfoReply::set_point(::google::protobuf::uint64 value) {
  set_has_point();
  point_ = value;
}

// optional string dateOfBirth = 9;
inline bool GetAgentInfoReply::has_dateofbirth() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GetAgentInfoReply::set_has_dateofbirth() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GetAgentInfoReply::clear_has_dateofbirth() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GetAgentInfoReply::clear_dateofbirth() {
  if (dateofbirth_ != &::google::protobuf::internal::kEmptyString) {
    dateofbirth_->clear();
  }
  clear_has_dateofbirth();
}
inline const ::std::string& GetAgentInfoReply::dateofbirth() const {
  return *dateofbirth_;
}
inline void GetAgentInfoReply::set_dateofbirth(const ::std::string& value) {
  set_has_dateofbirth();
  if (dateofbirth_ == &::google::protobuf::internal::kEmptyString) {
    dateofbirth_ = new ::std::string;
  }
  dateofbirth_->assign(value);
}
inline void GetAgentInfoReply::set_dateofbirth(const char* value) {
  set_has_dateofbirth();
  if (dateofbirth_ == &::google::protobuf::internal::kEmptyString) {
    dateofbirth_ = new ::std::string;
  }
  dateofbirth_->assign(value);
}
inline void GetAgentInfoReply::set_dateofbirth(const char* value, size_t size) {
  set_has_dateofbirth();
  if (dateofbirth_ == &::google::protobuf::internal::kEmptyString) {
    dateofbirth_ = new ::std::string;
  }
  dateofbirth_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetAgentInfoReply::mutable_dateofbirth() {
  set_has_dateofbirth();
  if (dateofbirth_ == &::google::protobuf::internal::kEmptyString) {
    dateofbirth_ = new ::std::string;
  }
  return dateofbirth_;
}
inline ::std::string* GetAgentInfoReply::release_dateofbirth() {
  clear_has_dateofbirth();
  if (dateofbirth_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dateofbirth_;
    dateofbirth_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetAgentInfoReply::set_allocated_dateofbirth(::std::string* dateofbirth) {
  if (dateofbirth_ != &::google::protobuf::internal::kEmptyString) {
    delete dateofbirth_;
  }
  if (dateofbirth) {
    set_has_dateofbirth();
    dateofbirth_ = dateofbirth;
  } else {
    clear_has_dateofbirth();
    dateofbirth_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string address = 10;
inline bool GetAgentInfoReply::has_address() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GetAgentInfoReply::set_has_address() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GetAgentInfoReply::clear_has_address() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GetAgentInfoReply::clear_address() {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& GetAgentInfoReply::address() const {
  return *address_;
}
inline void GetAgentInfoReply::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void GetAgentInfoReply::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void GetAgentInfoReply::set_address(const char* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetAgentInfoReply::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  return address_;
}
inline ::std::string* GetAgentInfoReply::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetAgentInfoReply::set_allocated_address(::std::string* address) {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    delete address_;
  }
  if (address) {
    set_has_address();
    address_ = address;
  } else {
    clear_has_address();
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 rcode = 11;
inline bool GetAgentInfoReply::has_rcode() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GetAgentInfoReply::set_has_rcode() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GetAgentInfoReply::clear_has_rcode() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GetAgentInfoReply::clear_rcode() {
  rcode_ = 0u;
  clear_has_rcode();
}
inline ::google::protobuf::uint32 GetAgentInfoReply::rcode() const {
  return rcode_;
}
inline void GetAgentInfoReply::set_rcode(::google::protobuf::uint32 value) {
  set_has_rcode();
  rcode_ = value;
}

// optional string bank_name = 12;
inline bool GetAgentInfoReply::has_bank_name() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GetAgentInfoReply::set_has_bank_name() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GetAgentInfoReply::clear_has_bank_name() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GetAgentInfoReply::clear_bank_name() {
  if (bank_name_ != &::google::protobuf::internal::kEmptyString) {
    bank_name_->clear();
  }
  clear_has_bank_name();
}
inline const ::std::string& GetAgentInfoReply::bank_name() const {
  return *bank_name_;
}
inline void GetAgentInfoReply::set_bank_name(const ::std::string& value) {
  set_has_bank_name();
  if (bank_name_ == &::google::protobuf::internal::kEmptyString) {
    bank_name_ = new ::std::string;
  }
  bank_name_->assign(value);
}
inline void GetAgentInfoReply::set_bank_name(const char* value) {
  set_has_bank_name();
  if (bank_name_ == &::google::protobuf::internal::kEmptyString) {
    bank_name_ = new ::std::string;
  }
  bank_name_->assign(value);
}
inline void GetAgentInfoReply::set_bank_name(const char* value, size_t size) {
  set_has_bank_name();
  if (bank_name_ == &::google::protobuf::internal::kEmptyString) {
    bank_name_ = new ::std::string;
  }
  bank_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetAgentInfoReply::mutable_bank_name() {
  set_has_bank_name();
  if (bank_name_ == &::google::protobuf::internal::kEmptyString) {
    bank_name_ = new ::std::string;
  }
  return bank_name_;
}
inline ::std::string* GetAgentInfoReply::release_bank_name() {
  clear_has_bank_name();
  if (bank_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bank_name_;
    bank_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetAgentInfoReply::set_allocated_bank_name(::std::string* bank_name) {
  if (bank_name_ != &::google::protobuf::internal::kEmptyString) {
    delete bank_name_;
  }
  if (bank_name) {
    set_has_bank_name();
    bank_name_ = bank_name;
  } else {
    clear_has_bank_name();
    bank_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string bank_acc = 13;
inline bool GetAgentInfoReply::has_bank_acc() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void GetAgentInfoReply::set_has_bank_acc() {
  _has_bits_[0] |= 0x00001000u;
}
inline void GetAgentInfoReply::clear_has_bank_acc() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void GetAgentInfoReply::clear_bank_acc() {
  if (bank_acc_ != &::google::protobuf::internal::kEmptyString) {
    bank_acc_->clear();
  }
  clear_has_bank_acc();
}
inline const ::std::string& GetAgentInfoReply::bank_acc() const {
  return *bank_acc_;
}
inline void GetAgentInfoReply::set_bank_acc(const ::std::string& value) {
  set_has_bank_acc();
  if (bank_acc_ == &::google::protobuf::internal::kEmptyString) {
    bank_acc_ = new ::std::string;
  }
  bank_acc_->assign(value);
}
inline void GetAgentInfoReply::set_bank_acc(const char* value) {
  set_has_bank_acc();
  if (bank_acc_ == &::google::protobuf::internal::kEmptyString) {
    bank_acc_ = new ::std::string;
  }
  bank_acc_->assign(value);
}
inline void GetAgentInfoReply::set_bank_acc(const char* value, size_t size) {
  set_has_bank_acc();
  if (bank_acc_ == &::google::protobuf::internal::kEmptyString) {
    bank_acc_ = new ::std::string;
  }
  bank_acc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetAgentInfoReply::mutable_bank_acc() {
  set_has_bank_acc();
  if (bank_acc_ == &::google::protobuf::internal::kEmptyString) {
    bank_acc_ = new ::std::string;
  }
  return bank_acc_;
}
inline ::std::string* GetAgentInfoReply::release_bank_acc() {
  clear_has_bank_acc();
  if (bank_acc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bank_acc_;
    bank_acc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetAgentInfoReply::set_allocated_bank_acc(::std::string* bank_acc) {
  if (bank_acc_ != &::google::protobuf::internal::kEmptyString) {
    delete bank_acc_;
  }
  if (bank_acc) {
    set_has_bank_acc();
    bank_acc_ = bank_acc;
  } else {
    clear_has_bank_acc();
    bank_acc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string bank_code = 14;
inline bool GetAgentInfoReply::has_bank_code() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void GetAgentInfoReply::set_has_bank_code() {
  _has_bits_[0] |= 0x00002000u;
}
inline void GetAgentInfoReply::clear_has_bank_code() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void GetAgentInfoReply::clear_bank_code() {
  if (bank_code_ != &::google::protobuf::internal::kEmptyString) {
    bank_code_->clear();
  }
  clear_has_bank_code();
}
inline const ::std::string& GetAgentInfoReply::bank_code() const {
  return *bank_code_;
}
inline void GetAgentInfoReply::set_bank_code(const ::std::string& value) {
  set_has_bank_code();
  if (bank_code_ == &::google::protobuf::internal::kEmptyString) {
    bank_code_ = new ::std::string;
  }
  bank_code_->assign(value);
}
inline void GetAgentInfoReply::set_bank_code(const char* value) {
  set_has_bank_code();
  if (bank_code_ == &::google::protobuf::internal::kEmptyString) {
    bank_code_ = new ::std::string;
  }
  bank_code_->assign(value);
}
inline void GetAgentInfoReply::set_bank_code(const char* value, size_t size) {
  set_has_bank_code();
  if (bank_code_ == &::google::protobuf::internal::kEmptyString) {
    bank_code_ = new ::std::string;
  }
  bank_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetAgentInfoReply::mutable_bank_code() {
  set_has_bank_code();
  if (bank_code_ == &::google::protobuf::internal::kEmptyString) {
    bank_code_ = new ::std::string;
  }
  return bank_code_;
}
inline ::std::string* GetAgentInfoReply::release_bank_code() {
  clear_has_bank_code();
  if (bank_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bank_code_;
    bank_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetAgentInfoReply::set_allocated_bank_code(::std::string* bank_code) {
  if (bank_code_ != &::google::protobuf::internal::kEmptyString) {
    delete bank_code_;
  }
  if (bank_code) {
    set_has_bank_code();
    bank_code_ = bank_code;
  } else {
    clear_has_bank_code();
    bank_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 agent_id = 15;
inline bool GetAgentInfoReply::has_agent_id() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void GetAgentInfoReply::set_has_agent_id() {
  _has_bits_[0] |= 0x00004000u;
}
inline void GetAgentInfoReply::clear_has_agent_id() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void GetAgentInfoReply::clear_agent_id() {
  agent_id_ = GOOGLE_ULONGLONG(0);
  clear_has_agent_id();
}
inline ::google::protobuf::uint64 GetAgentInfoReply::agent_id() const {
  return agent_id_;
}
inline void GetAgentInfoReply::set_agent_id(::google::protobuf::uint64 value) {
  set_has_agent_id();
  agent_id_ = value;
}

// optional uint64 createdDate = 16;
inline bool GetAgentInfoReply::has_createddate() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void GetAgentInfoReply::set_has_createddate() {
  _has_bits_[0] |= 0x00008000u;
}
inline void GetAgentInfoReply::clear_has_createddate() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void GetAgentInfoReply::clear_createddate() {
  createddate_ = GOOGLE_ULONGLONG(0);
  clear_has_createddate();
}
inline ::google::protobuf::uint64 GetAgentInfoReply::createddate() const {
  return createddate_;
}
inline void GetAgentInfoReply::set_createddate(::google::protobuf::uint64 value) {
  set_has_createddate();
  createddate_ = value;
}

// -------------------------------------------------------------------

// Register

// optional string name = 1;
inline bool Register::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Register::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Register::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Register::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Register::name() const {
  return *name_;
}
inline void Register::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Register::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Register::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Register::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Register::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Register::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string id_card = 2;
inline bool Register::has_id_card() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Register::set_has_id_card() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Register::clear_has_id_card() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Register::clear_id_card() {
  if (id_card_ != &::google::protobuf::internal::kEmptyString) {
    id_card_->clear();
  }
  clear_has_id_card();
}
inline const ::std::string& Register::id_card() const {
  return *id_card_;
}
inline void Register::set_id_card(const ::std::string& value) {
  set_has_id_card();
  if (id_card_ == &::google::protobuf::internal::kEmptyString) {
    id_card_ = new ::std::string;
  }
  id_card_->assign(value);
}
inline void Register::set_id_card(const char* value) {
  set_has_id_card();
  if (id_card_ == &::google::protobuf::internal::kEmptyString) {
    id_card_ = new ::std::string;
  }
  id_card_->assign(value);
}
inline void Register::set_id_card(const char* value, size_t size) {
  set_has_id_card();
  if (id_card_ == &::google::protobuf::internal::kEmptyString) {
    id_card_ = new ::std::string;
  }
  id_card_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Register::mutable_id_card() {
  set_has_id_card();
  if (id_card_ == &::google::protobuf::internal::kEmptyString) {
    id_card_ = new ::std::string;
  }
  return id_card_;
}
inline ::std::string* Register::release_id_card() {
  clear_has_id_card();
  if (id_card_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_card_;
    id_card_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Register::set_allocated_id_card(::std::string* id_card) {
  if (id_card_ != &::google::protobuf::internal::kEmptyString) {
    delete id_card_;
  }
  if (id_card) {
    set_has_id_card();
    id_card_ = id_card;
  } else {
    clear_has_id_card();
    id_card_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string pin = 3;
inline bool Register::has_pin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Register::set_has_pin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Register::clear_has_pin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Register::clear_pin() {
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    pin_->clear();
  }
  clear_has_pin();
}
inline const ::std::string& Register::pin() const {
  return *pin_;
}
inline void Register::set_pin(const ::std::string& value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void Register::set_pin(const char* value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void Register::set_pin(const char* value, size_t size) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Register::mutable_pin() {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  return pin_;
}
inline ::std::string* Register::release_pin() {
  clear_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pin_;
    pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Register::set_allocated_pin(::std::string* pin) {
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    delete pin_;
  }
  if (pin) {
    set_has_pin();
    pin_ = pin;
  } else {
    clear_has_pin();
    pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string arr_group = 4;
inline bool Register::has_arr_group() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Register::set_has_arr_group() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Register::clear_has_arr_group() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Register::clear_arr_group() {
  if (arr_group_ != &::google::protobuf::internal::kEmptyString) {
    arr_group_->clear();
  }
  clear_has_arr_group();
}
inline const ::std::string& Register::arr_group() const {
  return *arr_group_;
}
inline void Register::set_arr_group(const ::std::string& value) {
  set_has_arr_group();
  if (arr_group_ == &::google::protobuf::internal::kEmptyString) {
    arr_group_ = new ::std::string;
  }
  arr_group_->assign(value);
}
inline void Register::set_arr_group(const char* value) {
  set_has_arr_group();
  if (arr_group_ == &::google::protobuf::internal::kEmptyString) {
    arr_group_ = new ::std::string;
  }
  arr_group_->assign(value);
}
inline void Register::set_arr_group(const char* value, size_t size) {
  set_has_arr_group();
  if (arr_group_ == &::google::protobuf::internal::kEmptyString) {
    arr_group_ = new ::std::string;
  }
  arr_group_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Register::mutable_arr_group() {
  set_has_arr_group();
  if (arr_group_ == &::google::protobuf::internal::kEmptyString) {
    arr_group_ = new ::std::string;
  }
  return arr_group_;
}
inline ::std::string* Register::release_arr_group() {
  clear_has_arr_group();
  if (arr_group_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = arr_group_;
    arr_group_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Register::set_allocated_arr_group(::std::string* arr_group) {
  if (arr_group_ != &::google::protobuf::internal::kEmptyString) {
    delete arr_group_;
  }
  if (arr_group) {
    set_has_arr_group();
    arr_group_ = arr_group;
  } else {
    clear_has_arr_group();
    arr_group_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string arr_capset = 5;
inline bool Register::has_arr_capset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Register::set_has_arr_capset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Register::clear_has_arr_capset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Register::clear_arr_capset() {
  if (arr_capset_ != &::google::protobuf::internal::kEmptyString) {
    arr_capset_->clear();
  }
  clear_has_arr_capset();
}
inline const ::std::string& Register::arr_capset() const {
  return *arr_capset_;
}
inline void Register::set_arr_capset(const ::std::string& value) {
  set_has_arr_capset();
  if (arr_capset_ == &::google::protobuf::internal::kEmptyString) {
    arr_capset_ = new ::std::string;
  }
  arr_capset_->assign(value);
}
inline void Register::set_arr_capset(const char* value) {
  set_has_arr_capset();
  if (arr_capset_ == &::google::protobuf::internal::kEmptyString) {
    arr_capset_ = new ::std::string;
  }
  arr_capset_->assign(value);
}
inline void Register::set_arr_capset(const char* value, size_t size) {
  set_has_arr_capset();
  if (arr_capset_ == &::google::protobuf::internal::kEmptyString) {
    arr_capset_ = new ::std::string;
  }
  arr_capset_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Register::mutable_arr_capset() {
  set_has_arr_capset();
  if (arr_capset_ == &::google::protobuf::internal::kEmptyString) {
    arr_capset_ = new ::std::string;
  }
  return arr_capset_;
}
inline ::std::string* Register::release_arr_capset() {
  clear_has_arr_capset();
  if (arr_capset_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = arr_capset_;
    arr_capset_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Register::set_allocated_arr_capset(::std::string* arr_capset) {
  if (arr_capset_ != &::google::protobuf::internal::kEmptyString) {
    delete arr_capset_;
  }
  if (arr_capset) {
    set_has_arr_capset();
    arr_capset_ = arr_capset;
  } else {
    clear_has_arr_capset();
    arr_capset_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string upper_limit = 6;
inline bool Register::has_upper_limit() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Register::set_has_upper_limit() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Register::clear_has_upper_limit() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Register::clear_upper_limit() {
  if (upper_limit_ != &::google::protobuf::internal::kEmptyString) {
    upper_limit_->clear();
  }
  clear_has_upper_limit();
}
inline const ::std::string& Register::upper_limit() const {
  return *upper_limit_;
}
inline void Register::set_upper_limit(const ::std::string& value) {
  set_has_upper_limit();
  if (upper_limit_ == &::google::protobuf::internal::kEmptyString) {
    upper_limit_ = new ::std::string;
  }
  upper_limit_->assign(value);
}
inline void Register::set_upper_limit(const char* value) {
  set_has_upper_limit();
  if (upper_limit_ == &::google::protobuf::internal::kEmptyString) {
    upper_limit_ = new ::std::string;
  }
  upper_limit_->assign(value);
}
inline void Register::set_upper_limit(const char* value, size_t size) {
  set_has_upper_limit();
  if (upper_limit_ == &::google::protobuf::internal::kEmptyString) {
    upper_limit_ = new ::std::string;
  }
  upper_limit_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Register::mutable_upper_limit() {
  set_has_upper_limit();
  if (upper_limit_ == &::google::protobuf::internal::kEmptyString) {
    upper_limit_ = new ::std::string;
  }
  return upper_limit_;
}
inline ::std::string* Register::release_upper_limit() {
  clear_has_upper_limit();
  if (upper_limit_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = upper_limit_;
    upper_limit_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Register::set_allocated_upper_limit(::std::string* upper_limit) {
  if (upper_limit_ != &::google::protobuf::internal::kEmptyString) {
    delete upper_limit_;
  }
  if (upper_limit) {
    set_has_upper_limit();
    upper_limit_ = upper_limit;
  } else {
    clear_has_upper_limit();
    upper_limit_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string email = 7;
inline bool Register::has_email() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Register::set_has_email() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Register::clear_has_email() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Register::clear_email() {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& Register::email() const {
  return *email_;
}
inline void Register::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void Register::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void Register::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Register::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  return email_;
}
inline ::std::string* Register::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Register::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string question = 8;
inline bool Register::has_question() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Register::set_has_question() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Register::clear_has_question() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Register::clear_question() {
  if (question_ != &::google::protobuf::internal::kEmptyString) {
    question_->clear();
  }
  clear_has_question();
}
inline const ::std::string& Register::question() const {
  return *question_;
}
inline void Register::set_question(const ::std::string& value) {
  set_has_question();
  if (question_ == &::google::protobuf::internal::kEmptyString) {
    question_ = new ::std::string;
  }
  question_->assign(value);
}
inline void Register::set_question(const char* value) {
  set_has_question();
  if (question_ == &::google::protobuf::internal::kEmptyString) {
    question_ = new ::std::string;
  }
  question_->assign(value);
}
inline void Register::set_question(const char* value, size_t size) {
  set_has_question();
  if (question_ == &::google::protobuf::internal::kEmptyString) {
    question_ = new ::std::string;
  }
  question_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Register::mutable_question() {
  set_has_question();
  if (question_ == &::google::protobuf::internal::kEmptyString) {
    question_ = new ::std::string;
  }
  return question_;
}
inline ::std::string* Register::release_question() {
  clear_has_question();
  if (question_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = question_;
    question_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Register::set_allocated_question(::std::string* question) {
  if (question_ != &::google::protobuf::internal::kEmptyString) {
    delete question_;
  }
  if (question) {
    set_has_question();
    question_ = question;
  } else {
    clear_has_question();
    question_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string answer = 9;
inline bool Register::has_answer() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Register::set_has_answer() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Register::clear_has_answer() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Register::clear_answer() {
  if (answer_ != &::google::protobuf::internal::kEmptyString) {
    answer_->clear();
  }
  clear_has_answer();
}
inline const ::std::string& Register::answer() const {
  return *answer_;
}
inline void Register::set_answer(const ::std::string& value) {
  set_has_answer();
  if (answer_ == &::google::protobuf::internal::kEmptyString) {
    answer_ = new ::std::string;
  }
  answer_->assign(value);
}
inline void Register::set_answer(const char* value) {
  set_has_answer();
  if (answer_ == &::google::protobuf::internal::kEmptyString) {
    answer_ = new ::std::string;
  }
  answer_->assign(value);
}
inline void Register::set_answer(const char* value, size_t size) {
  set_has_answer();
  if (answer_ == &::google::protobuf::internal::kEmptyString) {
    answer_ = new ::std::string;
  }
  answer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Register::mutable_answer() {
  set_has_answer();
  if (answer_ == &::google::protobuf::internal::kEmptyString) {
    answer_ = new ::std::string;
  }
  return answer_;
}
inline ::std::string* Register::release_answer() {
  clear_has_answer();
  if (answer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = answer_;
    answer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Register::set_allocated_answer(::std::string* answer) {
  if (answer_ != &::google::protobuf::internal::kEmptyString) {
    delete answer_;
  }
  if (answer) {
    set_has_answer();
    answer_ = answer;
  } else {
    clear_has_answer();
    answer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string channel = 10;
inline bool Register::has_channel() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Register::set_has_channel() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Register::clear_has_channel() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Register::clear_channel() {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    channel_->clear();
  }
  clear_has_channel();
}
inline const ::std::string& Register::channel() const {
  return *channel_;
}
inline void Register::set_channel(const ::std::string& value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void Register::set_channel(const char* value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void Register::set_channel(const char* value, size_t size) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Register::mutable_channel() {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  return channel_;
}
inline ::std::string* Register::release_channel() {
  clear_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_;
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Register::set_allocated_channel(::std::string* channel) {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_;
  }
  if (channel) {
    set_has_channel();
    channel_ = channel;
  } else {
    clear_has_channel();
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string dateOfBirth = 11;
inline bool Register::has_dateofbirth() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Register::set_has_dateofbirth() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Register::clear_has_dateofbirth() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Register::clear_dateofbirth() {
  if (dateofbirth_ != &::google::protobuf::internal::kEmptyString) {
    dateofbirth_->clear();
  }
  clear_has_dateofbirth();
}
inline const ::std::string& Register::dateofbirth() const {
  return *dateofbirth_;
}
inline void Register::set_dateofbirth(const ::std::string& value) {
  set_has_dateofbirth();
  if (dateofbirth_ == &::google::protobuf::internal::kEmptyString) {
    dateofbirth_ = new ::std::string;
  }
  dateofbirth_->assign(value);
}
inline void Register::set_dateofbirth(const char* value) {
  set_has_dateofbirth();
  if (dateofbirth_ == &::google::protobuf::internal::kEmptyString) {
    dateofbirth_ = new ::std::string;
  }
  dateofbirth_->assign(value);
}
inline void Register::set_dateofbirth(const char* value, size_t size) {
  set_has_dateofbirth();
  if (dateofbirth_ == &::google::protobuf::internal::kEmptyString) {
    dateofbirth_ = new ::std::string;
  }
  dateofbirth_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Register::mutable_dateofbirth() {
  set_has_dateofbirth();
  if (dateofbirth_ == &::google::protobuf::internal::kEmptyString) {
    dateofbirth_ = new ::std::string;
  }
  return dateofbirth_;
}
inline ::std::string* Register::release_dateofbirth() {
  clear_has_dateofbirth();
  if (dateofbirth_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dateofbirth_;
    dateofbirth_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Register::set_allocated_dateofbirth(::std::string* dateofbirth) {
  if (dateofbirth_ != &::google::protobuf::internal::kEmptyString) {
    delete dateofbirth_;
  }
  if (dateofbirth) {
    set_has_dateofbirth();
    dateofbirth_ = dateofbirth;
  } else {
    clear_has_dateofbirth();
    dateofbirth_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string address = 12;
inline bool Register::has_address() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Register::set_has_address() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Register::clear_has_address() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Register::clear_address() {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& Register::address() const {
  return *address_;
}
inline void Register::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void Register::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void Register::set_address(const char* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Register::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  return address_;
}
inline ::std::string* Register::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Register::set_allocated_address(::std::string* address) {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    delete address_;
  }
  if (address) {
    set_has_address();
    address_ = address;
  } else {
    clear_has_address();
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .com.mservice.momo.msg.keyValuePair kvps = 13;
inline int Register::kvps_size() const {
  return kvps_.size();
}
inline void Register::clear_kvps() {
  kvps_.Clear();
}
inline const ::com::mservice::momo::msg::keyValuePair& Register::kvps(int index) const {
  return kvps_.Get(index);
}
inline ::com::mservice::momo::msg::keyValuePair* Register::mutable_kvps(int index) {
  return kvps_.Mutable(index);
}
inline ::com::mservice::momo::msg::keyValuePair* Register::add_kvps() {
  return kvps_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >&
Register::kvps() const {
  return kvps_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >*
Register::mutable_kvps() {
  return &kvps_;
}

// -------------------------------------------------------------------

// LogIn

// optional uint32 number = 1;
inline bool LogIn::has_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogIn::set_has_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogIn::clear_has_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogIn::clear_number() {
  number_ = 0u;
  clear_has_number();
}
inline ::google::protobuf::uint32 LogIn::number() const {
  return number_;
}
inline void LogIn::set_number(::google::protobuf::uint32 value) {
  set_has_number();
  number_ = value;
}

// optional string mpin = 2;
inline bool LogIn::has_mpin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogIn::set_has_mpin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogIn::clear_has_mpin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogIn::clear_mpin() {
  if (mpin_ != &::google::protobuf::internal::kEmptyString) {
    mpin_->clear();
  }
  clear_has_mpin();
}
inline const ::std::string& LogIn::mpin() const {
  return *mpin_;
}
inline void LogIn::set_mpin(const ::std::string& value) {
  set_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    mpin_ = new ::std::string;
  }
  mpin_->assign(value);
}
inline void LogIn::set_mpin(const char* value) {
  set_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    mpin_ = new ::std::string;
  }
  mpin_->assign(value);
}
inline void LogIn::set_mpin(const char* value, size_t size) {
  set_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    mpin_ = new ::std::string;
  }
  mpin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogIn::mutable_mpin() {
  set_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    mpin_ = new ::std::string;
  }
  return mpin_;
}
inline ::std::string* LogIn::release_mpin() {
  clear_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mpin_;
    mpin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LogIn::set_allocated_mpin(::std::string* mpin) {
  if (mpin_ != &::google::protobuf::internal::kEmptyString) {
    delete mpin_;
  }
  if (mpin) {
    set_has_mpin();
    mpin_ = mpin;
  } else {
    clear_has_mpin();
    mpin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GetBillInfo

// optional string mpin = 1;
inline bool GetBillInfo::has_mpin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetBillInfo::set_has_mpin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetBillInfo::clear_has_mpin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetBillInfo::clear_mpin() {
  if (mpin_ != &::google::protobuf::internal::kEmptyString) {
    mpin_->clear();
  }
  clear_has_mpin();
}
inline const ::std::string& GetBillInfo::mpin() const {
  return *mpin_;
}
inline void GetBillInfo::set_mpin(const ::std::string& value) {
  set_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    mpin_ = new ::std::string;
  }
  mpin_->assign(value);
}
inline void GetBillInfo::set_mpin(const char* value) {
  set_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    mpin_ = new ::std::string;
  }
  mpin_->assign(value);
}
inline void GetBillInfo::set_mpin(const char* value, size_t size) {
  set_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    mpin_ = new ::std::string;
  }
  mpin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetBillInfo::mutable_mpin() {
  set_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    mpin_ = new ::std::string;
  }
  return mpin_;
}
inline ::std::string* GetBillInfo::release_mpin() {
  clear_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mpin_;
    mpin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetBillInfo::set_allocated_mpin(::std::string* mpin) {
  if (mpin_ != &::google::protobuf::internal::kEmptyString) {
    delete mpin_;
  }
  if (mpin) {
    set_has_mpin();
    mpin_ = mpin;
  } else {
    clear_has_mpin();
    mpin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string provider_id = 2;
inline bool GetBillInfo::has_provider_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetBillInfo::set_has_provider_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetBillInfo::clear_has_provider_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetBillInfo::clear_provider_id() {
  if (provider_id_ != &::google::protobuf::internal::kEmptyString) {
    provider_id_->clear();
  }
  clear_has_provider_id();
}
inline const ::std::string& GetBillInfo::provider_id() const {
  return *provider_id_;
}
inline void GetBillInfo::set_provider_id(const ::std::string& value) {
  set_has_provider_id();
  if (provider_id_ == &::google::protobuf::internal::kEmptyString) {
    provider_id_ = new ::std::string;
  }
  provider_id_->assign(value);
}
inline void GetBillInfo::set_provider_id(const char* value) {
  set_has_provider_id();
  if (provider_id_ == &::google::protobuf::internal::kEmptyString) {
    provider_id_ = new ::std::string;
  }
  provider_id_->assign(value);
}
inline void GetBillInfo::set_provider_id(const char* value, size_t size) {
  set_has_provider_id();
  if (provider_id_ == &::google::protobuf::internal::kEmptyString) {
    provider_id_ = new ::std::string;
  }
  provider_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetBillInfo::mutable_provider_id() {
  set_has_provider_id();
  if (provider_id_ == &::google::protobuf::internal::kEmptyString) {
    provider_id_ = new ::std::string;
  }
  return provider_id_;
}
inline ::std::string* GetBillInfo::release_provider_id() {
  clear_has_provider_id();
  if (provider_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = provider_id_;
    provider_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetBillInfo::set_allocated_provider_id(::std::string* provider_id) {
  if (provider_id_ != &::google::protobuf::internal::kEmptyString) {
    delete provider_id_;
  }
  if (provider_id) {
    set_has_provider_id();
    provider_id_ = provider_id;
  } else {
    clear_has_provider_id();
    provider_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string bill_id = 3;
inline bool GetBillInfo::has_bill_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetBillInfo::set_has_bill_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetBillInfo::clear_has_bill_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetBillInfo::clear_bill_id() {
  if (bill_id_ != &::google::protobuf::internal::kEmptyString) {
    bill_id_->clear();
  }
  clear_has_bill_id();
}
inline const ::std::string& GetBillInfo::bill_id() const {
  return *bill_id_;
}
inline void GetBillInfo::set_bill_id(const ::std::string& value) {
  set_has_bill_id();
  if (bill_id_ == &::google::protobuf::internal::kEmptyString) {
    bill_id_ = new ::std::string;
  }
  bill_id_->assign(value);
}
inline void GetBillInfo::set_bill_id(const char* value) {
  set_has_bill_id();
  if (bill_id_ == &::google::protobuf::internal::kEmptyString) {
    bill_id_ = new ::std::string;
  }
  bill_id_->assign(value);
}
inline void GetBillInfo::set_bill_id(const char* value, size_t size) {
  set_has_bill_id();
  if (bill_id_ == &::google::protobuf::internal::kEmptyString) {
    bill_id_ = new ::std::string;
  }
  bill_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetBillInfo::mutable_bill_id() {
  set_has_bill_id();
  if (bill_id_ == &::google::protobuf::internal::kEmptyString) {
    bill_id_ = new ::std::string;
  }
  return bill_id_;
}
inline ::std::string* GetBillInfo::release_bill_id() {
  clear_has_bill_id();
  if (bill_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bill_id_;
    bill_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetBillInfo::set_allocated_bill_id(::std::string* bill_id) {
  if (bill_id_ != &::google::protobuf::internal::kEmptyString) {
    delete bill_id_;
  }
  if (bill_id) {
    set_has_bill_id();
    bill_id_ = bill_id;
  } else {
    clear_has_bill_id();
    bill_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AgentInfo

// optional string number = 1;
inline bool AgentInfo::has_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AgentInfo::set_has_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AgentInfo::clear_has_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AgentInfo::clear_number() {
  if (number_ != &::google::protobuf::internal::kEmptyString) {
    number_->clear();
  }
  clear_has_number();
}
inline const ::std::string& AgentInfo::number() const {
  return *number_;
}
inline void AgentInfo::set_number(const ::std::string& value) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  number_->assign(value);
}
inline void AgentInfo::set_number(const char* value) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  number_->assign(value);
}
inline void AgentInfo::set_number(const char* value, size_t size) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  number_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentInfo::mutable_number() {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  return number_;
}
inline ::std::string* AgentInfo::release_number() {
  clear_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = number_;
    number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AgentInfo::set_allocated_number(::std::string* number) {
  if (number_ != &::google::protobuf::internal::kEmptyString) {
    delete number_;
  }
  if (number) {
    set_has_number();
    number_ = number;
  } else {
    clear_has_number();
    number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// BankOut

// optional string mpin = 1;
inline bool BankOut::has_mpin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BankOut::set_has_mpin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BankOut::clear_has_mpin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BankOut::clear_mpin() {
  if (mpin_ != &::google::protobuf::internal::kEmptyString) {
    mpin_->clear();
  }
  clear_has_mpin();
}
inline const ::std::string& BankOut::mpin() const {
  return *mpin_;
}
inline void BankOut::set_mpin(const ::std::string& value) {
  set_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    mpin_ = new ::std::string;
  }
  mpin_->assign(value);
}
inline void BankOut::set_mpin(const char* value) {
  set_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    mpin_ = new ::std::string;
  }
  mpin_->assign(value);
}
inline void BankOut::set_mpin(const char* value, size_t size) {
  set_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    mpin_ = new ::std::string;
  }
  mpin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BankOut::mutable_mpin() {
  set_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    mpin_ = new ::std::string;
  }
  return mpin_;
}
inline ::std::string* BankOut::release_mpin() {
  clear_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mpin_;
    mpin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BankOut::set_allocated_mpin(::std::string* mpin) {
  if (mpin_ != &::google::protobuf::internal::kEmptyString) {
    delete mpin_;
  }
  if (mpin) {
    set_has_mpin();
    mpin_ = mpin;
  } else {
    clear_has_mpin();
    mpin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 amount = 2;
inline bool BankOut::has_amount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BankOut::set_has_amount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BankOut::clear_has_amount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BankOut::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 BankOut::amount() const {
  return amount_;
}
inline void BankOut::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
}

// optional string bank_code = 3;
inline bool BankOut::has_bank_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BankOut::set_has_bank_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BankOut::clear_has_bank_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BankOut::clear_bank_code() {
  if (bank_code_ != &::google::protobuf::internal::kEmptyString) {
    bank_code_->clear();
  }
  clear_has_bank_code();
}
inline const ::std::string& BankOut::bank_code() const {
  return *bank_code_;
}
inline void BankOut::set_bank_code(const ::std::string& value) {
  set_has_bank_code();
  if (bank_code_ == &::google::protobuf::internal::kEmptyString) {
    bank_code_ = new ::std::string;
  }
  bank_code_->assign(value);
}
inline void BankOut::set_bank_code(const char* value) {
  set_has_bank_code();
  if (bank_code_ == &::google::protobuf::internal::kEmptyString) {
    bank_code_ = new ::std::string;
  }
  bank_code_->assign(value);
}
inline void BankOut::set_bank_code(const char* value, size_t size) {
  set_has_bank_code();
  if (bank_code_ == &::google::protobuf::internal::kEmptyString) {
    bank_code_ = new ::std::string;
  }
  bank_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BankOut::mutable_bank_code() {
  set_has_bank_code();
  if (bank_code_ == &::google::protobuf::internal::kEmptyString) {
    bank_code_ = new ::std::string;
  }
  return bank_code_;
}
inline ::std::string* BankOut::release_bank_code() {
  clear_has_bank_code();
  if (bank_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bank_code_;
    bank_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BankOut::set_allocated_bank_code(::std::string* bank_code) {
  if (bank_code_ != &::google::protobuf::internal::kEmptyString) {
    delete bank_code_;
  }
  if (bank_code) {
    set_has_bank_code();
    bank_code_ = bank_code;
  } else {
    clear_has_bank_code();
    bank_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string channel = 4;
inline bool BankOut::has_channel() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BankOut::set_has_channel() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BankOut::clear_has_channel() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BankOut::clear_channel() {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    channel_->clear();
  }
  clear_has_channel();
}
inline const ::std::string& BankOut::channel() const {
  return *channel_;
}
inline void BankOut::set_channel(const ::std::string& value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void BankOut::set_channel(const char* value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void BankOut::set_channel(const char* value, size_t size) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BankOut::mutable_channel() {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  return channel_;
}
inline ::std::string* BankOut::release_channel() {
  clear_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_;
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BankOut::set_allocated_channel(::std::string* channel) {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_;
  }
  if (channel) {
    set_has_channel();
    channel_ = channel;
  } else {
    clear_has_channel();
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .com.mservice.momo.msg.keyValuePair kvps = 5;
inline int BankOut::kvps_size() const {
  return kvps_.size();
}
inline void BankOut::clear_kvps() {
  kvps_.Clear();
}
inline const ::com::mservice::momo::msg::keyValuePair& BankOut::kvps(int index) const {
  return kvps_.Get(index);
}
inline ::com::mservice::momo::msg::keyValuePair* BankOut::mutable_kvps(int index) {
  return kvps_.Mutable(index);
}
inline ::com::mservice::momo::msg::keyValuePair* BankOut::add_kvps() {
  return kvps_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >&
BankOut::kvps() const {
  return kvps_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >*
BankOut::mutable_kvps() {
  return &kvps_;
}

// -------------------------------------------------------------------

// TopUp

// optional uint32 from_number = 1;
inline bool TopUp::has_from_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TopUp::set_has_from_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TopUp::clear_has_from_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TopUp::clear_from_number() {
  from_number_ = 0u;
  clear_has_from_number();
}
inline ::google::protobuf::uint32 TopUp::from_number() const {
  return from_number_;
}
inline void TopUp::set_from_number(::google::protobuf::uint32 value) {
  set_has_from_number();
  from_number_ = value;
}

// optional string mpin = 2;
inline bool TopUp::has_mpin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TopUp::set_has_mpin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TopUp::clear_has_mpin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TopUp::clear_mpin() {
  if (mpin_ != &::google::protobuf::internal::kEmptyString) {
    mpin_->clear();
  }
  clear_has_mpin();
}
inline const ::std::string& TopUp::mpin() const {
  return *mpin_;
}
inline void TopUp::set_mpin(const ::std::string& value) {
  set_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    mpin_ = new ::std::string;
  }
  mpin_->assign(value);
}
inline void TopUp::set_mpin(const char* value) {
  set_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    mpin_ = new ::std::string;
  }
  mpin_->assign(value);
}
inline void TopUp::set_mpin(const char* value, size_t size) {
  set_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    mpin_ = new ::std::string;
  }
  mpin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TopUp::mutable_mpin() {
  set_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    mpin_ = new ::std::string;
  }
  return mpin_;
}
inline ::std::string* TopUp::release_mpin() {
  clear_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mpin_;
    mpin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TopUp::set_allocated_mpin(::std::string* mpin) {
  if (mpin_ != &::google::protobuf::internal::kEmptyString) {
    delete mpin_;
  }
  if (mpin) {
    set_has_mpin();
    mpin_ = mpin;
  } else {
    clear_has_mpin();
    mpin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 to_number = 3;
inline bool TopUp::has_to_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TopUp::set_has_to_number() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TopUp::clear_has_to_number() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TopUp::clear_to_number() {
  to_number_ = 0u;
  clear_has_to_number();
}
inline ::google::protobuf::uint32 TopUp::to_number() const {
  return to_number_;
}
inline void TopUp::set_to_number(::google::protobuf::uint32 value) {
  set_has_to_number();
  to_number_ = value;
}

// optional uint64 amount = 4;
inline bool TopUp::has_amount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TopUp::set_has_amount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TopUp::clear_has_amount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TopUp::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 TopUp::amount() const {
  return amount_;
}
inline void TopUp::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
}

// optional string channel = 5;
inline bool TopUp::has_channel() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TopUp::set_has_channel() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TopUp::clear_has_channel() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TopUp::clear_channel() {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    channel_->clear();
  }
  clear_has_channel();
}
inline const ::std::string& TopUp::channel() const {
  return *channel_;
}
inline void TopUp::set_channel(const ::std::string& value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void TopUp::set_channel(const char* value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void TopUp::set_channel(const char* value, size_t size) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TopUp::mutable_channel() {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  return channel_;
}
inline ::std::string* TopUp::release_channel() {
  clear_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_;
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TopUp::set_allocated_channel(::std::string* channel) {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_;
  }
  if (channel) {
    set_has_channel();
    channel_ = channel;
  } else {
    clear_has_channel();
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .com.mservice.momo.msg.keyValuePair keyValuePairs = 6;
inline int TopUp::keyvaluepairs_size() const {
  return keyvaluepairs_.size();
}
inline void TopUp::clear_keyvaluepairs() {
  keyvaluepairs_.Clear();
}
inline const ::com::mservice::momo::msg::keyValuePair& TopUp::keyvaluepairs(int index) const {
  return keyvaluepairs_.Get(index);
}
inline ::com::mservice::momo::msg::keyValuePair* TopUp::mutable_keyvaluepairs(int index) {
  return keyvaluepairs_.Mutable(index);
}
inline ::com::mservice::momo::msg::keyValuePair* TopUp::add_keyvaluepairs() {
  return keyvaluepairs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >&
TopUp::keyvaluepairs() const {
  return keyvaluepairs_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >*
TopUp::mutable_keyvaluepairs() {
  return &keyvaluepairs_;
}

// -------------------------------------------------------------------

// TopUpString

// optional string from_number = 1;
inline bool TopUpString::has_from_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TopUpString::set_has_from_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TopUpString::clear_has_from_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TopUpString::clear_from_number() {
  if (from_number_ != &::google::protobuf::internal::kEmptyString) {
    from_number_->clear();
  }
  clear_has_from_number();
}
inline const ::std::string& TopUpString::from_number() const {
  return *from_number_;
}
inline void TopUpString::set_from_number(const ::std::string& value) {
  set_has_from_number();
  if (from_number_ == &::google::protobuf::internal::kEmptyString) {
    from_number_ = new ::std::string;
  }
  from_number_->assign(value);
}
inline void TopUpString::set_from_number(const char* value) {
  set_has_from_number();
  if (from_number_ == &::google::protobuf::internal::kEmptyString) {
    from_number_ = new ::std::string;
  }
  from_number_->assign(value);
}
inline void TopUpString::set_from_number(const char* value, size_t size) {
  set_has_from_number();
  if (from_number_ == &::google::protobuf::internal::kEmptyString) {
    from_number_ = new ::std::string;
  }
  from_number_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TopUpString::mutable_from_number() {
  set_has_from_number();
  if (from_number_ == &::google::protobuf::internal::kEmptyString) {
    from_number_ = new ::std::string;
  }
  return from_number_;
}
inline ::std::string* TopUpString::release_from_number() {
  clear_has_from_number();
  if (from_number_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = from_number_;
    from_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TopUpString::set_allocated_from_number(::std::string* from_number) {
  if (from_number_ != &::google::protobuf::internal::kEmptyString) {
    delete from_number_;
  }
  if (from_number) {
    set_has_from_number();
    from_number_ = from_number;
  } else {
    clear_has_from_number();
    from_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mpin = 2;
inline bool TopUpString::has_mpin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TopUpString::set_has_mpin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TopUpString::clear_has_mpin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TopUpString::clear_mpin() {
  if (mpin_ != &::google::protobuf::internal::kEmptyString) {
    mpin_->clear();
  }
  clear_has_mpin();
}
inline const ::std::string& TopUpString::mpin() const {
  return *mpin_;
}
inline void TopUpString::set_mpin(const ::std::string& value) {
  set_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    mpin_ = new ::std::string;
  }
  mpin_->assign(value);
}
inline void TopUpString::set_mpin(const char* value) {
  set_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    mpin_ = new ::std::string;
  }
  mpin_->assign(value);
}
inline void TopUpString::set_mpin(const char* value, size_t size) {
  set_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    mpin_ = new ::std::string;
  }
  mpin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TopUpString::mutable_mpin() {
  set_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    mpin_ = new ::std::string;
  }
  return mpin_;
}
inline ::std::string* TopUpString::release_mpin() {
  clear_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mpin_;
    mpin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TopUpString::set_allocated_mpin(::std::string* mpin) {
  if (mpin_ != &::google::protobuf::internal::kEmptyString) {
    delete mpin_;
  }
  if (mpin) {
    set_has_mpin();
    mpin_ = mpin;
  } else {
    clear_has_mpin();
    mpin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string to_number = 3;
inline bool TopUpString::has_to_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TopUpString::set_has_to_number() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TopUpString::clear_has_to_number() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TopUpString::clear_to_number() {
  if (to_number_ != &::google::protobuf::internal::kEmptyString) {
    to_number_->clear();
  }
  clear_has_to_number();
}
inline const ::std::string& TopUpString::to_number() const {
  return *to_number_;
}
inline void TopUpString::set_to_number(const ::std::string& value) {
  set_has_to_number();
  if (to_number_ == &::google::protobuf::internal::kEmptyString) {
    to_number_ = new ::std::string;
  }
  to_number_->assign(value);
}
inline void TopUpString::set_to_number(const char* value) {
  set_has_to_number();
  if (to_number_ == &::google::protobuf::internal::kEmptyString) {
    to_number_ = new ::std::string;
  }
  to_number_->assign(value);
}
inline void TopUpString::set_to_number(const char* value, size_t size) {
  set_has_to_number();
  if (to_number_ == &::google::protobuf::internal::kEmptyString) {
    to_number_ = new ::std::string;
  }
  to_number_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TopUpString::mutable_to_number() {
  set_has_to_number();
  if (to_number_ == &::google::protobuf::internal::kEmptyString) {
    to_number_ = new ::std::string;
  }
  return to_number_;
}
inline ::std::string* TopUpString::release_to_number() {
  clear_has_to_number();
  if (to_number_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = to_number_;
    to_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TopUpString::set_allocated_to_number(::std::string* to_number) {
  if (to_number_ != &::google::protobuf::internal::kEmptyString) {
    delete to_number_;
  }
  if (to_number) {
    set_has_to_number();
    to_number_ = to_number;
  } else {
    clear_has_to_number();
    to_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 amount = 4;
inline bool TopUpString::has_amount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TopUpString::set_has_amount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TopUpString::clear_has_amount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TopUpString::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 TopUpString::amount() const {
  return amount_;
}
inline void TopUpString::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
}

// optional string channel = 5;
inline bool TopUpString::has_channel() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TopUpString::set_has_channel() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TopUpString::clear_has_channel() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TopUpString::clear_channel() {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    channel_->clear();
  }
  clear_has_channel();
}
inline const ::std::string& TopUpString::channel() const {
  return *channel_;
}
inline void TopUpString::set_channel(const ::std::string& value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void TopUpString::set_channel(const char* value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void TopUpString::set_channel(const char* value, size_t size) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TopUpString::mutable_channel() {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  return channel_;
}
inline ::std::string* TopUpString::release_channel() {
  clear_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_;
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TopUpString::set_allocated_channel(::std::string* channel) {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_;
  }
  if (channel) {
    set_has_channel();
    channel_ = channel;
  } else {
    clear_has_channel();
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .com.mservice.momo.msg.keyValuePair keyValuePairs = 6;
inline int TopUpString::keyvaluepairs_size() const {
  return keyvaluepairs_.size();
}
inline void TopUpString::clear_keyvaluepairs() {
  keyvaluepairs_.Clear();
}
inline const ::com::mservice::momo::msg::keyValuePair& TopUpString::keyvaluepairs(int index) const {
  return keyvaluepairs_.Get(index);
}
inline ::com::mservice::momo::msg::keyValuePair* TopUpString::mutable_keyvaluepairs(int index) {
  return keyvaluepairs_.Mutable(index);
}
inline ::com::mservice::momo::msg::keyValuePair* TopUpString::add_keyvaluepairs() {
  return keyvaluepairs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >&
TopUpString::keyvaluepairs() const {
  return keyvaluepairs_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >*
TopUpString::mutable_keyvaluepairs() {
  return &keyvaluepairs_;
}

// -------------------------------------------------------------------

// TopUpReply

// optional bool result = 1;
inline bool TopUpReply::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TopUpReply::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TopUpReply::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TopUpReply::clear_result() {
  result_ = false;
  clear_has_result();
}
inline bool TopUpReply::result() const {
  return result_;
}
inline void TopUpReply::set_result(bool value) {
  set_has_result();
  result_ = value;
}

// optional uint32 rcode = 2;
inline bool TopUpReply::has_rcode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TopUpReply::set_has_rcode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TopUpReply::clear_has_rcode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TopUpReply::clear_rcode() {
  rcode_ = 0u;
  clear_has_rcode();
}
inline ::google::protobuf::uint32 TopUpReply::rcode() const {
  return rcode_;
}
inline void TopUpReply::set_rcode(::google::protobuf::uint32 value) {
  set_has_rcode();
  rcode_ = value;
}

// optional string trans_id = 3;
inline bool TopUpReply::has_trans_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TopUpReply::set_has_trans_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TopUpReply::clear_has_trans_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TopUpReply::clear_trans_id() {
  if (trans_id_ != &::google::protobuf::internal::kEmptyString) {
    trans_id_->clear();
  }
  clear_has_trans_id();
}
inline const ::std::string& TopUpReply::trans_id() const {
  return *trans_id_;
}
inline void TopUpReply::set_trans_id(const ::std::string& value) {
  set_has_trans_id();
  if (trans_id_ == &::google::protobuf::internal::kEmptyString) {
    trans_id_ = new ::std::string;
  }
  trans_id_->assign(value);
}
inline void TopUpReply::set_trans_id(const char* value) {
  set_has_trans_id();
  if (trans_id_ == &::google::protobuf::internal::kEmptyString) {
    trans_id_ = new ::std::string;
  }
  trans_id_->assign(value);
}
inline void TopUpReply::set_trans_id(const char* value, size_t size) {
  set_has_trans_id();
  if (trans_id_ == &::google::protobuf::internal::kEmptyString) {
    trans_id_ = new ::std::string;
  }
  trans_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TopUpReply::mutable_trans_id() {
  set_has_trans_id();
  if (trans_id_ == &::google::protobuf::internal::kEmptyString) {
    trans_id_ = new ::std::string;
  }
  return trans_id_;
}
inline ::std::string* TopUpReply::release_trans_id() {
  clear_has_trans_id();
  if (trans_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = trans_id_;
    trans_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TopUpReply::set_allocated_trans_id(::std::string* trans_id) {
  if (trans_id_ != &::google::protobuf::internal::kEmptyString) {
    delete trans_id_;
  }
  if (trans_id) {
    set_has_trans_id();
    trans_id_ = trans_id;
  } else {
    clear_has_trans_id();
    trans_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// BankIn

// optional string mpin = 1;
inline bool BankIn::has_mpin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BankIn::set_has_mpin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BankIn::clear_has_mpin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BankIn::clear_mpin() {
  if (mpin_ != &::google::protobuf::internal::kEmptyString) {
    mpin_->clear();
  }
  clear_has_mpin();
}
inline const ::std::string& BankIn::mpin() const {
  return *mpin_;
}
inline void BankIn::set_mpin(const ::std::string& value) {
  set_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    mpin_ = new ::std::string;
  }
  mpin_->assign(value);
}
inline void BankIn::set_mpin(const char* value) {
  set_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    mpin_ = new ::std::string;
  }
  mpin_->assign(value);
}
inline void BankIn::set_mpin(const char* value, size_t size) {
  set_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    mpin_ = new ::std::string;
  }
  mpin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BankIn::mutable_mpin() {
  set_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    mpin_ = new ::std::string;
  }
  return mpin_;
}
inline ::std::string* BankIn::release_mpin() {
  clear_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mpin_;
    mpin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BankIn::set_allocated_mpin(::std::string* mpin) {
  if (mpin_ != &::google::protobuf::internal::kEmptyString) {
    delete mpin_;
  }
  if (mpin) {
    set_has_mpin();
    mpin_ = mpin;
  } else {
    clear_has_mpin();
    mpin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 amount = 2;
inline bool BankIn::has_amount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BankIn::set_has_amount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BankIn::clear_has_amount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BankIn::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 BankIn::amount() const {
  return amount_;
}
inline void BankIn::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
}

// optional string bank_code = 3;
inline bool BankIn::has_bank_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BankIn::set_has_bank_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BankIn::clear_has_bank_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BankIn::clear_bank_code() {
  if (bank_code_ != &::google::protobuf::internal::kEmptyString) {
    bank_code_->clear();
  }
  clear_has_bank_code();
}
inline const ::std::string& BankIn::bank_code() const {
  return *bank_code_;
}
inline void BankIn::set_bank_code(const ::std::string& value) {
  set_has_bank_code();
  if (bank_code_ == &::google::protobuf::internal::kEmptyString) {
    bank_code_ = new ::std::string;
  }
  bank_code_->assign(value);
}
inline void BankIn::set_bank_code(const char* value) {
  set_has_bank_code();
  if (bank_code_ == &::google::protobuf::internal::kEmptyString) {
    bank_code_ = new ::std::string;
  }
  bank_code_->assign(value);
}
inline void BankIn::set_bank_code(const char* value, size_t size) {
  set_has_bank_code();
  if (bank_code_ == &::google::protobuf::internal::kEmptyString) {
    bank_code_ = new ::std::string;
  }
  bank_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BankIn::mutable_bank_code() {
  set_has_bank_code();
  if (bank_code_ == &::google::protobuf::internal::kEmptyString) {
    bank_code_ = new ::std::string;
  }
  return bank_code_;
}
inline ::std::string* BankIn::release_bank_code() {
  clear_has_bank_code();
  if (bank_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bank_code_;
    bank_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BankIn::set_allocated_bank_code(::std::string* bank_code) {
  if (bank_code_ != &::google::protobuf::internal::kEmptyString) {
    delete bank_code_;
  }
  if (bank_code) {
    set_has_bank_code();
    bank_code_ = bank_code;
  } else {
    clear_has_bank_code();
    bank_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string channel = 4;
inline bool BankIn::has_channel() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BankIn::set_has_channel() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BankIn::clear_has_channel() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BankIn::clear_channel() {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    channel_->clear();
  }
  clear_has_channel();
}
inline const ::std::string& BankIn::channel() const {
  return *channel_;
}
inline void BankIn::set_channel(const ::std::string& value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void BankIn::set_channel(const char* value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void BankIn::set_channel(const char* value, size_t size) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BankIn::mutable_channel() {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  return channel_;
}
inline ::std::string* BankIn::release_channel() {
  clear_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_;
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BankIn::set_allocated_channel(::std::string* channel) {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_;
  }
  if (channel) {
    set_has_channel();
    channel_ = channel;
  } else {
    clear_has_channel();
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .com.mservice.momo.msg.keyValuePair kvps = 5;
inline int BankIn::kvps_size() const {
  return kvps_.size();
}
inline void BankIn::clear_kvps() {
  kvps_.Clear();
}
inline const ::com::mservice::momo::msg::keyValuePair& BankIn::kvps(int index) const {
  return kvps_.Get(index);
}
inline ::com::mservice::momo::msg::keyValuePair* BankIn::mutable_kvps(int index) {
  return kvps_.Mutable(index);
}
inline ::com::mservice::momo::msg::keyValuePair* BankIn::add_kvps() {
  return kvps_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >&
BankIn::kvps() const {
  return kvps_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >*
BankIn::mutable_kvps() {
  return &kvps_;
}

// -------------------------------------------------------------------

// M2CTransfer

// optional string agent = 1;
inline bool M2CTransfer::has_agent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void M2CTransfer::set_has_agent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void M2CTransfer::clear_has_agent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void M2CTransfer::clear_agent() {
  if (agent_ != &::google::protobuf::internal::kEmptyString) {
    agent_->clear();
  }
  clear_has_agent();
}
inline const ::std::string& M2CTransfer::agent() const {
  return *agent_;
}
inline void M2CTransfer::set_agent(const ::std::string& value) {
  set_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    agent_ = new ::std::string;
  }
  agent_->assign(value);
}
inline void M2CTransfer::set_agent(const char* value) {
  set_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    agent_ = new ::std::string;
  }
  agent_->assign(value);
}
inline void M2CTransfer::set_agent(const char* value, size_t size) {
  set_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    agent_ = new ::std::string;
  }
  agent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* M2CTransfer::mutable_agent() {
  set_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    agent_ = new ::std::string;
  }
  return agent_;
}
inline ::std::string* M2CTransfer::release_agent() {
  clear_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = agent_;
    agent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void M2CTransfer::set_allocated_agent(::std::string* agent) {
  if (agent_ != &::google::protobuf::internal::kEmptyString) {
    delete agent_;
  }
  if (agent) {
    set_has_agent();
    agent_ = agent;
  } else {
    clear_has_agent();
    agent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mpin = 2;
inline bool M2CTransfer::has_mpin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void M2CTransfer::set_has_mpin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void M2CTransfer::clear_has_mpin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void M2CTransfer::clear_mpin() {
  if (mpin_ != &::google::protobuf::internal::kEmptyString) {
    mpin_->clear();
  }
  clear_has_mpin();
}
inline const ::std::string& M2CTransfer::mpin() const {
  return *mpin_;
}
inline void M2CTransfer::set_mpin(const ::std::string& value) {
  set_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    mpin_ = new ::std::string;
  }
  mpin_->assign(value);
}
inline void M2CTransfer::set_mpin(const char* value) {
  set_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    mpin_ = new ::std::string;
  }
  mpin_->assign(value);
}
inline void M2CTransfer::set_mpin(const char* value, size_t size) {
  set_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    mpin_ = new ::std::string;
  }
  mpin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* M2CTransfer::mutable_mpin() {
  set_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    mpin_ = new ::std::string;
  }
  return mpin_;
}
inline ::std::string* M2CTransfer::release_mpin() {
  clear_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mpin_;
    mpin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void M2CTransfer::set_allocated_mpin(::std::string* mpin) {
  if (mpin_ != &::google::protobuf::internal::kEmptyString) {
    delete mpin_;
  }
  if (mpin) {
    set_has_mpin();
    mpin_ = mpin;
  } else {
    clear_has_mpin();
    mpin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string phone = 3;
inline bool M2CTransfer::has_phone() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void M2CTransfer::set_has_phone() {
  _has_bits_[0] |= 0x00000004u;
}
inline void M2CTransfer::clear_has_phone() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void M2CTransfer::clear_phone() {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    phone_->clear();
  }
  clear_has_phone();
}
inline const ::std::string& M2CTransfer::phone() const {
  return *phone_;
}
inline void M2CTransfer::set_phone(const ::std::string& value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void M2CTransfer::set_phone(const char* value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void M2CTransfer::set_phone(const char* value, size_t size) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* M2CTransfer::mutable_phone() {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  return phone_;
}
inline ::std::string* M2CTransfer::release_phone() {
  clear_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phone_;
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void M2CTransfer::set_allocated_phone(::std::string* phone) {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    delete phone_;
  }
  if (phone) {
    set_has_phone();
    phone_ = phone;
  } else {
    clear_has_phone();
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 4;
inline bool M2CTransfer::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void M2CTransfer::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void M2CTransfer::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void M2CTransfer::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& M2CTransfer::name() const {
  return *name_;
}
inline void M2CTransfer::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void M2CTransfer::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void M2CTransfer::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* M2CTransfer::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* M2CTransfer::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void M2CTransfer::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string card_id = 5;
inline bool M2CTransfer::has_card_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void M2CTransfer::set_has_card_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void M2CTransfer::clear_has_card_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void M2CTransfer::clear_card_id() {
  if (card_id_ != &::google::protobuf::internal::kEmptyString) {
    card_id_->clear();
  }
  clear_has_card_id();
}
inline const ::std::string& M2CTransfer::card_id() const {
  return *card_id_;
}
inline void M2CTransfer::set_card_id(const ::std::string& value) {
  set_has_card_id();
  if (card_id_ == &::google::protobuf::internal::kEmptyString) {
    card_id_ = new ::std::string;
  }
  card_id_->assign(value);
}
inline void M2CTransfer::set_card_id(const char* value) {
  set_has_card_id();
  if (card_id_ == &::google::protobuf::internal::kEmptyString) {
    card_id_ = new ::std::string;
  }
  card_id_->assign(value);
}
inline void M2CTransfer::set_card_id(const char* value, size_t size) {
  set_has_card_id();
  if (card_id_ == &::google::protobuf::internal::kEmptyString) {
    card_id_ = new ::std::string;
  }
  card_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* M2CTransfer::mutable_card_id() {
  set_has_card_id();
  if (card_id_ == &::google::protobuf::internal::kEmptyString) {
    card_id_ = new ::std::string;
  }
  return card_id_;
}
inline ::std::string* M2CTransfer::release_card_id() {
  clear_has_card_id();
  if (card_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = card_id_;
    card_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void M2CTransfer::set_allocated_card_id(::std::string* card_id) {
  if (card_id_ != &::google::protobuf::internal::kEmptyString) {
    delete card_id_;
  }
  if (card_id) {
    set_has_card_id();
    card_id_ = card_id;
  } else {
    clear_has_card_id();
    card_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 amount = 6;
inline bool M2CTransfer::has_amount() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void M2CTransfer::set_has_amount() {
  _has_bits_[0] |= 0x00000020u;
}
inline void M2CTransfer::clear_has_amount() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void M2CTransfer::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 M2CTransfer::amount() const {
  return amount_;
}
inline void M2CTransfer::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
}

// optional string notice = 7;
inline bool M2CTransfer::has_notice() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void M2CTransfer::set_has_notice() {
  _has_bits_[0] |= 0x00000040u;
}
inline void M2CTransfer::clear_has_notice() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void M2CTransfer::clear_notice() {
  if (notice_ != &::google::protobuf::internal::kEmptyString) {
    notice_->clear();
  }
  clear_has_notice();
}
inline const ::std::string& M2CTransfer::notice() const {
  return *notice_;
}
inline void M2CTransfer::set_notice(const ::std::string& value) {
  set_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    notice_ = new ::std::string;
  }
  notice_->assign(value);
}
inline void M2CTransfer::set_notice(const char* value) {
  set_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    notice_ = new ::std::string;
  }
  notice_->assign(value);
}
inline void M2CTransfer::set_notice(const char* value, size_t size) {
  set_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    notice_ = new ::std::string;
  }
  notice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* M2CTransfer::mutable_notice() {
  set_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    notice_ = new ::std::string;
  }
  return notice_;
}
inline ::std::string* M2CTransfer::release_notice() {
  clear_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = notice_;
    notice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void M2CTransfer::set_allocated_notice(::std::string* notice) {
  if (notice_ != &::google::protobuf::internal::kEmptyString) {
    delete notice_;
  }
  if (notice) {
    set_has_notice();
    notice_ = notice;
  } else {
    clear_has_notice();
    notice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string channel = 8;
inline bool M2CTransfer::has_channel() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void M2CTransfer::set_has_channel() {
  _has_bits_[0] |= 0x00000080u;
}
inline void M2CTransfer::clear_has_channel() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void M2CTransfer::clear_channel() {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    channel_->clear();
  }
  clear_has_channel();
}
inline const ::std::string& M2CTransfer::channel() const {
  return *channel_;
}
inline void M2CTransfer::set_channel(const ::std::string& value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void M2CTransfer::set_channel(const char* value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void M2CTransfer::set_channel(const char* value, size_t size) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* M2CTransfer::mutable_channel() {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  return channel_;
}
inline ::std::string* M2CTransfer::release_channel() {
  clear_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_;
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void M2CTransfer::set_allocated_channel(::std::string* channel) {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_;
  }
  if (channel) {
    set_has_channel();
    channel_ = channel;
  } else {
    clear_has_channel();
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .com.mservice.momo.msg.keyValuePair kvps = 9;
inline int M2CTransfer::kvps_size() const {
  return kvps_.size();
}
inline void M2CTransfer::clear_kvps() {
  kvps_.Clear();
}
inline const ::com::mservice::momo::msg::keyValuePair& M2CTransfer::kvps(int index) const {
  return kvps_.Get(index);
}
inline ::com::mservice::momo::msg::keyValuePair* M2CTransfer::mutable_kvps(int index) {
  return kvps_.Mutable(index);
}
inline ::com::mservice::momo::msg::keyValuePair* M2CTransfer::add_kvps() {
  return kvps_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >&
M2CTransfer::kvps() const {
  return kvps_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >*
M2CTransfer::mutable_kvps() {
  return &kvps_;
}

// -------------------------------------------------------------------

// PayOneBillOther

// optional string agent = 1;
inline bool PayOneBillOther::has_agent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PayOneBillOther::set_has_agent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PayOneBillOther::clear_has_agent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PayOneBillOther::clear_agent() {
  if (agent_ != &::google::protobuf::internal::kEmptyString) {
    agent_->clear();
  }
  clear_has_agent();
}
inline const ::std::string& PayOneBillOther::agent() const {
  return *agent_;
}
inline void PayOneBillOther::set_agent(const ::std::string& value) {
  set_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    agent_ = new ::std::string;
  }
  agent_->assign(value);
}
inline void PayOneBillOther::set_agent(const char* value) {
  set_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    agent_ = new ::std::string;
  }
  agent_->assign(value);
}
inline void PayOneBillOther::set_agent(const char* value, size_t size) {
  set_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    agent_ = new ::std::string;
  }
  agent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PayOneBillOther::mutable_agent() {
  set_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    agent_ = new ::std::string;
  }
  return agent_;
}
inline ::std::string* PayOneBillOther::release_agent() {
  clear_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = agent_;
    agent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PayOneBillOther::set_allocated_agent(::std::string* agent) {
  if (agent_ != &::google::protobuf::internal::kEmptyString) {
    delete agent_;
  }
  if (agent) {
    set_has_agent();
    agent_ = agent;
  } else {
    clear_has_agent();
    agent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mpin = 2;
inline bool PayOneBillOther::has_mpin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PayOneBillOther::set_has_mpin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PayOneBillOther::clear_has_mpin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PayOneBillOther::clear_mpin() {
  if (mpin_ != &::google::protobuf::internal::kEmptyString) {
    mpin_->clear();
  }
  clear_has_mpin();
}
inline const ::std::string& PayOneBillOther::mpin() const {
  return *mpin_;
}
inline void PayOneBillOther::set_mpin(const ::std::string& value) {
  set_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    mpin_ = new ::std::string;
  }
  mpin_->assign(value);
}
inline void PayOneBillOther::set_mpin(const char* value) {
  set_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    mpin_ = new ::std::string;
  }
  mpin_->assign(value);
}
inline void PayOneBillOther::set_mpin(const char* value, size_t size) {
  set_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    mpin_ = new ::std::string;
  }
  mpin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PayOneBillOther::mutable_mpin() {
  set_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    mpin_ = new ::std::string;
  }
  return mpin_;
}
inline ::std::string* PayOneBillOther::release_mpin() {
  clear_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mpin_;
    mpin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PayOneBillOther::set_allocated_mpin(::std::string* mpin) {
  if (mpin_ != &::google::protobuf::internal::kEmptyString) {
    delete mpin_;
  }
  if (mpin) {
    set_has_mpin();
    mpin_ = mpin;
  } else {
    clear_has_mpin();
    mpin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string phone = 3;
inline bool PayOneBillOther::has_phone() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PayOneBillOther::set_has_phone() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PayOneBillOther::clear_has_phone() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PayOneBillOther::clear_phone() {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    phone_->clear();
  }
  clear_has_phone();
}
inline const ::std::string& PayOneBillOther::phone() const {
  return *phone_;
}
inline void PayOneBillOther::set_phone(const ::std::string& value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void PayOneBillOther::set_phone(const char* value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void PayOneBillOther::set_phone(const char* value, size_t size) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PayOneBillOther::mutable_phone() {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  return phone_;
}
inline ::std::string* PayOneBillOther::release_phone() {
  clear_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phone_;
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PayOneBillOther::set_allocated_phone(::std::string* phone) {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    delete phone_;
  }
  if (phone) {
    set_has_phone();
    phone_ = phone;
  } else {
    clear_has_phone();
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 4;
inline bool PayOneBillOther::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PayOneBillOther::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PayOneBillOther::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PayOneBillOther::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& PayOneBillOther::name() const {
  return *name_;
}
inline void PayOneBillOther::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PayOneBillOther::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PayOneBillOther::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PayOneBillOther::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* PayOneBillOther::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PayOneBillOther::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string card_id = 5;
inline bool PayOneBillOther::has_card_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PayOneBillOther::set_has_card_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PayOneBillOther::clear_has_card_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PayOneBillOther::clear_card_id() {
  if (card_id_ != &::google::protobuf::internal::kEmptyString) {
    card_id_->clear();
  }
  clear_has_card_id();
}
inline const ::std::string& PayOneBillOther::card_id() const {
  return *card_id_;
}
inline void PayOneBillOther::set_card_id(const ::std::string& value) {
  set_has_card_id();
  if (card_id_ == &::google::protobuf::internal::kEmptyString) {
    card_id_ = new ::std::string;
  }
  card_id_->assign(value);
}
inline void PayOneBillOther::set_card_id(const char* value) {
  set_has_card_id();
  if (card_id_ == &::google::protobuf::internal::kEmptyString) {
    card_id_ = new ::std::string;
  }
  card_id_->assign(value);
}
inline void PayOneBillOther::set_card_id(const char* value, size_t size) {
  set_has_card_id();
  if (card_id_ == &::google::protobuf::internal::kEmptyString) {
    card_id_ = new ::std::string;
  }
  card_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PayOneBillOther::mutable_card_id() {
  set_has_card_id();
  if (card_id_ == &::google::protobuf::internal::kEmptyString) {
    card_id_ = new ::std::string;
  }
  return card_id_;
}
inline ::std::string* PayOneBillOther::release_card_id() {
  clear_has_card_id();
  if (card_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = card_id_;
    card_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PayOneBillOther::set_allocated_card_id(::std::string* card_id) {
  if (card_id_ != &::google::protobuf::internal::kEmptyString) {
    delete card_id_;
  }
  if (card_id) {
    set_has_card_id();
    card_id_ = card_id;
  } else {
    clear_has_card_id();
    card_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 amount = 6;
inline bool PayOneBillOther::has_amount() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PayOneBillOther::set_has_amount() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PayOneBillOther::clear_has_amount() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PayOneBillOther::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 PayOneBillOther::amount() const {
  return amount_;
}
inline void PayOneBillOther::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
}

// optional string notice = 7;
inline bool PayOneBillOther::has_notice() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PayOneBillOther::set_has_notice() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PayOneBillOther::clear_has_notice() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PayOneBillOther::clear_notice() {
  if (notice_ != &::google::protobuf::internal::kEmptyString) {
    notice_->clear();
  }
  clear_has_notice();
}
inline const ::std::string& PayOneBillOther::notice() const {
  return *notice_;
}
inline void PayOneBillOther::set_notice(const ::std::string& value) {
  set_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    notice_ = new ::std::string;
  }
  notice_->assign(value);
}
inline void PayOneBillOther::set_notice(const char* value) {
  set_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    notice_ = new ::std::string;
  }
  notice_->assign(value);
}
inline void PayOneBillOther::set_notice(const char* value, size_t size) {
  set_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    notice_ = new ::std::string;
  }
  notice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PayOneBillOther::mutable_notice() {
  set_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    notice_ = new ::std::string;
  }
  return notice_;
}
inline ::std::string* PayOneBillOther::release_notice() {
  clear_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = notice_;
    notice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PayOneBillOther::set_allocated_notice(::std::string* notice) {
  if (notice_ != &::google::protobuf::internal::kEmptyString) {
    delete notice_;
  }
  if (notice) {
    set_has_notice();
    notice_ = notice;
  } else {
    clear_has_notice();
    notice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string channel = 8;
inline bool PayOneBillOther::has_channel() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PayOneBillOther::set_has_channel() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PayOneBillOther::clear_has_channel() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PayOneBillOther::clear_channel() {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    channel_->clear();
  }
  clear_has_channel();
}
inline const ::std::string& PayOneBillOther::channel() const {
  return *channel_;
}
inline void PayOneBillOther::set_channel(const ::std::string& value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void PayOneBillOther::set_channel(const char* value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void PayOneBillOther::set_channel(const char* value, size_t size) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PayOneBillOther::mutable_channel() {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  return channel_;
}
inline ::std::string* PayOneBillOther::release_channel() {
  clear_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_;
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PayOneBillOther::set_allocated_channel(::std::string* channel) {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_;
  }
  if (channel) {
    set_has_channel();
    channel_ = channel;
  } else {
    clear_has_channel();
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .com.mservice.momo.msg.keyValuePair kvps = 9;
inline int PayOneBillOther::kvps_size() const {
  return kvps_.size();
}
inline void PayOneBillOther::clear_kvps() {
  kvps_.Clear();
}
inline const ::com::mservice::momo::msg::keyValuePair& PayOneBillOther::kvps(int index) const {
  return kvps_.Get(index);
}
inline ::com::mservice::momo::msg::keyValuePair* PayOneBillOther::mutable_kvps(int index) {
  return kvps_.Mutable(index);
}
inline ::com::mservice::momo::msg::keyValuePair* PayOneBillOther::add_kvps() {
  return kvps_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >&
PayOneBillOther::kvps() const {
  return kvps_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >*
PayOneBillOther::mutable_kvps() {
  return &kvps_;
}

// -------------------------------------------------------------------

// M2MTransfer

// optional string agent = 1;
inline bool M2MTransfer::has_agent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void M2MTransfer::set_has_agent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void M2MTransfer::clear_has_agent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void M2MTransfer::clear_agent() {
  if (agent_ != &::google::protobuf::internal::kEmptyString) {
    agent_->clear();
  }
  clear_has_agent();
}
inline const ::std::string& M2MTransfer::agent() const {
  return *agent_;
}
inline void M2MTransfer::set_agent(const ::std::string& value) {
  set_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    agent_ = new ::std::string;
  }
  agent_->assign(value);
}
inline void M2MTransfer::set_agent(const char* value) {
  set_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    agent_ = new ::std::string;
  }
  agent_->assign(value);
}
inline void M2MTransfer::set_agent(const char* value, size_t size) {
  set_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    agent_ = new ::std::string;
  }
  agent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* M2MTransfer::mutable_agent() {
  set_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    agent_ = new ::std::string;
  }
  return agent_;
}
inline ::std::string* M2MTransfer::release_agent() {
  clear_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = agent_;
    agent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void M2MTransfer::set_allocated_agent(::std::string* agent) {
  if (agent_ != &::google::protobuf::internal::kEmptyString) {
    delete agent_;
  }
  if (agent) {
    set_has_agent();
    agent_ = agent;
  } else {
    clear_has_agent();
    agent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mpin = 2;
inline bool M2MTransfer::has_mpin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void M2MTransfer::set_has_mpin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void M2MTransfer::clear_has_mpin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void M2MTransfer::clear_mpin() {
  if (mpin_ != &::google::protobuf::internal::kEmptyString) {
    mpin_->clear();
  }
  clear_has_mpin();
}
inline const ::std::string& M2MTransfer::mpin() const {
  return *mpin_;
}
inline void M2MTransfer::set_mpin(const ::std::string& value) {
  set_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    mpin_ = new ::std::string;
  }
  mpin_->assign(value);
}
inline void M2MTransfer::set_mpin(const char* value) {
  set_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    mpin_ = new ::std::string;
  }
  mpin_->assign(value);
}
inline void M2MTransfer::set_mpin(const char* value, size_t size) {
  set_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    mpin_ = new ::std::string;
  }
  mpin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* M2MTransfer::mutable_mpin() {
  set_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    mpin_ = new ::std::string;
  }
  return mpin_;
}
inline ::std::string* M2MTransfer::release_mpin() {
  clear_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mpin_;
    mpin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void M2MTransfer::set_allocated_mpin(::std::string* mpin) {
  if (mpin_ != &::google::protobuf::internal::kEmptyString) {
    delete mpin_;
  }
  if (mpin) {
    set_has_mpin();
    mpin_ = mpin;
  } else {
    clear_has_mpin();
    mpin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string phone = 3;
inline bool M2MTransfer::has_phone() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void M2MTransfer::set_has_phone() {
  _has_bits_[0] |= 0x00000004u;
}
inline void M2MTransfer::clear_has_phone() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void M2MTransfer::clear_phone() {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    phone_->clear();
  }
  clear_has_phone();
}
inline const ::std::string& M2MTransfer::phone() const {
  return *phone_;
}
inline void M2MTransfer::set_phone(const ::std::string& value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void M2MTransfer::set_phone(const char* value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void M2MTransfer::set_phone(const char* value, size_t size) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* M2MTransfer::mutable_phone() {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  return phone_;
}
inline ::std::string* M2MTransfer::release_phone() {
  clear_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phone_;
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void M2MTransfer::set_allocated_phone(::std::string* phone) {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    delete phone_;
  }
  if (phone) {
    set_has_phone();
    phone_ = phone;
  } else {
    clear_has_phone();
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 amount = 4;
inline bool M2MTransfer::has_amount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void M2MTransfer::set_has_amount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void M2MTransfer::clear_has_amount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void M2MTransfer::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 M2MTransfer::amount() const {
  return amount_;
}
inline void M2MTransfer::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
}

// optional string notice = 5;
inline bool M2MTransfer::has_notice() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void M2MTransfer::set_has_notice() {
  _has_bits_[0] |= 0x00000010u;
}
inline void M2MTransfer::clear_has_notice() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void M2MTransfer::clear_notice() {
  if (notice_ != &::google::protobuf::internal::kEmptyString) {
    notice_->clear();
  }
  clear_has_notice();
}
inline const ::std::string& M2MTransfer::notice() const {
  return *notice_;
}
inline void M2MTransfer::set_notice(const ::std::string& value) {
  set_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    notice_ = new ::std::string;
  }
  notice_->assign(value);
}
inline void M2MTransfer::set_notice(const char* value) {
  set_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    notice_ = new ::std::string;
  }
  notice_->assign(value);
}
inline void M2MTransfer::set_notice(const char* value, size_t size) {
  set_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    notice_ = new ::std::string;
  }
  notice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* M2MTransfer::mutable_notice() {
  set_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    notice_ = new ::std::string;
  }
  return notice_;
}
inline ::std::string* M2MTransfer::release_notice() {
  clear_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = notice_;
    notice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void M2MTransfer::set_allocated_notice(::std::string* notice) {
  if (notice_ != &::google::protobuf::internal::kEmptyString) {
    delete notice_;
  }
  if (notice) {
    set_has_notice();
    notice_ = notice;
  } else {
    clear_has_notice();
    notice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string channel = 6;
inline bool M2MTransfer::has_channel() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void M2MTransfer::set_has_channel() {
  _has_bits_[0] |= 0x00000020u;
}
inline void M2MTransfer::clear_has_channel() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void M2MTransfer::clear_channel() {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    channel_->clear();
  }
  clear_has_channel();
}
inline const ::std::string& M2MTransfer::channel() const {
  return *channel_;
}
inline void M2MTransfer::set_channel(const ::std::string& value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void M2MTransfer::set_channel(const char* value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void M2MTransfer::set_channel(const char* value, size_t size) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* M2MTransfer::mutable_channel() {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  return channel_;
}
inline ::std::string* M2MTransfer::release_channel() {
  clear_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_;
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void M2MTransfer::set_allocated_channel(::std::string* channel) {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_;
  }
  if (channel) {
    set_has_channel();
    channel_ = channel;
  } else {
    clear_has_channel();
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .com.mservice.momo.msg.keyValuePair kvps = 7;
inline int M2MTransfer::kvps_size() const {
  return kvps_.size();
}
inline void M2MTransfer::clear_kvps() {
  kvps_.Clear();
}
inline const ::com::mservice::momo::msg::keyValuePair& M2MTransfer::kvps(int index) const {
  return kvps_.Get(index);
}
inline ::com::mservice::momo::msg::keyValuePair* M2MTransfer::mutable_kvps(int index) {
  return kvps_.Mutable(index);
}
inline ::com::mservice::momo::msg::keyValuePair* M2MTransfer::add_kvps() {
  return kvps_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >&
M2MTransfer::kvps() const {
  return kvps_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >*
M2MTransfer::mutable_kvps() {
  return &kvps_;
}

// -------------------------------------------------------------------

// TransferMoney2Place

// optional string agent = 1;
inline bool TransferMoney2Place::has_agent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransferMoney2Place::set_has_agent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransferMoney2Place::clear_has_agent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransferMoney2Place::clear_agent() {
  if (agent_ != &::google::protobuf::internal::kEmptyString) {
    agent_->clear();
  }
  clear_has_agent();
}
inline const ::std::string& TransferMoney2Place::agent() const {
  return *agent_;
}
inline void TransferMoney2Place::set_agent(const ::std::string& value) {
  set_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    agent_ = new ::std::string;
  }
  agent_->assign(value);
}
inline void TransferMoney2Place::set_agent(const char* value) {
  set_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    agent_ = new ::std::string;
  }
  agent_->assign(value);
}
inline void TransferMoney2Place::set_agent(const char* value, size_t size) {
  set_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    agent_ = new ::std::string;
  }
  agent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TransferMoney2Place::mutable_agent() {
  set_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    agent_ = new ::std::string;
  }
  return agent_;
}
inline ::std::string* TransferMoney2Place::release_agent() {
  clear_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = agent_;
    agent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TransferMoney2Place::set_allocated_agent(::std::string* agent) {
  if (agent_ != &::google::protobuf::internal::kEmptyString) {
    delete agent_;
  }
  if (agent) {
    set_has_agent();
    agent_ = agent;
  } else {
    clear_has_agent();
    agent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mpin = 2;
inline bool TransferMoney2Place::has_mpin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransferMoney2Place::set_has_mpin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransferMoney2Place::clear_has_mpin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransferMoney2Place::clear_mpin() {
  if (mpin_ != &::google::protobuf::internal::kEmptyString) {
    mpin_->clear();
  }
  clear_has_mpin();
}
inline const ::std::string& TransferMoney2Place::mpin() const {
  return *mpin_;
}
inline void TransferMoney2Place::set_mpin(const ::std::string& value) {
  set_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    mpin_ = new ::std::string;
  }
  mpin_->assign(value);
}
inline void TransferMoney2Place::set_mpin(const char* value) {
  set_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    mpin_ = new ::std::string;
  }
  mpin_->assign(value);
}
inline void TransferMoney2Place::set_mpin(const char* value, size_t size) {
  set_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    mpin_ = new ::std::string;
  }
  mpin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TransferMoney2Place::mutable_mpin() {
  set_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    mpin_ = new ::std::string;
  }
  return mpin_;
}
inline ::std::string* TransferMoney2Place::release_mpin() {
  clear_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mpin_;
    mpin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TransferMoney2Place::set_allocated_mpin(::std::string* mpin) {
  if (mpin_ != &::google::protobuf::internal::kEmptyString) {
    delete mpin_;
  }
  if (mpin) {
    set_has_mpin();
    mpin_ = mpin;
  } else {
    clear_has_mpin();
    mpin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string phone = 3;
inline bool TransferMoney2Place::has_phone() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransferMoney2Place::set_has_phone() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TransferMoney2Place::clear_has_phone() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TransferMoney2Place::clear_phone() {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    phone_->clear();
  }
  clear_has_phone();
}
inline const ::std::string& TransferMoney2Place::phone() const {
  return *phone_;
}
inline void TransferMoney2Place::set_phone(const ::std::string& value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void TransferMoney2Place::set_phone(const char* value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void TransferMoney2Place::set_phone(const char* value, size_t size) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TransferMoney2Place::mutable_phone() {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  return phone_;
}
inline ::std::string* TransferMoney2Place::release_phone() {
  clear_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phone_;
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TransferMoney2Place::set_allocated_phone(::std::string* phone) {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    delete phone_;
  }
  if (phone) {
    set_has_phone();
    phone_ = phone;
  } else {
    clear_has_phone();
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 amount = 4;
inline bool TransferMoney2Place::has_amount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TransferMoney2Place::set_has_amount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TransferMoney2Place::clear_has_amount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TransferMoney2Place::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 TransferMoney2Place::amount() const {
  return amount_;
}
inline void TransferMoney2Place::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
}

// optional string notice = 5;
inline bool TransferMoney2Place::has_notice() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TransferMoney2Place::set_has_notice() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TransferMoney2Place::clear_has_notice() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TransferMoney2Place::clear_notice() {
  if (notice_ != &::google::protobuf::internal::kEmptyString) {
    notice_->clear();
  }
  clear_has_notice();
}
inline const ::std::string& TransferMoney2Place::notice() const {
  return *notice_;
}
inline void TransferMoney2Place::set_notice(const ::std::string& value) {
  set_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    notice_ = new ::std::string;
  }
  notice_->assign(value);
}
inline void TransferMoney2Place::set_notice(const char* value) {
  set_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    notice_ = new ::std::string;
  }
  notice_->assign(value);
}
inline void TransferMoney2Place::set_notice(const char* value, size_t size) {
  set_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    notice_ = new ::std::string;
  }
  notice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TransferMoney2Place::mutable_notice() {
  set_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    notice_ = new ::std::string;
  }
  return notice_;
}
inline ::std::string* TransferMoney2Place::release_notice() {
  clear_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = notice_;
    notice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TransferMoney2Place::set_allocated_notice(::std::string* notice) {
  if (notice_ != &::google::protobuf::internal::kEmptyString) {
    delete notice_;
  }
  if (notice) {
    set_has_notice();
    notice_ = notice;
  } else {
    clear_has_notice();
    notice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string channel = 6;
inline bool TransferMoney2Place::has_channel() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TransferMoney2Place::set_has_channel() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TransferMoney2Place::clear_has_channel() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TransferMoney2Place::clear_channel() {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    channel_->clear();
  }
  clear_has_channel();
}
inline const ::std::string& TransferMoney2Place::channel() const {
  return *channel_;
}
inline void TransferMoney2Place::set_channel(const ::std::string& value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void TransferMoney2Place::set_channel(const char* value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void TransferMoney2Place::set_channel(const char* value, size_t size) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TransferMoney2Place::mutable_channel() {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  return channel_;
}
inline ::std::string* TransferMoney2Place::release_channel() {
  clear_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_;
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TransferMoney2Place::set_allocated_channel(::std::string* channel) {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_;
  }
  if (channel) {
    set_has_channel();
    channel_ = channel;
  } else {
    clear_has_channel();
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .com.mservice.momo.msg.keyValuePair kvps = 7;
inline int TransferMoney2Place::kvps_size() const {
  return kvps_.size();
}
inline void TransferMoney2Place::clear_kvps() {
  kvps_.Clear();
}
inline const ::com::mservice::momo::msg::keyValuePair& TransferMoney2Place::kvps(int index) const {
  return kvps_.Get(index);
}
inline ::com::mservice::momo::msg::keyValuePair* TransferMoney2Place::mutable_kvps(int index) {
  return kvps_.Mutable(index);
}
inline ::com::mservice::momo::msg::keyValuePair* TransferMoney2Place::add_kvps() {
  return kvps_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >&
TransferMoney2Place::kvps() const {
  return kvps_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >*
TransferMoney2Place::mutable_kvps() {
  return &kvps_;
}

// -------------------------------------------------------------------

// ChangePin

// optional string number = 1;
inline bool ChangePin::has_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangePin::set_has_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangePin::clear_has_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangePin::clear_number() {
  if (number_ != &::google::protobuf::internal::kEmptyString) {
    number_->clear();
  }
  clear_has_number();
}
inline const ::std::string& ChangePin::number() const {
  return *number_;
}
inline void ChangePin::set_number(const ::std::string& value) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  number_->assign(value);
}
inline void ChangePin::set_number(const char* value) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  number_->assign(value);
}
inline void ChangePin::set_number(const char* value, size_t size) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  number_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChangePin::mutable_number() {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  return number_;
}
inline ::std::string* ChangePin::release_number() {
  clear_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = number_;
    number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ChangePin::set_allocated_number(::std::string* number) {
  if (number_ != &::google::protobuf::internal::kEmptyString) {
    delete number_;
  }
  if (number) {
    set_has_number();
    number_ = number;
  } else {
    clear_has_number();
    number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string old_pin = 2;
inline bool ChangePin::has_old_pin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChangePin::set_has_old_pin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChangePin::clear_has_old_pin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChangePin::clear_old_pin() {
  if (old_pin_ != &::google::protobuf::internal::kEmptyString) {
    old_pin_->clear();
  }
  clear_has_old_pin();
}
inline const ::std::string& ChangePin::old_pin() const {
  return *old_pin_;
}
inline void ChangePin::set_old_pin(const ::std::string& value) {
  set_has_old_pin();
  if (old_pin_ == &::google::protobuf::internal::kEmptyString) {
    old_pin_ = new ::std::string;
  }
  old_pin_->assign(value);
}
inline void ChangePin::set_old_pin(const char* value) {
  set_has_old_pin();
  if (old_pin_ == &::google::protobuf::internal::kEmptyString) {
    old_pin_ = new ::std::string;
  }
  old_pin_->assign(value);
}
inline void ChangePin::set_old_pin(const char* value, size_t size) {
  set_has_old_pin();
  if (old_pin_ == &::google::protobuf::internal::kEmptyString) {
    old_pin_ = new ::std::string;
  }
  old_pin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChangePin::mutable_old_pin() {
  set_has_old_pin();
  if (old_pin_ == &::google::protobuf::internal::kEmptyString) {
    old_pin_ = new ::std::string;
  }
  return old_pin_;
}
inline ::std::string* ChangePin::release_old_pin() {
  clear_has_old_pin();
  if (old_pin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = old_pin_;
    old_pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ChangePin::set_allocated_old_pin(::std::string* old_pin) {
  if (old_pin_ != &::google::protobuf::internal::kEmptyString) {
    delete old_pin_;
  }
  if (old_pin) {
    set_has_old_pin();
    old_pin_ = old_pin;
  } else {
    clear_has_old_pin();
    old_pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string new_pin = 3;
inline bool ChangePin::has_new_pin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChangePin::set_has_new_pin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChangePin::clear_has_new_pin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChangePin::clear_new_pin() {
  if (new_pin_ != &::google::protobuf::internal::kEmptyString) {
    new_pin_->clear();
  }
  clear_has_new_pin();
}
inline const ::std::string& ChangePin::new_pin() const {
  return *new_pin_;
}
inline void ChangePin::set_new_pin(const ::std::string& value) {
  set_has_new_pin();
  if (new_pin_ == &::google::protobuf::internal::kEmptyString) {
    new_pin_ = new ::std::string;
  }
  new_pin_->assign(value);
}
inline void ChangePin::set_new_pin(const char* value) {
  set_has_new_pin();
  if (new_pin_ == &::google::protobuf::internal::kEmptyString) {
    new_pin_ = new ::std::string;
  }
  new_pin_->assign(value);
}
inline void ChangePin::set_new_pin(const char* value, size_t size) {
  set_has_new_pin();
  if (new_pin_ == &::google::protobuf::internal::kEmptyString) {
    new_pin_ = new ::std::string;
  }
  new_pin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChangePin::mutable_new_pin() {
  set_has_new_pin();
  if (new_pin_ == &::google::protobuf::internal::kEmptyString) {
    new_pin_ = new ::std::string;
  }
  return new_pin_;
}
inline ::std::string* ChangePin::release_new_pin() {
  clear_has_new_pin();
  if (new_pin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = new_pin_;
    new_pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ChangePin::set_allocated_new_pin(::std::string* new_pin) {
  if (new_pin_ != &::google::protobuf::internal::kEmptyString) {
    delete new_pin_;
  }
  if (new_pin) {
    set_has_new_pin();
    new_pin_ = new_pin;
  } else {
    clear_has_new_pin();
    new_pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RecoveryNewPin

// optional string number = 1;
inline bool RecoveryNewPin::has_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RecoveryNewPin::set_has_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RecoveryNewPin::clear_has_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RecoveryNewPin::clear_number() {
  if (number_ != &::google::protobuf::internal::kEmptyString) {
    number_->clear();
  }
  clear_has_number();
}
inline const ::std::string& RecoveryNewPin::number() const {
  return *number_;
}
inline void RecoveryNewPin::set_number(const ::std::string& value) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  number_->assign(value);
}
inline void RecoveryNewPin::set_number(const char* value) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  number_->assign(value);
}
inline void RecoveryNewPin::set_number(const char* value, size_t size) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  number_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RecoveryNewPin::mutable_number() {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  return number_;
}
inline ::std::string* RecoveryNewPin::release_number() {
  clear_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = number_;
    number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RecoveryNewPin::set_allocated_number(::std::string* number) {
  if (number_ != &::google::protobuf::internal::kEmptyString) {
    delete number_;
  }
  if (number) {
    set_has_number();
    number_ = number;
  } else {
    clear_has_number();
    number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string old_pin = 2;
inline bool RecoveryNewPin::has_old_pin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RecoveryNewPin::set_has_old_pin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RecoveryNewPin::clear_has_old_pin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RecoveryNewPin::clear_old_pin() {
  if (old_pin_ != &::google::protobuf::internal::kEmptyString) {
    old_pin_->clear();
  }
  clear_has_old_pin();
}
inline const ::std::string& RecoveryNewPin::old_pin() const {
  return *old_pin_;
}
inline void RecoveryNewPin::set_old_pin(const ::std::string& value) {
  set_has_old_pin();
  if (old_pin_ == &::google::protobuf::internal::kEmptyString) {
    old_pin_ = new ::std::string;
  }
  old_pin_->assign(value);
}
inline void RecoveryNewPin::set_old_pin(const char* value) {
  set_has_old_pin();
  if (old_pin_ == &::google::protobuf::internal::kEmptyString) {
    old_pin_ = new ::std::string;
  }
  old_pin_->assign(value);
}
inline void RecoveryNewPin::set_old_pin(const char* value, size_t size) {
  set_has_old_pin();
  if (old_pin_ == &::google::protobuf::internal::kEmptyString) {
    old_pin_ = new ::std::string;
  }
  old_pin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RecoveryNewPin::mutable_old_pin() {
  set_has_old_pin();
  if (old_pin_ == &::google::protobuf::internal::kEmptyString) {
    old_pin_ = new ::std::string;
  }
  return old_pin_;
}
inline ::std::string* RecoveryNewPin::release_old_pin() {
  clear_has_old_pin();
  if (old_pin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = old_pin_;
    old_pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RecoveryNewPin::set_allocated_old_pin(::std::string* old_pin) {
  if (old_pin_ != &::google::protobuf::internal::kEmptyString) {
    delete old_pin_;
  }
  if (old_pin) {
    set_has_old_pin();
    old_pin_ = old_pin;
  } else {
    clear_has_old_pin();
    old_pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string new_pin = 3;
inline bool RecoveryNewPin::has_new_pin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RecoveryNewPin::set_has_new_pin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RecoveryNewPin::clear_has_new_pin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RecoveryNewPin::clear_new_pin() {
  if (new_pin_ != &::google::protobuf::internal::kEmptyString) {
    new_pin_->clear();
  }
  clear_has_new_pin();
}
inline const ::std::string& RecoveryNewPin::new_pin() const {
  return *new_pin_;
}
inline void RecoveryNewPin::set_new_pin(const ::std::string& value) {
  set_has_new_pin();
  if (new_pin_ == &::google::protobuf::internal::kEmptyString) {
    new_pin_ = new ::std::string;
  }
  new_pin_->assign(value);
}
inline void RecoveryNewPin::set_new_pin(const char* value) {
  set_has_new_pin();
  if (new_pin_ == &::google::protobuf::internal::kEmptyString) {
    new_pin_ = new ::std::string;
  }
  new_pin_->assign(value);
}
inline void RecoveryNewPin::set_new_pin(const char* value, size_t size) {
  set_has_new_pin();
  if (new_pin_ == &::google::protobuf::internal::kEmptyString) {
    new_pin_ = new ::std::string;
  }
  new_pin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RecoveryNewPin::mutable_new_pin() {
  set_has_new_pin();
  if (new_pin_ == &::google::protobuf::internal::kEmptyString) {
    new_pin_ = new ::std::string;
  }
  return new_pin_;
}
inline ::std::string* RecoveryNewPin::release_new_pin() {
  clear_has_new_pin();
  if (new_pin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = new_pin_;
    new_pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RecoveryNewPin::set_allocated_new_pin(::std::string* new_pin) {
  if (new_pin_ != &::google::protobuf::internal::kEmptyString) {
    delete new_pin_;
  }
  if (new_pin) {
    set_has_new_pin();
    new_pin_ = new_pin;
  } else {
    clear_has_new_pin();
    new_pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PayOneBill

// optional string pin = 1;
inline bool PayOneBill::has_pin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PayOneBill::set_has_pin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PayOneBill::clear_has_pin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PayOneBill::clear_pin() {
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    pin_->clear();
  }
  clear_has_pin();
}
inline const ::std::string& PayOneBill::pin() const {
  return *pin_;
}
inline void PayOneBill::set_pin(const ::std::string& value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void PayOneBill::set_pin(const char* value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void PayOneBill::set_pin(const char* value, size_t size) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PayOneBill::mutable_pin() {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  return pin_;
}
inline ::std::string* PayOneBill::release_pin() {
  clear_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pin_;
    pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PayOneBill::set_allocated_pin(::std::string* pin) {
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    delete pin_;
  }
  if (pin) {
    set_has_pin();
    pin_ = pin;
  } else {
    clear_has_pin();
    pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string providerId = 2;
inline bool PayOneBill::has_providerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PayOneBill::set_has_providerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PayOneBill::clear_has_providerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PayOneBill::clear_providerid() {
  if (providerid_ != &::google::protobuf::internal::kEmptyString) {
    providerid_->clear();
  }
  clear_has_providerid();
}
inline const ::std::string& PayOneBill::providerid() const {
  return *providerid_;
}
inline void PayOneBill::set_providerid(const ::std::string& value) {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  providerid_->assign(value);
}
inline void PayOneBill::set_providerid(const char* value) {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  providerid_->assign(value);
}
inline void PayOneBill::set_providerid(const char* value, size_t size) {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  providerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PayOneBill::mutable_providerid() {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  return providerid_;
}
inline ::std::string* PayOneBill::release_providerid() {
  clear_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = providerid_;
    providerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PayOneBill::set_allocated_providerid(::std::string* providerid) {
  if (providerid_ != &::google::protobuf::internal::kEmptyString) {
    delete providerid_;
  }
  if (providerid) {
    set_has_providerid();
    providerid_ = providerid;
  } else {
    clear_has_providerid();
    providerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string billId = 3;
inline bool PayOneBill::has_billid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PayOneBill::set_has_billid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PayOneBill::clear_has_billid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PayOneBill::clear_billid() {
  if (billid_ != &::google::protobuf::internal::kEmptyString) {
    billid_->clear();
  }
  clear_has_billid();
}
inline const ::std::string& PayOneBill::billid() const {
  return *billid_;
}
inline void PayOneBill::set_billid(const ::std::string& value) {
  set_has_billid();
  if (billid_ == &::google::protobuf::internal::kEmptyString) {
    billid_ = new ::std::string;
  }
  billid_->assign(value);
}
inline void PayOneBill::set_billid(const char* value) {
  set_has_billid();
  if (billid_ == &::google::protobuf::internal::kEmptyString) {
    billid_ = new ::std::string;
  }
  billid_->assign(value);
}
inline void PayOneBill::set_billid(const char* value, size_t size) {
  set_has_billid();
  if (billid_ == &::google::protobuf::internal::kEmptyString) {
    billid_ = new ::std::string;
  }
  billid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PayOneBill::mutable_billid() {
  set_has_billid();
  if (billid_ == &::google::protobuf::internal::kEmptyString) {
    billid_ = new ::std::string;
  }
  return billid_;
}
inline ::std::string* PayOneBill::release_billid() {
  clear_has_billid();
  if (billid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = billid_;
    billid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PayOneBill::set_allocated_billid(::std::string* billid) {
  if (billid_ != &::google::protobuf::internal::kEmptyString) {
    delete billid_;
  }
  if (billid) {
    set_has_billid();
    billid_ = billid;
  } else {
    clear_has_billid();
    billid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 amount = 4;
inline bool PayOneBill::has_amount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PayOneBill::set_has_amount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PayOneBill::clear_has_amount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PayOneBill::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 PayOneBill::amount() const {
  return amount_;
}
inline void PayOneBill::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
}

// optional string channel = 5;
inline bool PayOneBill::has_channel() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PayOneBill::set_has_channel() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PayOneBill::clear_has_channel() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PayOneBill::clear_channel() {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    channel_->clear();
  }
  clear_has_channel();
}
inline const ::std::string& PayOneBill::channel() const {
  return *channel_;
}
inline void PayOneBill::set_channel(const ::std::string& value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void PayOneBill::set_channel(const char* value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void PayOneBill::set_channel(const char* value, size_t size) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PayOneBill::mutable_channel() {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  return channel_;
}
inline ::std::string* PayOneBill::release_channel() {
  clear_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_;
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PayOneBill::set_allocated_channel(::std::string* channel) {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_;
  }
  if (channel) {
    set_has_channel();
    channel_ = channel;
  } else {
    clear_has_channel();
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .com.mservice.momo.msg.keyValuePair keyValuePairs = 6;
inline int PayOneBill::keyvaluepairs_size() const {
  return keyvaluepairs_.size();
}
inline void PayOneBill::clear_keyvaluepairs() {
  keyvaluepairs_.Clear();
}
inline const ::com::mservice::momo::msg::keyValuePair& PayOneBill::keyvaluepairs(int index) const {
  return keyvaluepairs_.Get(index);
}
inline ::com::mservice::momo::msg::keyValuePair* PayOneBill::mutable_keyvaluepairs(int index) {
  return keyvaluepairs_.Mutable(index);
}
inline ::com::mservice::momo::msg::keyValuePair* PayOneBill::add_keyvaluepairs() {
  return keyvaluepairs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >&
PayOneBill::keyvaluepairs() const {
  return keyvaluepairs_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >*
PayOneBill::mutable_keyvaluepairs() {
  return &keyvaluepairs_;
}

// -------------------------------------------------------------------

// PayMultiBills

// optional string pin = 1;
inline bool PayMultiBills::has_pin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PayMultiBills::set_has_pin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PayMultiBills::clear_has_pin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PayMultiBills::clear_pin() {
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    pin_->clear();
  }
  clear_has_pin();
}
inline const ::std::string& PayMultiBills::pin() const {
  return *pin_;
}
inline void PayMultiBills::set_pin(const ::std::string& value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void PayMultiBills::set_pin(const char* value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void PayMultiBills::set_pin(const char* value, size_t size) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PayMultiBills::mutable_pin() {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  return pin_;
}
inline ::std::string* PayMultiBills::release_pin() {
  clear_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pin_;
    pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PayMultiBills::set_allocated_pin(::std::string* pin) {
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    delete pin_;
  }
  if (pin) {
    set_has_pin();
    pin_ = pin;
  } else {
    clear_has_pin();
    pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string providerIds = 2;
inline bool PayMultiBills::has_providerids() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PayMultiBills::set_has_providerids() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PayMultiBills::clear_has_providerids() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PayMultiBills::clear_providerids() {
  if (providerids_ != &::google::protobuf::internal::kEmptyString) {
    providerids_->clear();
  }
  clear_has_providerids();
}
inline const ::std::string& PayMultiBills::providerids() const {
  return *providerids_;
}
inline void PayMultiBills::set_providerids(const ::std::string& value) {
  set_has_providerids();
  if (providerids_ == &::google::protobuf::internal::kEmptyString) {
    providerids_ = new ::std::string;
  }
  providerids_->assign(value);
}
inline void PayMultiBills::set_providerids(const char* value) {
  set_has_providerids();
  if (providerids_ == &::google::protobuf::internal::kEmptyString) {
    providerids_ = new ::std::string;
  }
  providerids_->assign(value);
}
inline void PayMultiBills::set_providerids(const char* value, size_t size) {
  set_has_providerids();
  if (providerids_ == &::google::protobuf::internal::kEmptyString) {
    providerids_ = new ::std::string;
  }
  providerids_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PayMultiBills::mutable_providerids() {
  set_has_providerids();
  if (providerids_ == &::google::protobuf::internal::kEmptyString) {
    providerids_ = new ::std::string;
  }
  return providerids_;
}
inline ::std::string* PayMultiBills::release_providerids() {
  clear_has_providerids();
  if (providerids_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = providerids_;
    providerids_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PayMultiBills::set_allocated_providerids(::std::string* providerids) {
  if (providerids_ != &::google::protobuf::internal::kEmptyString) {
    delete providerids_;
  }
  if (providerids) {
    set_has_providerids();
    providerids_ = providerids;
  } else {
    clear_has_providerids();
    providerids_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string billIds = 3;
inline bool PayMultiBills::has_billids() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PayMultiBills::set_has_billids() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PayMultiBills::clear_has_billids() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PayMultiBills::clear_billids() {
  if (billids_ != &::google::protobuf::internal::kEmptyString) {
    billids_->clear();
  }
  clear_has_billids();
}
inline const ::std::string& PayMultiBills::billids() const {
  return *billids_;
}
inline void PayMultiBills::set_billids(const ::std::string& value) {
  set_has_billids();
  if (billids_ == &::google::protobuf::internal::kEmptyString) {
    billids_ = new ::std::string;
  }
  billids_->assign(value);
}
inline void PayMultiBills::set_billids(const char* value) {
  set_has_billids();
  if (billids_ == &::google::protobuf::internal::kEmptyString) {
    billids_ = new ::std::string;
  }
  billids_->assign(value);
}
inline void PayMultiBills::set_billids(const char* value, size_t size) {
  set_has_billids();
  if (billids_ == &::google::protobuf::internal::kEmptyString) {
    billids_ = new ::std::string;
  }
  billids_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PayMultiBills::mutable_billids() {
  set_has_billids();
  if (billids_ == &::google::protobuf::internal::kEmptyString) {
    billids_ = new ::std::string;
  }
  return billids_;
}
inline ::std::string* PayMultiBills::release_billids() {
  clear_has_billids();
  if (billids_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = billids_;
    billids_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PayMultiBills::set_allocated_billids(::std::string* billids) {
  if (billids_ != &::google::protobuf::internal::kEmptyString) {
    delete billids_;
  }
  if (billids) {
    set_has_billids();
    billids_ = billids;
  } else {
    clear_has_billids();
    billids_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string amounts = 4;
inline bool PayMultiBills::has_amounts() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PayMultiBills::set_has_amounts() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PayMultiBills::clear_has_amounts() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PayMultiBills::clear_amounts() {
  if (amounts_ != &::google::protobuf::internal::kEmptyString) {
    amounts_->clear();
  }
  clear_has_amounts();
}
inline const ::std::string& PayMultiBills::amounts() const {
  return *amounts_;
}
inline void PayMultiBills::set_amounts(const ::std::string& value) {
  set_has_amounts();
  if (amounts_ == &::google::protobuf::internal::kEmptyString) {
    amounts_ = new ::std::string;
  }
  amounts_->assign(value);
}
inline void PayMultiBills::set_amounts(const char* value) {
  set_has_amounts();
  if (amounts_ == &::google::protobuf::internal::kEmptyString) {
    amounts_ = new ::std::string;
  }
  amounts_->assign(value);
}
inline void PayMultiBills::set_amounts(const char* value, size_t size) {
  set_has_amounts();
  if (amounts_ == &::google::protobuf::internal::kEmptyString) {
    amounts_ = new ::std::string;
  }
  amounts_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PayMultiBills::mutable_amounts() {
  set_has_amounts();
  if (amounts_ == &::google::protobuf::internal::kEmptyString) {
    amounts_ = new ::std::string;
  }
  return amounts_;
}
inline ::std::string* PayMultiBills::release_amounts() {
  clear_has_amounts();
  if (amounts_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = amounts_;
    amounts_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PayMultiBills::set_allocated_amounts(::std::string* amounts) {
  if (amounts_ != &::google::protobuf::internal::kEmptyString) {
    delete amounts_;
  }
  if (amounts) {
    set_has_amounts();
    amounts_ = amounts;
  } else {
    clear_has_amounts();
    amounts_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ViewPaymentHistoryByBillId

// optional string pin = 1;
inline bool ViewPaymentHistoryByBillId::has_pin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ViewPaymentHistoryByBillId::set_has_pin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ViewPaymentHistoryByBillId::clear_has_pin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ViewPaymentHistoryByBillId::clear_pin() {
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    pin_->clear();
  }
  clear_has_pin();
}
inline const ::std::string& ViewPaymentHistoryByBillId::pin() const {
  return *pin_;
}
inline void ViewPaymentHistoryByBillId::set_pin(const ::std::string& value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void ViewPaymentHistoryByBillId::set_pin(const char* value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void ViewPaymentHistoryByBillId::set_pin(const char* value, size_t size) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ViewPaymentHistoryByBillId::mutable_pin() {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  return pin_;
}
inline ::std::string* ViewPaymentHistoryByBillId::release_pin() {
  clear_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pin_;
    pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ViewPaymentHistoryByBillId::set_allocated_pin(::std::string* pin) {
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    delete pin_;
  }
  if (pin) {
    set_has_pin();
    pin_ = pin;
  } else {
    clear_has_pin();
    pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string billId = 2;
inline bool ViewPaymentHistoryByBillId::has_billid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ViewPaymentHistoryByBillId::set_has_billid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ViewPaymentHistoryByBillId::clear_has_billid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ViewPaymentHistoryByBillId::clear_billid() {
  if (billid_ != &::google::protobuf::internal::kEmptyString) {
    billid_->clear();
  }
  clear_has_billid();
}
inline const ::std::string& ViewPaymentHistoryByBillId::billid() const {
  return *billid_;
}
inline void ViewPaymentHistoryByBillId::set_billid(const ::std::string& value) {
  set_has_billid();
  if (billid_ == &::google::protobuf::internal::kEmptyString) {
    billid_ = new ::std::string;
  }
  billid_->assign(value);
}
inline void ViewPaymentHistoryByBillId::set_billid(const char* value) {
  set_has_billid();
  if (billid_ == &::google::protobuf::internal::kEmptyString) {
    billid_ = new ::std::string;
  }
  billid_->assign(value);
}
inline void ViewPaymentHistoryByBillId::set_billid(const char* value, size_t size) {
  set_has_billid();
  if (billid_ == &::google::protobuf::internal::kEmptyString) {
    billid_ = new ::std::string;
  }
  billid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ViewPaymentHistoryByBillId::mutable_billid() {
  set_has_billid();
  if (billid_ == &::google::protobuf::internal::kEmptyString) {
    billid_ = new ::std::string;
  }
  return billid_;
}
inline ::std::string* ViewPaymentHistoryByBillId::release_billid() {
  clear_has_billid();
  if (billid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = billid_;
    billid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ViewPaymentHistoryByBillId::set_allocated_billid(::std::string* billid) {
  if (billid_ != &::google::protobuf::internal::kEmptyString) {
    delete billid_;
  }
  if (billid) {
    set_has_billid();
    billid_ = billid;
  } else {
    clear_has_billid();
    billid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TopUpGame

// optional string mpin = 1;
inline bool TopUpGame::has_mpin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TopUpGame::set_has_mpin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TopUpGame::clear_has_mpin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TopUpGame::clear_mpin() {
  if (mpin_ != &::google::protobuf::internal::kEmptyString) {
    mpin_->clear();
  }
  clear_has_mpin();
}
inline const ::std::string& TopUpGame::mpin() const {
  return *mpin_;
}
inline void TopUpGame::set_mpin(const ::std::string& value) {
  set_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    mpin_ = new ::std::string;
  }
  mpin_->assign(value);
}
inline void TopUpGame::set_mpin(const char* value) {
  set_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    mpin_ = new ::std::string;
  }
  mpin_->assign(value);
}
inline void TopUpGame::set_mpin(const char* value, size_t size) {
  set_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    mpin_ = new ::std::string;
  }
  mpin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TopUpGame::mutable_mpin() {
  set_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    mpin_ = new ::std::string;
  }
  return mpin_;
}
inline ::std::string* TopUpGame::release_mpin() {
  clear_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mpin_;
    mpin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TopUpGame::set_allocated_mpin(::std::string* mpin) {
  if (mpin_ != &::google::protobuf::internal::kEmptyString) {
    delete mpin_;
  }
  if (mpin) {
    set_has_mpin();
    mpin_ = mpin;
  } else {
    clear_has_mpin();
    mpin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string providerId = 2;
inline bool TopUpGame::has_providerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TopUpGame::set_has_providerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TopUpGame::clear_has_providerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TopUpGame::clear_providerid() {
  if (providerid_ != &::google::protobuf::internal::kEmptyString) {
    providerid_->clear();
  }
  clear_has_providerid();
}
inline const ::std::string& TopUpGame::providerid() const {
  return *providerid_;
}
inline void TopUpGame::set_providerid(const ::std::string& value) {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  providerid_->assign(value);
}
inline void TopUpGame::set_providerid(const char* value) {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  providerid_->assign(value);
}
inline void TopUpGame::set_providerid(const char* value, size_t size) {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  providerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TopUpGame::mutable_providerid() {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  return providerid_;
}
inline ::std::string* TopUpGame::release_providerid() {
  clear_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = providerid_;
    providerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TopUpGame::set_allocated_providerid(::std::string* providerid) {
  if (providerid_ != &::google::protobuf::internal::kEmptyString) {
    delete providerid_;
  }
  if (providerid) {
    set_has_providerid();
    providerid_ = providerid;
  } else {
    clear_has_providerid();
    providerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 amount = 3;
inline bool TopUpGame::has_amount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TopUpGame::set_has_amount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TopUpGame::clear_has_amount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TopUpGame::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 TopUpGame::amount() const {
  return amount_;
}
inline void TopUpGame::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
}

// optional string game_account = 4;
inline bool TopUpGame::has_game_account() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TopUpGame::set_has_game_account() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TopUpGame::clear_has_game_account() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TopUpGame::clear_game_account() {
  if (game_account_ != &::google::protobuf::internal::kEmptyString) {
    game_account_->clear();
  }
  clear_has_game_account();
}
inline const ::std::string& TopUpGame::game_account() const {
  return *game_account_;
}
inline void TopUpGame::set_game_account(const ::std::string& value) {
  set_has_game_account();
  if (game_account_ == &::google::protobuf::internal::kEmptyString) {
    game_account_ = new ::std::string;
  }
  game_account_->assign(value);
}
inline void TopUpGame::set_game_account(const char* value) {
  set_has_game_account();
  if (game_account_ == &::google::protobuf::internal::kEmptyString) {
    game_account_ = new ::std::string;
  }
  game_account_->assign(value);
}
inline void TopUpGame::set_game_account(const char* value, size_t size) {
  set_has_game_account();
  if (game_account_ == &::google::protobuf::internal::kEmptyString) {
    game_account_ = new ::std::string;
  }
  game_account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TopUpGame::mutable_game_account() {
  set_has_game_account();
  if (game_account_ == &::google::protobuf::internal::kEmptyString) {
    game_account_ = new ::std::string;
  }
  return game_account_;
}
inline ::std::string* TopUpGame::release_game_account() {
  clear_has_game_account();
  if (game_account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = game_account_;
    game_account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TopUpGame::set_allocated_game_account(::std::string* game_account) {
  if (game_account_ != &::google::protobuf::internal::kEmptyString) {
    delete game_account_;
  }
  if (game_account) {
    set_has_game_account();
    game_account_ = game_account;
  } else {
    clear_has_game_account();
    game_account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string channel = 5;
inline bool TopUpGame::has_channel() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TopUpGame::set_has_channel() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TopUpGame::clear_has_channel() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TopUpGame::clear_channel() {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    channel_->clear();
  }
  clear_has_channel();
}
inline const ::std::string& TopUpGame::channel() const {
  return *channel_;
}
inline void TopUpGame::set_channel(const ::std::string& value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void TopUpGame::set_channel(const char* value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void TopUpGame::set_channel(const char* value, size_t size) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TopUpGame::mutable_channel() {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  return channel_;
}
inline ::std::string* TopUpGame::release_channel() {
  clear_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_;
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TopUpGame::set_allocated_channel(::std::string* channel) {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_;
  }
  if (channel) {
    set_has_channel();
    channel_ = channel;
  } else {
    clear_has_channel();
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .com.mservice.momo.msg.keyValuePair keyValuePairs = 6;
inline int TopUpGame::keyvaluepairs_size() const {
  return keyvaluepairs_.size();
}
inline void TopUpGame::clear_keyvaluepairs() {
  keyvaluepairs_.Clear();
}
inline const ::com::mservice::momo::msg::keyValuePair& TopUpGame::keyvaluepairs(int index) const {
  return keyvaluepairs_.Get(index);
}
inline ::com::mservice::momo::msg::keyValuePair* TopUpGame::mutable_keyvaluepairs(int index) {
  return keyvaluepairs_.Mutable(index);
}
inline ::com::mservice::momo::msg::keyValuePair* TopUpGame::add_keyvaluepairs() {
  return keyvaluepairs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >&
TopUpGame::keyvaluepairs() const {
  return keyvaluepairs_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >*
TopUpGame::mutable_keyvaluepairs() {
  return &keyvaluepairs_;
}

// -------------------------------------------------------------------

// CheckPhoneDetail

// optional string number = 1;
inline bool CheckPhoneDetail::has_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckPhoneDetail::set_has_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckPhoneDetail::clear_has_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckPhoneDetail::clear_number() {
  if (number_ != &::google::protobuf::internal::kEmptyString) {
    number_->clear();
  }
  clear_has_number();
}
inline const ::std::string& CheckPhoneDetail::number() const {
  return *number_;
}
inline void CheckPhoneDetail::set_number(const ::std::string& value) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  number_->assign(value);
}
inline void CheckPhoneDetail::set_number(const char* value) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  number_->assign(value);
}
inline void CheckPhoneDetail::set_number(const char* value, size_t size) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  number_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CheckPhoneDetail::mutable_number() {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  return number_;
}
inline ::std::string* CheckPhoneDetail::release_number() {
  clear_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = number_;
    number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CheckPhoneDetail::set_allocated_number(::std::string* number) {
  if (number_ != &::google::protobuf::internal::kEmptyString) {
    delete number_;
  }
  if (number) {
    set_has_number();
    number_ = number;
  } else {
    clear_has_number();
    number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GetStoreAround

// optional double lng = 1;
inline bool GetStoreAround::has_lng() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetStoreAround::set_has_lng() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetStoreAround::clear_has_lng() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetStoreAround::clear_lng() {
  lng_ = 0;
  clear_has_lng();
}
inline double GetStoreAround::lng() const {
  return lng_;
}
inline void GetStoreAround::set_lng(double value) {
  set_has_lng();
  lng_ = value;
}

// optional double lat = 2;
inline bool GetStoreAround::has_lat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetStoreAround::set_has_lat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetStoreAround::clear_has_lat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetStoreAround::clear_lat() {
  lat_ = 0;
  clear_has_lat();
}
inline double GetStoreAround::lat() const {
  return lat_;
}
inline void GetStoreAround::set_lat(double value) {
  set_has_lat();
  lat_ = value;
}

// optional string street = 3;
inline bool GetStoreAround::has_street() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetStoreAround::set_has_street() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetStoreAround::clear_has_street() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetStoreAround::clear_street() {
  if (street_ != &::google::protobuf::internal::kEmptyString) {
    street_->clear();
  }
  clear_has_street();
}
inline const ::std::string& GetStoreAround::street() const {
  return *street_;
}
inline void GetStoreAround::set_street(const ::std::string& value) {
  set_has_street();
  if (street_ == &::google::protobuf::internal::kEmptyString) {
    street_ = new ::std::string;
  }
  street_->assign(value);
}
inline void GetStoreAround::set_street(const char* value) {
  set_has_street();
  if (street_ == &::google::protobuf::internal::kEmptyString) {
    street_ = new ::std::string;
  }
  street_->assign(value);
}
inline void GetStoreAround::set_street(const char* value, size_t size) {
  set_has_street();
  if (street_ == &::google::protobuf::internal::kEmptyString) {
    street_ = new ::std::string;
  }
  street_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetStoreAround::mutable_street() {
  set_has_street();
  if (street_ == &::google::protobuf::internal::kEmptyString) {
    street_ = new ::std::string;
  }
  return street_;
}
inline ::std::string* GetStoreAround::release_street() {
  clear_has_street();
  if (street_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = street_;
    street_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetStoreAround::set_allocated_street(::std::string* street) {
  if (street_ != &::google::protobuf::internal::kEmptyString) {
    delete street_;
  }
  if (street) {
    set_has_street();
    street_ = street;
  } else {
    clear_has_street();
    street_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ward = 4;
inline bool GetStoreAround::has_ward() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetStoreAround::set_has_ward() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetStoreAround::clear_has_ward() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetStoreAround::clear_ward() {
  if (ward_ != &::google::protobuf::internal::kEmptyString) {
    ward_->clear();
  }
  clear_has_ward();
}
inline const ::std::string& GetStoreAround::ward() const {
  return *ward_;
}
inline void GetStoreAround::set_ward(const ::std::string& value) {
  set_has_ward();
  if (ward_ == &::google::protobuf::internal::kEmptyString) {
    ward_ = new ::std::string;
  }
  ward_->assign(value);
}
inline void GetStoreAround::set_ward(const char* value) {
  set_has_ward();
  if (ward_ == &::google::protobuf::internal::kEmptyString) {
    ward_ = new ::std::string;
  }
  ward_->assign(value);
}
inline void GetStoreAround::set_ward(const char* value, size_t size) {
  set_has_ward();
  if (ward_ == &::google::protobuf::internal::kEmptyString) {
    ward_ = new ::std::string;
  }
  ward_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetStoreAround::mutable_ward() {
  set_has_ward();
  if (ward_ == &::google::protobuf::internal::kEmptyString) {
    ward_ = new ::std::string;
  }
  return ward_;
}
inline ::std::string* GetStoreAround::release_ward() {
  clear_has_ward();
  if (ward_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ward_;
    ward_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetStoreAround::set_allocated_ward(::std::string* ward) {
  if (ward_ != &::google::protobuf::internal::kEmptyString) {
    delete ward_;
  }
  if (ward) {
    set_has_ward();
    ward_ = ward;
  } else {
    clear_has_ward();
    ward_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string district = 5;
inline bool GetStoreAround::has_district() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetStoreAround::set_has_district() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetStoreAround::clear_has_district() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetStoreAround::clear_district() {
  if (district_ != &::google::protobuf::internal::kEmptyString) {
    district_->clear();
  }
  clear_has_district();
}
inline const ::std::string& GetStoreAround::district() const {
  return *district_;
}
inline void GetStoreAround::set_district(const ::std::string& value) {
  set_has_district();
  if (district_ == &::google::protobuf::internal::kEmptyString) {
    district_ = new ::std::string;
  }
  district_->assign(value);
}
inline void GetStoreAround::set_district(const char* value) {
  set_has_district();
  if (district_ == &::google::protobuf::internal::kEmptyString) {
    district_ = new ::std::string;
  }
  district_->assign(value);
}
inline void GetStoreAround::set_district(const char* value, size_t size) {
  set_has_district();
  if (district_ == &::google::protobuf::internal::kEmptyString) {
    district_ = new ::std::string;
  }
  district_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetStoreAround::mutable_district() {
  set_has_district();
  if (district_ == &::google::protobuf::internal::kEmptyString) {
    district_ = new ::std::string;
  }
  return district_;
}
inline ::std::string* GetStoreAround::release_district() {
  clear_has_district();
  if (district_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = district_;
    district_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetStoreAround::set_allocated_district(::std::string* district) {
  if (district_ != &::google::protobuf::internal::kEmptyString) {
    delete district_;
  }
  if (district) {
    set_has_district();
    district_ = district;
  } else {
    clear_has_district();
    district_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string city = 6;
inline bool GetStoreAround::has_city() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GetStoreAround::set_has_city() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GetStoreAround::clear_has_city() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GetStoreAround::clear_city() {
  if (city_ != &::google::protobuf::internal::kEmptyString) {
    city_->clear();
  }
  clear_has_city();
}
inline const ::std::string& GetStoreAround::city() const {
  return *city_;
}
inline void GetStoreAround::set_city(const ::std::string& value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(value);
}
inline void GetStoreAround::set_city(const char* value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(value);
}
inline void GetStoreAround::set_city(const char* value, size_t size) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetStoreAround::mutable_city() {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  return city_;
}
inline ::std::string* GetStoreAround::release_city() {
  clear_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = city_;
    city_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetStoreAround::set_allocated_city(::std::string* city) {
  if (city_ != &::google::protobuf::internal::kEmptyString) {
    delete city_;
  }
  if (city) {
    set_has_city();
    city_ = city;
  } else {
    clear_has_city();
    city_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string area = 7;
inline bool GetStoreAround::has_area() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GetStoreAround::set_has_area() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GetStoreAround::clear_has_area() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GetStoreAround::clear_area() {
  if (area_ != &::google::protobuf::internal::kEmptyString) {
    area_->clear();
  }
  clear_has_area();
}
inline const ::std::string& GetStoreAround::area() const {
  return *area_;
}
inline void GetStoreAround::set_area(const ::std::string& value) {
  set_has_area();
  if (area_ == &::google::protobuf::internal::kEmptyString) {
    area_ = new ::std::string;
  }
  area_->assign(value);
}
inline void GetStoreAround::set_area(const char* value) {
  set_has_area();
  if (area_ == &::google::protobuf::internal::kEmptyString) {
    area_ = new ::std::string;
  }
  area_->assign(value);
}
inline void GetStoreAround::set_area(const char* value, size_t size) {
  set_has_area();
  if (area_ == &::google::protobuf::internal::kEmptyString) {
    area_ = new ::std::string;
  }
  area_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetStoreAround::mutable_area() {
  set_has_area();
  if (area_ == &::google::protobuf::internal::kEmptyString) {
    area_ = new ::std::string;
  }
  return area_;
}
inline ::std::string* GetStoreAround::release_area() {
  clear_has_area();
  if (area_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = area_;
    area_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetStoreAround::set_allocated_area(::std::string* area) {
  if (area_ != &::google::protobuf::internal::kEmptyString) {
    delete area_;
  }
  if (area) {
    set_has_area();
    area_ = area;
  } else {
    clear_has_area();
    area_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 limit = 8;
inline bool GetStoreAround::has_limit() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GetStoreAround::set_has_limit() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GetStoreAround::clear_has_limit() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GetStoreAround::clear_limit() {
  limit_ = 0u;
  clear_has_limit();
}
inline ::google::protobuf::uint32 GetStoreAround::limit() const {
  return limit_;
}
inline void GetStoreAround::set_limit(::google::protobuf::uint32 value) {
  set_has_limit();
  limit_ = value;
}

// -------------------------------------------------------------------

// QuickDeposit

// optional string providerId = 1;
inline bool QuickDeposit::has_providerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QuickDeposit::set_has_providerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QuickDeposit::clear_has_providerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QuickDeposit::clear_providerid() {
  if (providerid_ != &::google::protobuf::internal::kEmptyString) {
    providerid_->clear();
  }
  clear_has_providerid();
}
inline const ::std::string& QuickDeposit::providerid() const {
  return *providerid_;
}
inline void QuickDeposit::set_providerid(const ::std::string& value) {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  providerid_->assign(value);
}
inline void QuickDeposit::set_providerid(const char* value) {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  providerid_->assign(value);
}
inline void QuickDeposit::set_providerid(const char* value, size_t size) {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  providerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QuickDeposit::mutable_providerid() {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  return providerid_;
}
inline ::std::string* QuickDeposit::release_providerid() {
  clear_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = providerid_;
    providerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QuickDeposit::set_allocated_providerid(::std::string* providerid) {
  if (providerid_ != &::google::protobuf::internal::kEmptyString) {
    delete providerid_;
  }
  if (providerid) {
    set_has_providerid();
    providerid_ = providerid;
  } else {
    clear_has_providerid();
    providerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string tellerId = 2;
inline bool QuickDeposit::has_tellerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QuickDeposit::set_has_tellerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QuickDeposit::clear_has_tellerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QuickDeposit::clear_tellerid() {
  if (tellerid_ != &::google::protobuf::internal::kEmptyString) {
    tellerid_->clear();
  }
  clear_has_tellerid();
}
inline const ::std::string& QuickDeposit::tellerid() const {
  return *tellerid_;
}
inline void QuickDeposit::set_tellerid(const ::std::string& value) {
  set_has_tellerid();
  if (tellerid_ == &::google::protobuf::internal::kEmptyString) {
    tellerid_ = new ::std::string;
  }
  tellerid_->assign(value);
}
inline void QuickDeposit::set_tellerid(const char* value) {
  set_has_tellerid();
  if (tellerid_ == &::google::protobuf::internal::kEmptyString) {
    tellerid_ = new ::std::string;
  }
  tellerid_->assign(value);
}
inline void QuickDeposit::set_tellerid(const char* value, size_t size) {
  set_has_tellerid();
  if (tellerid_ == &::google::protobuf::internal::kEmptyString) {
    tellerid_ = new ::std::string;
  }
  tellerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QuickDeposit::mutable_tellerid() {
  set_has_tellerid();
  if (tellerid_ == &::google::protobuf::internal::kEmptyString) {
    tellerid_ = new ::std::string;
  }
  return tellerid_;
}
inline ::std::string* QuickDeposit::release_tellerid() {
  clear_has_tellerid();
  if (tellerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tellerid_;
    tellerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QuickDeposit::set_allocated_tellerid(::std::string* tellerid) {
  if (tellerid_ != &::google::protobuf::internal::kEmptyString) {
    delete tellerid_;
  }
  if (tellerid) {
    set_has_tellerid();
    tellerid_ = tellerid;
  } else {
    clear_has_tellerid();
    tellerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string billId = 3;
inline bool QuickDeposit::has_billid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void QuickDeposit::set_has_billid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void QuickDeposit::clear_has_billid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void QuickDeposit::clear_billid() {
  if (billid_ != &::google::protobuf::internal::kEmptyString) {
    billid_->clear();
  }
  clear_has_billid();
}
inline const ::std::string& QuickDeposit::billid() const {
  return *billid_;
}
inline void QuickDeposit::set_billid(const ::std::string& value) {
  set_has_billid();
  if (billid_ == &::google::protobuf::internal::kEmptyString) {
    billid_ = new ::std::string;
  }
  billid_->assign(value);
}
inline void QuickDeposit::set_billid(const char* value) {
  set_has_billid();
  if (billid_ == &::google::protobuf::internal::kEmptyString) {
    billid_ = new ::std::string;
  }
  billid_->assign(value);
}
inline void QuickDeposit::set_billid(const char* value, size_t size) {
  set_has_billid();
  if (billid_ == &::google::protobuf::internal::kEmptyString) {
    billid_ = new ::std::string;
  }
  billid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QuickDeposit::mutable_billid() {
  set_has_billid();
  if (billid_ == &::google::protobuf::internal::kEmptyString) {
    billid_ = new ::std::string;
  }
  return billid_;
}
inline ::std::string* QuickDeposit::release_billid() {
  clear_has_billid();
  if (billid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = billid_;
    billid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QuickDeposit::set_allocated_billid(::std::string* billid) {
  if (billid_ != &::google::protobuf::internal::kEmptyString) {
    delete billid_;
  }
  if (billid) {
    set_has_billid();
    billid_ = billid;
  } else {
    clear_has_billid();
    billid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 amount = 4;
inline bool QuickDeposit::has_amount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void QuickDeposit::set_has_amount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void QuickDeposit::clear_has_amount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void QuickDeposit::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 QuickDeposit::amount() const {
  return amount_;
}
inline void QuickDeposit::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
}

// optional string pin = 5;
inline bool QuickDeposit::has_pin() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void QuickDeposit::set_has_pin() {
  _has_bits_[0] |= 0x00000010u;
}
inline void QuickDeposit::clear_has_pin() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void QuickDeposit::clear_pin() {
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    pin_->clear();
  }
  clear_has_pin();
}
inline const ::std::string& QuickDeposit::pin() const {
  return *pin_;
}
inline void QuickDeposit::set_pin(const ::std::string& value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void QuickDeposit::set_pin(const char* value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void QuickDeposit::set_pin(const char* value, size_t size) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QuickDeposit::mutable_pin() {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  return pin_;
}
inline ::std::string* QuickDeposit::release_pin() {
  clear_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pin_;
    pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QuickDeposit::set_allocated_pin(::std::string* pin) {
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    delete pin_;
  }
  if (pin) {
    set_has_pin();
    pin_ = pin;
  } else {
    clear_has_pin();
    pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string channel = 6;
inline bool QuickDeposit::has_channel() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void QuickDeposit::set_has_channel() {
  _has_bits_[0] |= 0x00000020u;
}
inline void QuickDeposit::clear_has_channel() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void QuickDeposit::clear_channel() {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    channel_->clear();
  }
  clear_has_channel();
}
inline const ::std::string& QuickDeposit::channel() const {
  return *channel_;
}
inline void QuickDeposit::set_channel(const ::std::string& value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void QuickDeposit::set_channel(const char* value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void QuickDeposit::set_channel(const char* value, size_t size) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QuickDeposit::mutable_channel() {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  return channel_;
}
inline ::std::string* QuickDeposit::release_channel() {
  clear_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_;
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QuickDeposit::set_allocated_channel(::std::string* channel) {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_;
  }
  if (channel) {
    set_has_channel();
    channel_ = channel;
  } else {
    clear_has_channel();
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// QuickPayment

// optional string providerId = 1;
inline bool QuickPayment::has_providerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QuickPayment::set_has_providerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QuickPayment::clear_has_providerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QuickPayment::clear_providerid() {
  if (providerid_ != &::google::protobuf::internal::kEmptyString) {
    providerid_->clear();
  }
  clear_has_providerid();
}
inline const ::std::string& QuickPayment::providerid() const {
  return *providerid_;
}
inline void QuickPayment::set_providerid(const ::std::string& value) {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  providerid_->assign(value);
}
inline void QuickPayment::set_providerid(const char* value) {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  providerid_->assign(value);
}
inline void QuickPayment::set_providerid(const char* value, size_t size) {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  providerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QuickPayment::mutable_providerid() {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  return providerid_;
}
inline ::std::string* QuickPayment::release_providerid() {
  clear_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = providerid_;
    providerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QuickPayment::set_allocated_providerid(::std::string* providerid) {
  if (providerid_ != &::google::protobuf::internal::kEmptyString) {
    delete providerid_;
  }
  if (providerid) {
    set_has_providerid();
    providerid_ = providerid;
  } else {
    clear_has_providerid();
    providerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string tellerId = 2;
inline bool QuickPayment::has_tellerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QuickPayment::set_has_tellerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QuickPayment::clear_has_tellerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QuickPayment::clear_tellerid() {
  if (tellerid_ != &::google::protobuf::internal::kEmptyString) {
    tellerid_->clear();
  }
  clear_has_tellerid();
}
inline const ::std::string& QuickPayment::tellerid() const {
  return *tellerid_;
}
inline void QuickPayment::set_tellerid(const ::std::string& value) {
  set_has_tellerid();
  if (tellerid_ == &::google::protobuf::internal::kEmptyString) {
    tellerid_ = new ::std::string;
  }
  tellerid_->assign(value);
}
inline void QuickPayment::set_tellerid(const char* value) {
  set_has_tellerid();
  if (tellerid_ == &::google::protobuf::internal::kEmptyString) {
    tellerid_ = new ::std::string;
  }
  tellerid_->assign(value);
}
inline void QuickPayment::set_tellerid(const char* value, size_t size) {
  set_has_tellerid();
  if (tellerid_ == &::google::protobuf::internal::kEmptyString) {
    tellerid_ = new ::std::string;
  }
  tellerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QuickPayment::mutable_tellerid() {
  set_has_tellerid();
  if (tellerid_ == &::google::protobuf::internal::kEmptyString) {
    tellerid_ = new ::std::string;
  }
  return tellerid_;
}
inline ::std::string* QuickPayment::release_tellerid() {
  clear_has_tellerid();
  if (tellerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tellerid_;
    tellerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QuickPayment::set_allocated_tellerid(::std::string* tellerid) {
  if (tellerid_ != &::google::protobuf::internal::kEmptyString) {
    delete tellerid_;
  }
  if (tellerid) {
    set_has_tellerid();
    tellerid_ = tellerid;
  } else {
    clear_has_tellerid();
    tellerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string billId = 3;
inline bool QuickPayment::has_billid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void QuickPayment::set_has_billid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void QuickPayment::clear_has_billid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void QuickPayment::clear_billid() {
  if (billid_ != &::google::protobuf::internal::kEmptyString) {
    billid_->clear();
  }
  clear_has_billid();
}
inline const ::std::string& QuickPayment::billid() const {
  return *billid_;
}
inline void QuickPayment::set_billid(const ::std::string& value) {
  set_has_billid();
  if (billid_ == &::google::protobuf::internal::kEmptyString) {
    billid_ = new ::std::string;
  }
  billid_->assign(value);
}
inline void QuickPayment::set_billid(const char* value) {
  set_has_billid();
  if (billid_ == &::google::protobuf::internal::kEmptyString) {
    billid_ = new ::std::string;
  }
  billid_->assign(value);
}
inline void QuickPayment::set_billid(const char* value, size_t size) {
  set_has_billid();
  if (billid_ == &::google::protobuf::internal::kEmptyString) {
    billid_ = new ::std::string;
  }
  billid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QuickPayment::mutable_billid() {
  set_has_billid();
  if (billid_ == &::google::protobuf::internal::kEmptyString) {
    billid_ = new ::std::string;
  }
  return billid_;
}
inline ::std::string* QuickPayment::release_billid() {
  clear_has_billid();
  if (billid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = billid_;
    billid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QuickPayment::set_allocated_billid(::std::string* billid) {
  if (billid_ != &::google::protobuf::internal::kEmptyString) {
    delete billid_;
  }
  if (billid) {
    set_has_billid();
    billid_ = billid;
  } else {
    clear_has_billid();
    billid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 amount = 4;
inline bool QuickPayment::has_amount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void QuickPayment::set_has_amount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void QuickPayment::clear_has_amount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void QuickPayment::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 QuickPayment::amount() const {
  return amount_;
}
inline void QuickPayment::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
}

// optional string pin = 5;
inline bool QuickPayment::has_pin() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void QuickPayment::set_has_pin() {
  _has_bits_[0] |= 0x00000010u;
}
inline void QuickPayment::clear_has_pin() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void QuickPayment::clear_pin() {
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    pin_->clear();
  }
  clear_has_pin();
}
inline const ::std::string& QuickPayment::pin() const {
  return *pin_;
}
inline void QuickPayment::set_pin(const ::std::string& value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void QuickPayment::set_pin(const char* value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void QuickPayment::set_pin(const char* value, size_t size) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QuickPayment::mutable_pin() {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  return pin_;
}
inline ::std::string* QuickPayment::release_pin() {
  clear_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pin_;
    pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QuickPayment::set_allocated_pin(::std::string* pin) {
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    delete pin_;
  }
  if (pin) {
    set_has_pin();
    pin_ = pin;
  } else {
    clear_has_pin();
    pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string channel = 6;
inline bool QuickPayment::has_channel() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void QuickPayment::set_has_channel() {
  _has_bits_[0] |= 0x00000020u;
}
inline void QuickPayment::clear_has_channel() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void QuickPayment::clear_channel() {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    channel_->clear();
  }
  clear_has_channel();
}
inline const ::std::string& QuickPayment::channel() const {
  return *channel_;
}
inline void QuickPayment::set_channel(const ::std::string& value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void QuickPayment::set_channel(const char* value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void QuickPayment::set_channel(const char* value, size_t size) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QuickPayment::mutable_channel() {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  return channel_;
}
inline ::std::string* QuickPayment::release_channel() {
  clear_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_;
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QuickPayment::set_allocated_channel(::std::string* channel) {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_;
  }
  if (channel) {
    set_has_channel();
    channel_ = channel;
  } else {
    clear_has_channel();
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// BankNetToMomo

// optional uint64 amount = 1;
inline bool BankNetToMomo::has_amount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BankNetToMomo::set_has_amount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BankNetToMomo::clear_has_amount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BankNetToMomo::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 BankNetToMomo::amount() const {
  return amount_;
}
inline void BankNetToMomo::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
}

// optional string bankId = 2;
inline bool BankNetToMomo::has_bankid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BankNetToMomo::set_has_bankid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BankNetToMomo::clear_has_bankid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BankNetToMomo::clear_bankid() {
  if (bankid_ != &::google::protobuf::internal::kEmptyString) {
    bankid_->clear();
  }
  clear_has_bankid();
}
inline const ::std::string& BankNetToMomo::bankid() const {
  return *bankid_;
}
inline void BankNetToMomo::set_bankid(const ::std::string& value) {
  set_has_bankid();
  if (bankid_ == &::google::protobuf::internal::kEmptyString) {
    bankid_ = new ::std::string;
  }
  bankid_->assign(value);
}
inline void BankNetToMomo::set_bankid(const char* value) {
  set_has_bankid();
  if (bankid_ == &::google::protobuf::internal::kEmptyString) {
    bankid_ = new ::std::string;
  }
  bankid_->assign(value);
}
inline void BankNetToMomo::set_bankid(const char* value, size_t size) {
  set_has_bankid();
  if (bankid_ == &::google::protobuf::internal::kEmptyString) {
    bankid_ = new ::std::string;
  }
  bankid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BankNetToMomo::mutable_bankid() {
  set_has_bankid();
  if (bankid_ == &::google::protobuf::internal::kEmptyString) {
    bankid_ = new ::std::string;
  }
  return bankid_;
}
inline ::std::string* BankNetToMomo::release_bankid() {
  clear_has_bankid();
  if (bankid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bankid_;
    bankid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BankNetToMomo::set_allocated_bankid(::std::string* bankid) {
  if (bankid_ != &::google::protobuf::internal::kEmptyString) {
    delete bankid_;
  }
  if (bankid) {
    set_has_bankid();
    bankid_ = bankid;
  } else {
    clear_has_bankid();
    bankid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string card_holder_name = 3;
inline bool BankNetToMomo::has_card_holder_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BankNetToMomo::set_has_card_holder_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BankNetToMomo::clear_has_card_holder_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BankNetToMomo::clear_card_holder_name() {
  if (card_holder_name_ != &::google::protobuf::internal::kEmptyString) {
    card_holder_name_->clear();
  }
  clear_has_card_holder_name();
}
inline const ::std::string& BankNetToMomo::card_holder_name() const {
  return *card_holder_name_;
}
inline void BankNetToMomo::set_card_holder_name(const ::std::string& value) {
  set_has_card_holder_name();
  if (card_holder_name_ == &::google::protobuf::internal::kEmptyString) {
    card_holder_name_ = new ::std::string;
  }
  card_holder_name_->assign(value);
}
inline void BankNetToMomo::set_card_holder_name(const char* value) {
  set_has_card_holder_name();
  if (card_holder_name_ == &::google::protobuf::internal::kEmptyString) {
    card_holder_name_ = new ::std::string;
  }
  card_holder_name_->assign(value);
}
inline void BankNetToMomo::set_card_holder_name(const char* value, size_t size) {
  set_has_card_holder_name();
  if (card_holder_name_ == &::google::protobuf::internal::kEmptyString) {
    card_holder_name_ = new ::std::string;
  }
  card_holder_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BankNetToMomo::mutable_card_holder_name() {
  set_has_card_holder_name();
  if (card_holder_name_ == &::google::protobuf::internal::kEmptyString) {
    card_holder_name_ = new ::std::string;
  }
  return card_holder_name_;
}
inline ::std::string* BankNetToMomo::release_card_holder_name() {
  clear_has_card_holder_name();
  if (card_holder_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = card_holder_name_;
    card_holder_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BankNetToMomo::set_allocated_card_holder_name(::std::string* card_holder_name) {
  if (card_holder_name_ != &::google::protobuf::internal::kEmptyString) {
    delete card_holder_name_;
  }
  if (card_holder_name) {
    set_has_card_holder_name();
    card_holder_name_ = card_holder_name;
  } else {
    clear_has_card_holder_name();
    card_holder_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string card_holder_number = 4;
inline bool BankNetToMomo::has_card_holder_number() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BankNetToMomo::set_has_card_holder_number() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BankNetToMomo::clear_has_card_holder_number() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BankNetToMomo::clear_card_holder_number() {
  if (card_holder_number_ != &::google::protobuf::internal::kEmptyString) {
    card_holder_number_->clear();
  }
  clear_has_card_holder_number();
}
inline const ::std::string& BankNetToMomo::card_holder_number() const {
  return *card_holder_number_;
}
inline void BankNetToMomo::set_card_holder_number(const ::std::string& value) {
  set_has_card_holder_number();
  if (card_holder_number_ == &::google::protobuf::internal::kEmptyString) {
    card_holder_number_ = new ::std::string;
  }
  card_holder_number_->assign(value);
}
inline void BankNetToMomo::set_card_holder_number(const char* value) {
  set_has_card_holder_number();
  if (card_holder_number_ == &::google::protobuf::internal::kEmptyString) {
    card_holder_number_ = new ::std::string;
  }
  card_holder_number_->assign(value);
}
inline void BankNetToMomo::set_card_holder_number(const char* value, size_t size) {
  set_has_card_holder_number();
  if (card_holder_number_ == &::google::protobuf::internal::kEmptyString) {
    card_holder_number_ = new ::std::string;
  }
  card_holder_number_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BankNetToMomo::mutable_card_holder_number() {
  set_has_card_holder_number();
  if (card_holder_number_ == &::google::protobuf::internal::kEmptyString) {
    card_holder_number_ = new ::std::string;
  }
  return card_holder_number_;
}
inline ::std::string* BankNetToMomo::release_card_holder_number() {
  clear_has_card_holder_number();
  if (card_holder_number_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = card_holder_number_;
    card_holder_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BankNetToMomo::set_allocated_card_holder_number(::std::string* card_holder_number) {
  if (card_holder_number_ != &::google::protobuf::internal::kEmptyString) {
    delete card_holder_number_;
  }
  if (card_holder_number) {
    set_has_card_holder_number();
    card_holder_number_ = card_holder_number;
  } else {
    clear_has_card_holder_number();
    card_holder_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string card_holder_month = 5;
inline bool BankNetToMomo::has_card_holder_month() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BankNetToMomo::set_has_card_holder_month() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BankNetToMomo::clear_has_card_holder_month() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BankNetToMomo::clear_card_holder_month() {
  if (card_holder_month_ != &::google::protobuf::internal::kEmptyString) {
    card_holder_month_->clear();
  }
  clear_has_card_holder_month();
}
inline const ::std::string& BankNetToMomo::card_holder_month() const {
  return *card_holder_month_;
}
inline void BankNetToMomo::set_card_holder_month(const ::std::string& value) {
  set_has_card_holder_month();
  if (card_holder_month_ == &::google::protobuf::internal::kEmptyString) {
    card_holder_month_ = new ::std::string;
  }
  card_holder_month_->assign(value);
}
inline void BankNetToMomo::set_card_holder_month(const char* value) {
  set_has_card_holder_month();
  if (card_holder_month_ == &::google::protobuf::internal::kEmptyString) {
    card_holder_month_ = new ::std::string;
  }
  card_holder_month_->assign(value);
}
inline void BankNetToMomo::set_card_holder_month(const char* value, size_t size) {
  set_has_card_holder_month();
  if (card_holder_month_ == &::google::protobuf::internal::kEmptyString) {
    card_holder_month_ = new ::std::string;
  }
  card_holder_month_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BankNetToMomo::mutable_card_holder_month() {
  set_has_card_holder_month();
  if (card_holder_month_ == &::google::protobuf::internal::kEmptyString) {
    card_holder_month_ = new ::std::string;
  }
  return card_holder_month_;
}
inline ::std::string* BankNetToMomo::release_card_holder_month() {
  clear_has_card_holder_month();
  if (card_holder_month_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = card_holder_month_;
    card_holder_month_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BankNetToMomo::set_allocated_card_holder_month(::std::string* card_holder_month) {
  if (card_holder_month_ != &::google::protobuf::internal::kEmptyString) {
    delete card_holder_month_;
  }
  if (card_holder_month) {
    set_has_card_holder_month();
    card_holder_month_ = card_holder_month;
  } else {
    clear_has_card_holder_month();
    card_holder_month_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string card_holder_year = 6;
inline bool BankNetToMomo::has_card_holder_year() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BankNetToMomo::set_has_card_holder_year() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BankNetToMomo::clear_has_card_holder_year() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BankNetToMomo::clear_card_holder_year() {
  if (card_holder_year_ != &::google::protobuf::internal::kEmptyString) {
    card_holder_year_->clear();
  }
  clear_has_card_holder_year();
}
inline const ::std::string& BankNetToMomo::card_holder_year() const {
  return *card_holder_year_;
}
inline void BankNetToMomo::set_card_holder_year(const ::std::string& value) {
  set_has_card_holder_year();
  if (card_holder_year_ == &::google::protobuf::internal::kEmptyString) {
    card_holder_year_ = new ::std::string;
  }
  card_holder_year_->assign(value);
}
inline void BankNetToMomo::set_card_holder_year(const char* value) {
  set_has_card_holder_year();
  if (card_holder_year_ == &::google::protobuf::internal::kEmptyString) {
    card_holder_year_ = new ::std::string;
  }
  card_holder_year_->assign(value);
}
inline void BankNetToMomo::set_card_holder_year(const char* value, size_t size) {
  set_has_card_holder_year();
  if (card_holder_year_ == &::google::protobuf::internal::kEmptyString) {
    card_holder_year_ = new ::std::string;
  }
  card_holder_year_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BankNetToMomo::mutable_card_holder_year() {
  set_has_card_holder_year();
  if (card_holder_year_ == &::google::protobuf::internal::kEmptyString) {
    card_holder_year_ = new ::std::string;
  }
  return card_holder_year_;
}
inline ::std::string* BankNetToMomo::release_card_holder_year() {
  clear_has_card_holder_year();
  if (card_holder_year_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = card_holder_year_;
    card_holder_year_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BankNetToMomo::set_allocated_card_holder_year(::std::string* card_holder_year) {
  if (card_holder_year_ != &::google::protobuf::internal::kEmptyString) {
    delete card_holder_year_;
  }
  if (card_holder_year) {
    set_has_card_holder_year();
    card_holder_year_ = card_holder_year;
  } else {
    clear_has_card_holder_year();
    card_holder_year_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// BankNetVerifyOtp

// optional string merchant_trans_id = 1;
inline bool BankNetVerifyOtp::has_merchant_trans_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BankNetVerifyOtp::set_has_merchant_trans_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BankNetVerifyOtp::clear_has_merchant_trans_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BankNetVerifyOtp::clear_merchant_trans_id() {
  if (merchant_trans_id_ != &::google::protobuf::internal::kEmptyString) {
    merchant_trans_id_->clear();
  }
  clear_has_merchant_trans_id();
}
inline const ::std::string& BankNetVerifyOtp::merchant_trans_id() const {
  return *merchant_trans_id_;
}
inline void BankNetVerifyOtp::set_merchant_trans_id(const ::std::string& value) {
  set_has_merchant_trans_id();
  if (merchant_trans_id_ == &::google::protobuf::internal::kEmptyString) {
    merchant_trans_id_ = new ::std::string;
  }
  merchant_trans_id_->assign(value);
}
inline void BankNetVerifyOtp::set_merchant_trans_id(const char* value) {
  set_has_merchant_trans_id();
  if (merchant_trans_id_ == &::google::protobuf::internal::kEmptyString) {
    merchant_trans_id_ = new ::std::string;
  }
  merchant_trans_id_->assign(value);
}
inline void BankNetVerifyOtp::set_merchant_trans_id(const char* value, size_t size) {
  set_has_merchant_trans_id();
  if (merchant_trans_id_ == &::google::protobuf::internal::kEmptyString) {
    merchant_trans_id_ = new ::std::string;
  }
  merchant_trans_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BankNetVerifyOtp::mutable_merchant_trans_id() {
  set_has_merchant_trans_id();
  if (merchant_trans_id_ == &::google::protobuf::internal::kEmptyString) {
    merchant_trans_id_ = new ::std::string;
  }
  return merchant_trans_id_;
}
inline ::std::string* BankNetVerifyOtp::release_merchant_trans_id() {
  clear_has_merchant_trans_id();
  if (merchant_trans_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = merchant_trans_id_;
    merchant_trans_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BankNetVerifyOtp::set_allocated_merchant_trans_id(::std::string* merchant_trans_id) {
  if (merchant_trans_id_ != &::google::protobuf::internal::kEmptyString) {
    delete merchant_trans_id_;
  }
  if (merchant_trans_id) {
    set_has_merchant_trans_id();
    merchant_trans_id_ = merchant_trans_id;
  } else {
    clear_has_merchant_trans_id();
    merchant_trans_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string trans_id = 2;
inline bool BankNetVerifyOtp::has_trans_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BankNetVerifyOtp::set_has_trans_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BankNetVerifyOtp::clear_has_trans_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BankNetVerifyOtp::clear_trans_id() {
  if (trans_id_ != &::google::protobuf::internal::kEmptyString) {
    trans_id_->clear();
  }
  clear_has_trans_id();
}
inline const ::std::string& BankNetVerifyOtp::trans_id() const {
  return *trans_id_;
}
inline void BankNetVerifyOtp::set_trans_id(const ::std::string& value) {
  set_has_trans_id();
  if (trans_id_ == &::google::protobuf::internal::kEmptyString) {
    trans_id_ = new ::std::string;
  }
  trans_id_->assign(value);
}
inline void BankNetVerifyOtp::set_trans_id(const char* value) {
  set_has_trans_id();
  if (trans_id_ == &::google::protobuf::internal::kEmptyString) {
    trans_id_ = new ::std::string;
  }
  trans_id_->assign(value);
}
inline void BankNetVerifyOtp::set_trans_id(const char* value, size_t size) {
  set_has_trans_id();
  if (trans_id_ == &::google::protobuf::internal::kEmptyString) {
    trans_id_ = new ::std::string;
  }
  trans_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BankNetVerifyOtp::mutable_trans_id() {
  set_has_trans_id();
  if (trans_id_ == &::google::protobuf::internal::kEmptyString) {
    trans_id_ = new ::std::string;
  }
  return trans_id_;
}
inline ::std::string* BankNetVerifyOtp::release_trans_id() {
  clear_has_trans_id();
  if (trans_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = trans_id_;
    trans_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BankNetVerifyOtp::set_allocated_trans_id(::std::string* trans_id) {
  if (trans_id_ != &::google::protobuf::internal::kEmptyString) {
    delete trans_id_;
  }
  if (trans_id) {
    set_has_trans_id();
    trans_id_ = trans_id;
  } else {
    clear_has_trans_id();
    trans_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 amount = 3;
inline bool BankNetVerifyOtp::has_amount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BankNetVerifyOtp::set_has_amount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BankNetVerifyOtp::clear_has_amount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BankNetVerifyOtp::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 BankNetVerifyOtp::amount() const {
  return amount_;
}
inline void BankNetVerifyOtp::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
}

// optional string otp = 4;
inline bool BankNetVerifyOtp::has_otp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BankNetVerifyOtp::set_has_otp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BankNetVerifyOtp::clear_has_otp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BankNetVerifyOtp::clear_otp() {
  if (otp_ != &::google::protobuf::internal::kEmptyString) {
    otp_->clear();
  }
  clear_has_otp();
}
inline const ::std::string& BankNetVerifyOtp::otp() const {
  return *otp_;
}
inline void BankNetVerifyOtp::set_otp(const ::std::string& value) {
  set_has_otp();
  if (otp_ == &::google::protobuf::internal::kEmptyString) {
    otp_ = new ::std::string;
  }
  otp_->assign(value);
}
inline void BankNetVerifyOtp::set_otp(const char* value) {
  set_has_otp();
  if (otp_ == &::google::protobuf::internal::kEmptyString) {
    otp_ = new ::std::string;
  }
  otp_->assign(value);
}
inline void BankNetVerifyOtp::set_otp(const char* value, size_t size) {
  set_has_otp();
  if (otp_ == &::google::protobuf::internal::kEmptyString) {
    otp_ = new ::std::string;
  }
  otp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BankNetVerifyOtp::mutable_otp() {
  set_has_otp();
  if (otp_ == &::google::protobuf::internal::kEmptyString) {
    otp_ = new ::std::string;
  }
  return otp_;
}
inline ::std::string* BankNetVerifyOtp::release_otp() {
  clear_has_otp();
  if (otp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = otp_;
    otp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BankNetVerifyOtp::set_allocated_otp(::std::string* otp) {
  if (otp_ != &::google::protobuf::internal::kEmptyString) {
    delete otp_;
  }
  if (otp) {
    set_has_otp();
    otp_ = otp;
  } else {
    clear_has_otp();
    otp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .com.mservice.momo.msg.keyValuePair kvps = 5;
inline int BankNetVerifyOtp::kvps_size() const {
  return kvps_.size();
}
inline void BankNetVerifyOtp::clear_kvps() {
  kvps_.Clear();
}
inline const ::com::mservice::momo::msg::keyValuePair& BankNetVerifyOtp::kvps(int index) const {
  return kvps_.Get(index);
}
inline ::com::mservice::momo::msg::keyValuePair* BankNetVerifyOtp::mutable_kvps(int index) {
  return kvps_.Mutable(index);
}
inline ::com::mservice::momo::msg::keyValuePair* BankNetVerifyOtp::add_kvps() {
  return kvps_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >&
BankNetVerifyOtp::kvps() const {
  return kvps_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::keyValuePair >*
BankNetVerifyOtp::mutable_kvps() {
  return &kvps_;
}

// -------------------------------------------------------------------

// Broadcast

// optional .com.mservice.momo.msg.Broadcast.MsgType type = 1;
inline bool Broadcast::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Broadcast::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Broadcast::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Broadcast::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::com::mservice::momo::msg::Broadcast_MsgType Broadcast::type() const {
  return static_cast< ::com::mservice::momo::msg::Broadcast_MsgType >(type_);
}
inline void Broadcast::set_type(::com::mservice::momo::msg::Broadcast_MsgType value) {
  assert(::com::mservice::momo::msg::Broadcast_MsgType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string sender = 2;
inline bool Broadcast::has_sender() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Broadcast::set_has_sender() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Broadcast::clear_has_sender() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Broadcast::clear_sender() {
  if (sender_ != &::google::protobuf::internal::kEmptyString) {
    sender_->clear();
  }
  clear_has_sender();
}
inline const ::std::string& Broadcast::sender() const {
  return *sender_;
}
inline void Broadcast::set_sender(const ::std::string& value) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(value);
}
inline void Broadcast::set_sender(const char* value) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(value);
}
inline void Broadcast::set_sender(const char* value, size_t size) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Broadcast::mutable_sender() {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  return sender_;
}
inline ::std::string* Broadcast::release_sender() {
  clear_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sender_;
    sender_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Broadcast::set_allocated_sender(::std::string* sender) {
  if (sender_ != &::google::protobuf::internal::kEmptyString) {
    delete sender_;
  }
  if (sender) {
    set_has_sender();
    sender_ = sender;
  } else {
    clear_has_sender();
    sender_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string content = 3;
inline bool Broadcast::has_content() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Broadcast::set_has_content() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Broadcast::clear_has_content() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Broadcast::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& Broadcast::content() const {
  return *content_;
}
inline void Broadcast::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void Broadcast::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void Broadcast::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Broadcast::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* Broadcast::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Broadcast::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace msg
}  // namespace momo
}  // namespace mservice
}  // namespace com

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::mservice::momo::msg::Err_ResultCode>() {
  return ::com::mservice::momo::msg::Err_ResultCode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::mservice::momo::msg::GetAgentInfoReply_ResultCode>() {
  return ::com::mservice::momo::msg::GetAgentInfoReply_ResultCode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::mservice::momo::msg::Broadcast_MsgType>() {
  return ::com::mservice::momo::msg::Broadcast_MsgType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::mservice::momo::msg::MsgType>() {
  return ::com::mservice::momo::msg::MsgType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_SoapProto_2eproto__INCLUDED
