// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MomoProto.proto

#ifndef PROTOBUF_MomoProto_2eproto__INCLUDED
#define PROTOBUF_MomoProto_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace com {
namespace mservice {
namespace momo {
namespace msg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_MomoProto_2eproto();
void protobuf_AssignDesc_MomoProto_2eproto();
void protobuf_ShutdownFile_MomoProto_2eproto();

class TextValueMsg;
class FormReply;
class FormField;
class ValueForDropBox;
class GetServiceByLastTime;
class GetServiceByServiceId;
class WholeSystemPaused;
class GetServiceLayout;
class Invitee;
class InviteStatisticReply;
class TextValue;
class Service;
class ServiceItem;
class ServiceReply;
class FieldItem;
class ExtraInfo;
class GetServiceLayoutReply;
class Promotion;
class GetPromotionReply;
class GetPromotionDetail;
class GetPromotionDetailReply;
class MinMax;
class MinMaxReply;
class CreateOrder123Phim;
class Seat;
class CreateOrder123PhimReply;
class StandardSync;
class StandardReply;
class BanketVerifyOtp;
class IdList;
class BankOfBanknet;
class TranStatisticPerDayReply;
class GetFee;
class GetFeeReply;
class NewUser;
class TicketInfo;
class RegStatus;
class Hello;
class HelloReply;
class VerifyOtp;
class VerifyOtpReply;
class Register;
class LogIn;
class LogInReply;
class GetBillInfo;
class BillDetail;
class GetBillInfoReply;
class ChangePin;
class WhoIsMomoer;
class ViewPaymentHistoryByBillId;
class ViewPaymentHistoryByBillIdReply;
class DeviceInfo;
class GetAccessHistory;
class AccessHistoryDetail;
class GetAccessHistoryReply;
class StoreInfo;
class SyncStoreLocationReply;
class PhoneExist;
class AgentInfo;
class BankNetToMomoRely;
class MoneyRequest;
class TranHisV1;
class CardItem;
class CardAddOrUpdate;
class CardAddOrUpdateReply;
class CardSyncFirstTimeReply;
class TranHisSyncReply;
class Bill;
class RemoveSavedBill;
class RemoveSavedBillReply;
class Notification;
class UpdateNotificationsStatus;
class UpdateNotificationsStatusReply;
class NotificationSyncReply;
class NotificationNew;
class NotificationReceived;
class GetNotification;
class GetNotificationReply;
class Avatar;
class AvatarReply;
class AvatarUploadReply;
class GetDynamicConfig;
class GetDynamicConfigReply;
class GetSmartLinkUrl;
class GetSmartLinkUrlReply;
class StoreRateInfo;
class GetStoreRate;
class GetStoreRateReply;
class StoreComment;
class GetStoreCommentPage;
class GetStoreCommentPageReply;
class StoreCommentCrud;
class StoreCommentCrudReply;
class StoreWarningType;
class GetStoreWarningType;
class GetStoreWarningTypeReply;
class WarnStore;
class WarnStoreReply;
class GiftType;
class Gift;
class GiftClaim;
class GiftClaimReply;
class UserSetting;
class GetGiftType;
class GetGiftTypeReply;
class GetGift;
class GetGiftReply;
class SetGiftStatus;
class SendMessage;
class GiftRequest;
class GetTranConfirmReply;
class InfoAlertType;
class GetAlertType;
class GetAlertTypeReply;
class InfoAlert;

enum HelloReply_ResultCode {
  HelloReply_ResultCode_ALL_OK = 0,
  HelloReply_ResultCode_PHONE_NOT_CORRECT = 1,
  HelloReply_ResultCode_LOG_ON = 2,
  HelloReply_ResultCode_LOG_ON_ANOTHER_DEVICE = 3,
  HelloReply_ResultCode_NOT_LOG_ON = 4
};
bool HelloReply_ResultCode_IsValid(int value);
const HelloReply_ResultCode HelloReply_ResultCode_ResultCode_MIN = HelloReply_ResultCode_ALL_OK;
const HelloReply_ResultCode HelloReply_ResultCode_ResultCode_MAX = HelloReply_ResultCode_NOT_LOG_ON;
const int HelloReply_ResultCode_ResultCode_ARRAYSIZE = HelloReply_ResultCode_ResultCode_MAX + 1;

enum VerifyOtpReply_ResultCode {
  VerifyOtpReply_ResultCode_ALL_OK = 0,
  VerifyOtpReply_ResultCode_WRONG_OTP = 1,
  VerifyOtpReply_ResultCode_TIME_OUT = 2
};
bool VerifyOtpReply_ResultCode_IsValid(int value);
const VerifyOtpReply_ResultCode VerifyOtpReply_ResultCode_ResultCode_MIN = VerifyOtpReply_ResultCode_ALL_OK;
const VerifyOtpReply_ResultCode VerifyOtpReply_ResultCode_ResultCode_MAX = VerifyOtpReply_ResultCode_TIME_OUT;
const int VerifyOtpReply_ResultCode_ResultCode_ARRAYSIZE = VerifyOtpReply_ResultCode_ResultCode_MAX + 1;

enum LogInReply_ResultCode {
  LogInReply_ResultCode_ALL_OK = 0,
  LogInReply_ResultCode_PIN_INVALID = 1014,
  LogInReply_ResultCode_SYSTEM_ERROR = 2,
  LogInReply_ResultCode_AUTH_RETRY_EXCEED = 1012,
  LogInReply_ResultCode_AUTH_EXPIRED = 1013,
  LogInReply_ResultCode_NOT_SETUP = 4,
  LogInReply_ResultCode_TEMP_LOCK = 5,
  LogInReply_ResultCode_AGENT_NOT_FOUND = 40000,
  LogInReply_ResultCode_AGENT_CANCELLED = 40001
};
bool LogInReply_ResultCode_IsValid(int value);
const LogInReply_ResultCode LogInReply_ResultCode_ResultCode_MIN = LogInReply_ResultCode_ALL_OK;
const LogInReply_ResultCode LogInReply_ResultCode_ResultCode_MAX = LogInReply_ResultCode_AGENT_CANCELLED;
const int LogInReply_ResultCode_ResultCode_ARRAYSIZE = LogInReply_ResultCode_ResultCode_MAX + 1;

enum GetBillInfoReply_ResultCode {
  GetBillInfoReply_ResultCode_ALL_OK = 0,
  GetBillInfoReply_ResultCode_WRONG_ACCOUNT_ID = 1,
  GetBillInfoReply_ResultCode_WRONG_AMOUNT = 2,
  GetBillInfoReply_ResultCode_SYSTEM_ERROR = 3
};
bool GetBillInfoReply_ResultCode_IsValid(int value);
const GetBillInfoReply_ResultCode GetBillInfoReply_ResultCode_ResultCode_MIN = GetBillInfoReply_ResultCode_ALL_OK;
const GetBillInfoReply_ResultCode GetBillInfoReply_ResultCode_ResultCode_MAX = GetBillInfoReply_ResultCode_SYSTEM_ERROR;
const int GetBillInfoReply_ResultCode_ResultCode_ARRAYSIZE = GetBillInfoReply_ResultCode_ResultCode_MAX + 1;

enum TranHisV1_TranType {
  TranHisV1_TranType_BANK_IN = 1,
  TranHisV1_TranType_BANK_OUT = 2,
  TranHisV1_TranType_TOP_UP = 3,
  TranHisV1_TranType_TOP_UP_GAME = 4,
  TranHisV1_TranType_M2C = 5,
  TranHisV1_TranType_M2M = 6,
  TranHisV1_TranType_PAY_ONE_BILL = 7,
  TranHisV1_TranType_QUICK_PAYMENT = 8,
  TranHisV1_TranType_QUICK_DEPOSIT = 9,
  TranHisV1_TranType_BANK_NET_TO_MOMO = 10,
  TranHisV1_TranType_BANK_NET_VERIFY_OTP = 11,
  TranHisV1_TranType_PAY_ONE_BILL_OTHER = 12,
  TranHisV1_TranType_TRANSFER_MONEY_TO_PLACE = 13,
  TranHisV1_TranType_BILL_PAY_TELEPHONE = 14,
  TranHisV1_TranType_BILL_PAY_TICKET_AIRLINE = 15,
  TranHisV1_TranType_BILL_PAY_TICKET_TRAIN = 16,
  TranHisV1_TranType_BILL_PAY_INSURANCE = 17,
  TranHisV1_TranType_BILL_PAY_INTERNET = 18,
  TranHisV1_TranType_BILL_PAY_OTHER = 19,
  TranHisV1_TranType_DEPOSIT_CASH_OTHER = 20,
  TranHisV1_TranType_BUY_MOBILITY_CARD = 21,
  TranHisV1_TranType_BUY_GAME_CARD = 22,
  TranHisV1_TranType_BUY_OTHER = 23,
  TranHisV1_TranType_DEPOSIT_CASH = 24,
  TranHisV1_TranType_BILL_PAY_CINEMA = 25,
  TranHisV1_TranType_MOMO_TO_BANK_MANUAL = 26,
  TranHisV1_TranType_DEPOSIT_AT_HOME = 27,
  TranHisV1_TranType_WITHDRAW_AT_HOME = 28,
  TranHisV1_TranType_BONUS = 29,
  TranHisV1_TranType_FEE = 30,
  TranHisV1_TranType_PHIM123 = 31,
  TranHisV1_TranType_PAY_NUOCCL_BILL = 32,
  TranHisV1_TranType_PAY_AVG_BILL = 33,
  TranHisV1_TranType_PAY_ONE_BILL_SERVICE = 34,
  TranHisV1_TranType_BUY_GIFT = 35,
  TranHisV1_TranType_SEND_GIFT = 36,
  TranHisV1_TranType_GIFT_TO_MPOINT = 37,
  TranHisV1_TranType_GIFT_RECEIVE = 38,
  TranHisV1_TranType_NAMED = 39,
  TranHisV1_TranType_PAY_BACK = 40,
  TranHisV1_TranType_PROMOTION = 41,
  TranHisV1_TranType_VOUCHER = 42,
  TranHisV1_TranType_POINT = 43,
  TranHisV1_TranType_GIFT_CLAIM = 44,
  TranHisV1_TranType_MPOINT_CLAIM = 45,
  TranHisV1_TranType_C2C = 46,
  TranHisV1_TranType_C2C_RECEIVE = 47,
  TranHisV1_TranType_C2C_BONUS_SEND = 48,
  TranHisV1_TranType_C2C_BONUS_RECEIVE = 49,
  TranHisV1_TranType_VM_PROCESS_CASH_IN = 50,
  TranHisV1_TranType_BONUS_DGD = 51,
  TranHisV1_TranType_BONUS_300 = 52,
  TranHisV1_TranType_PAY_ONE_SALE_OFF_BILL = 53,
  TranHisV1_TranType_TRANSFER_ONE_BILL = 54,
  TranHisV1_TranType_PAY_SDK_BILL = 55,
  TranHisV1_TranType_PAY_IPOS_BILL = 56,
  TranHisV1_TranType_ATM_CASH_IN = 57,
  TranHisV1_TranType_ATM_CASH_IN_REPLY = 58,
  TranHisV1_TranType_ATM_CASH_OUT = 59,
  TranHisV1_TranType_ATM_CASH_OUT_REPLY = 60
};
bool TranHisV1_TranType_IsValid(int value);
const TranHisV1_TranType TranHisV1_TranType_TranType_MIN = TranHisV1_TranType_BANK_IN;
const TranHisV1_TranType TranHisV1_TranType_TranType_MAX = TranHisV1_TranType_ATM_CASH_OUT_REPLY;
const int TranHisV1_TranType_TranType_ARRAYSIZE = TranHisV1_TranType_TranType_MAX + 1;

enum TranHisV1_ResultCode {
  TranHisV1_ResultCode_SYSTEM_ERROR = -1,
  TranHisV1_ResultCode_ALL_OK = 0,
  TranHisV1_ResultCode_PARTNER_NUMBER_NOT_VALID = -2,
  TranHisV1_ResultCode_SESSION_EXPIRED = -3,
  TranHisV1_ResultCode_NOT_SUPPORT = -4,
  TranHisV1_ResultCode_NO_SUCH_GIFT = -6,
  TranHisV1_ResultCode_GIFT_TYPE_NOT_ACTIVE = -7,
  TranHisV1_ResultCode_WRONG_PRICE_AMOUNT = -8,
  TranHisV1_ResultCode_ALREADY_OWNED = -9,
  TranHisV1_ResultCode_NOT_TRANSFERABLE = -11,
  TranHisV1_ResultCode_CUSTOM_ERROR = 1000000,
  TranHisV1_ResultCode_NOT_OWNED = -13
};
bool TranHisV1_ResultCode_IsValid(int value);
const TranHisV1_ResultCode TranHisV1_ResultCode_ResultCode_MIN = TranHisV1_ResultCode_NOT_OWNED;
const TranHisV1_ResultCode TranHisV1_ResultCode_ResultCode_MAX = TranHisV1_ResultCode_CUSTOM_ERROR;
const int TranHisV1_ResultCode_ResultCode_ARRAYSIZE = TranHisV1_ResultCode_ResultCode_MAX + 1;

enum TranHisV1_SourceFrom {
  TranHisV1_SourceFrom_MOMO = 1,
  TranHisV1_SourceFrom_BANKLINKED = 2,
  TranHisV1_SourceFrom_MASTERCARD = 3,
  TranHisV1_SourceFrom_VISA = 4,
  TranHisV1_SourceFrom_BANK_NET_2_VERIFY_OTP = 5,
  TranHisV1_SourceFrom_PAY123 = 6
};
bool TranHisV1_SourceFrom_IsValid(int value);
const TranHisV1_SourceFrom TranHisV1_SourceFrom_SourceFrom_MIN = TranHisV1_SourceFrom_MOMO;
const TranHisV1_SourceFrom TranHisV1_SourceFrom_SourceFrom_MAX = TranHisV1_SourceFrom_PAY123;
const int TranHisV1_SourceFrom_SourceFrom_ARRAYSIZE = TranHisV1_SourceFrom_SourceFrom_MAX + 1;

enum CardItem_LockedType {
  CardItem_LockedType_FULL = 1,
  CardItem_LockedType_PART = 2,
  CardItem_LockedType_BANKLINKED = 3
};
bool CardItem_LockedType_IsValid(int value);
const CardItem_LockedType CardItem_LockedType_LockedType_MIN = CardItem_LockedType_FULL;
const CardItem_LockedType CardItem_LockedType_LockedType_MAX = CardItem_LockedType_BANKLINKED;
const int CardItem_LockedType_LockedType_ARRAYSIZE = CardItem_LockedType_LockedType_MAX + 1;

enum CardItem_Channel {
  CardItem_Channel_BANKNET = 1,
  CardItem_Channel_ONEPAY = 2,
  CardItem_Channel_SMARTLINK = 3,
  CardItem_Channel_MANUAL = 4
};
bool CardItem_Channel_IsValid(int value);
const CardItem_Channel CardItem_Channel_Channel_MIN = CardItem_Channel_BANKNET;
const CardItem_Channel CardItem_Channel_Channel_MAX = CardItem_Channel_MANUAL;
const int CardItem_Channel_Channel_ARRAYSIZE = CardItem_Channel_Channel_MAX + 1;

enum CardItem_IOCity {
  CardItem_IOCity_OUT = 0,
  CardItem_IOCity_IN = 1
};
bool CardItem_IOCity_IsValid(int value);
const CardItem_IOCity CardItem_IOCity_IOCity_MIN = CardItem_IOCity_OUT;
const CardItem_IOCity CardItem_IOCity_IOCity_MAX = CardItem_IOCity_IN;
const int CardItem_IOCity_IOCity_ARRAYSIZE = CardItem_IOCity_IOCity_MAX + 1;

enum RemoveSavedBillReply_Result {
  RemoveSavedBillReply_Result_SUCCESS = 1,
  RemoveSavedBillReply_Result_FAIL = 2
};
bool RemoveSavedBillReply_Result_IsValid(int value);
const RemoveSavedBillReply_Result RemoveSavedBillReply_Result_Result_MIN = RemoveSavedBillReply_Result_SUCCESS;
const RemoveSavedBillReply_Result RemoveSavedBillReply_Result_Result_MAX = RemoveSavedBillReply_Result_FAIL;
const int RemoveSavedBillReply_Result_Result_ARRAYSIZE = RemoveSavedBillReply_Result_Result_MAX + 1;

enum StoreComment_CommentStatus {
  StoreComment_CommentStatus_STATUS_NEW = 0,
  StoreComment_CommentStatus_STATUS_ACCEPTED = 1,
  StoreComment_CommentStatus_STATUS_REJECTED = 2
};
bool StoreComment_CommentStatus_IsValid(int value);
const StoreComment_CommentStatus StoreComment_CommentStatus_CommentStatus_MIN = StoreComment_CommentStatus_STATUS_NEW;
const StoreComment_CommentStatus StoreComment_CommentStatus_CommentStatus_MAX = StoreComment_CommentStatus_STATUS_REJECTED;
const int StoreComment_CommentStatus_CommentStatus_ARRAYSIZE = StoreComment_CommentStatus_CommentStatus_MAX + 1;

enum StoreCommentCrud_CrudCmd {
  StoreCommentCrud_CrudCmd_CMD_CREATE = 1,
  StoreCommentCrud_CrudCmd_CMD_READ = 2,
  StoreCommentCrud_CrudCmd_CMD_UPDATE = 3,
  StoreCommentCrud_CrudCmd_CMD_DELETE = 4
};
bool StoreCommentCrud_CrudCmd_IsValid(int value);
const StoreCommentCrud_CrudCmd StoreCommentCrud_CrudCmd_CrudCmd_MIN = StoreCommentCrud_CrudCmd_CMD_CREATE;
const StoreCommentCrud_CrudCmd StoreCommentCrud_CrudCmd_CrudCmd_MAX = StoreCommentCrud_CrudCmd_CMD_DELETE;
const int StoreCommentCrud_CrudCmd_CrudCmd_ARRAYSIZE = StoreCommentCrud_CrudCmd_CrudCmd_MAX + 1;

enum GiftType_Status {
  GiftType_Status_ACTIVE = 1,
  GiftType_Status_INACTIVE = 2,
  GiftType_Status_DELETED = 3,
  GiftType_Status_TIMED = 4
};
bool GiftType_Status_IsValid(int value);
const GiftType_Status GiftType_Status_Status_MIN = GiftType_Status_ACTIVE;
const GiftType_Status GiftType_Status_Status_MAX = GiftType_Status_TIMED;
const int GiftType_Status_Status_ARRAYSIZE = GiftType_Status_Status_MAX + 1;

enum Gift_Status {
  Gift_Status_NEW = 1,
  Gift_Status_VIEWED = 2,
  Gift_Status_USED = 3,
  Gift_Status_TIMED = 4
};
bool Gift_Status_IsValid(int value);
const Gift_Status Gift_Status_Status_MIN = Gift_Status_NEW;
const Gift_Status Gift_Status_Status_MAX = Gift_Status_TIMED;
const int Gift_Status_Status_ARRAYSIZE = Gift_Status_Status_MAX + 1;

enum SendMessage_Type {
  SendMessage_Type_MONEY_THANKS = 1,
  SendMessage_Type_GIFT_THANKS = 2
};
bool SendMessage_Type_IsValid(int value);
const SendMessage_Type SendMessage_Type_Type_MIN = SendMessage_Type_MONEY_THANKS;
const SendMessage_Type SendMessage_Type_Type_MAX = SendMessage_Type_GIFT_THANKS;
const int SendMessage_Type_Type_ARRAYSIZE = SendMessage_Type_Type_MAX + 1;

enum InfoAlertType_Status {
  InfoAlertType_Status_ACTIVE = 1,
  InfoAlertType_Status_INACTIVE = 2,
  InfoAlertType_Status_DELETED = 3
};
bool InfoAlertType_Status_IsValid(int value);
const InfoAlertType_Status InfoAlertType_Status_Status_MIN = InfoAlertType_Status_ACTIVE;
const InfoAlertType_Status InfoAlertType_Status_Status_MAX = InfoAlertType_Status_DELETED;
const int InfoAlertType_Status_Status_ARRAYSIZE = InfoAlertType_Status_Status_MAX + 1;

enum MsgType {
  ACK = 1,
  ERROR = 2,
  SEND_SMS = 3,
  HELLO = 1001,
  HELLO_REPLY = 1002,
  GET_OTP = 1003,
  GET_OTP_REPLY = 1004,
  VERIFY_OTP = 1005,
  VERIFY_OTP_REPLY = 1006,
  LOGIN = 1007,
  LOGIN_REPLY = 1008,
  REGISTER = 1009,
  REGISTER_REPLY = 1010,
  USER_INFO_RECOVERY_PIN = 1011,
  USER_INFO_RECOVERY_PIN_REPLY = 1012,
  GET_BILL_INFO = 1013,
  GET_BILL_INFO_REPLY = 1014,
  DEVICE_INFO = 1015,
  DEVICE_INFO_REPLY = 1016,
  CHANGE_PIN = 1017,
  CHANGE_PIN_REPLY = 1018,
  BILLPAY_GET_ALL = 1019,
  BILLPAY_GET_ALL_REPLY = 1020,
  PHONE_EXIST = 1021,
  PHONE_EXIST_REPLY = 1022,
  LOG_OUT = 1023,
  LOG_OUT_REPLY = 1024,
  CHECK_MOMO_AGENT = 1025,
  CHECK_MOMO_AGENT_REPLY = 1026,
  RECOVERY_NEW_PIN = 1027,
  RECOVERY_NEW_PIN_REPLY = 1028,
  WHO_IS_MOMOER = 1029,
  WHO_IS_MOMOER_REPLY = 1030,
  VIEW_PAYMENT_HISTORY_BY_BILL_ID = 1031,
  VIEW_PAYMENT_HISTORY_BY_BILL_ID_REPLY = 1032,
  BILL_SYNC_REPLY = 1033,
  GET_ACCESS_HISTORY = 1034,
  GET_ACCESS_HISTORY_REPLY = 1035,
  SESSION_EXPIRED_REPLY = 1036,
  UPDATE_AGENT_INFO = 1037,
  BILL_SYNC = 1038,
  TRANS_REPLY = 1059,
  GET_STORES_AROUND = 1060,
  GET_STORES_AROUND_REPLY = 1061,
  BANK_NET_TO_MOMO_REPLY = 1063,
  MONEY_REQUEST = 1066,
  MONEY_REQUEST_REPLY = 1067,
  BROADCAST = 1068,
  TRAN_ACK = 1069,
  TRANS_REQUEST = 1070,
  TRAN_SYNC = 1071,
  TRAN_SYNC_REPLY = 1072,
  TRAN_RECEIVER = 1073,
  STORE_LOCATION_SYNC = 1074,
  STORE_LOCATION_SYNC_REPLY = 1075,
  STORE_LOCATION = 1076,
  TRANSFER_REQUEST = 1077,
  BANK_NET_TO_MOMO = 1078,
  CARD_ADD_OR_UPDATE = 1079,
  CARD_ADD_OR_UPDATE_REPLY = 1080,
  CARD_SYNC = 1081,
  CARD_SYNC_REPLY = 1082,
  TICKET_INFO_REPLY = 1083,
  AGENT_MODIFY = 1084,
  AGENT_MODIFY_REPLY = 1085,
  AVATAR_UPLOAD = 1086,
  AVATAR_UPLOAD_REPLY = 1087,
  ECHO = 1090,
  ECHO_REPLY = 1091,
  NEW_USER = 1092,
  TRAN_STATISTIC_PER_DAY = 1093,
  TRAN_STATISTIC_PER_DAY_REPLY = 1094,
  GET_FEE = 1095,
  GET_FEE_REPLY = 1096,
  NO_MORE_BILLS = 1099,
  REMOVE_SAVED_BILL = 1100,
  REMOVE_SAVED_BILL_REPLY = 1101,
  TRAN_DELETE = 1102,
  TRAN_DELETE_REPLY = 1103,
  NOTIFICATION_SYNC = 1104,
  NOTIFICATION_SYNC_REPLY = 1105,
  NOTIFICATION_SYNC_FINISH = 1106,
  NOTIFICATION_NEW = 1107,
  NOTIFICATION_RECEIVED = 1108,
  TRAN_SYNC_FINISH = 1109,
  UPDATE_NOTIFICATIONS_STATUS = 1110,
  UPDATE_NOTIFICATIONS_STATUS_REPLY = 1111,
  GET_BANK_OF_BANKNET = 1112,
  GET_BANK_OF_BANKNET_REPLY = 1113,
  BANKNET_VERIFY_OTP = 1114,
  BANKNET_VERIFY_OTP_REPLY = 1115,
  CHECK_TRAN_STATUS = 1116,
  CHECK_TRAN_STATUS_REPLY = 1117,
  GET_DYNAMIC_CONFIG = 1118,
  GET_DYNAMIC_CONFIG_REPLY = 1119,
  CREATE_ORDER_123PHIM = 1120,
  CREATE_ORDER_123PHIM_REPLY = 1121,
  GET_MIN_MAX_TRAN = 1122,
  GET_MIN_MAX_TRAN_REPLY = 1123,
  GET_PROMOTION = 1124,
  GET_PROMOTION_REPLY = 1125,
  GET_PROMOTION_DETAIL = 1126,
  GET_PROMOTION_DETAIL_REPLY = 1127,
  GET_SMARTLINK_URL = 1128,
  GET_SMARTLINK_URL_REPLY = 1129,
  INVITE_STATISTIC = 1130,
  INVITE_STATISTIC_REPLY = 1131,
  GET_SERVICE = 1132,
  GET_SERVICE_REPLY = 1133,
  GET_SERVICE_LAYOUT = 1134,
  GET_SERVICE_LAYOUT_REPLY = 1135,
  WHOLE_SYSTEM_PAUSED = 1136,
  GET_NOTIFICAITON = 1137,
  GET_NOTIFICATION_REPLY = 1138,
  GET_SERVICE_BY_LAST_TIME = 1139,
  GET_SERVICE_BY_SERVICE_ID = 1140,
  GET_SERVICE_BY_SERVICE_ID_REPLY = 1141,
  GET_PROMO = 1142,
  GET_PROMO_REPLY = 1143,
  GET_STORE_RATE = 1144,
  GET_STORE_RATE_REPLY = 1145,
  GET_STORE_COMMENT_PAGE = 1146,
  GET_STORE_COMMENT_PAGE_REPLY = 1147,
  RATE_STORE = 1148,
  RATE_STORE_REPLY = 1149,
  STORE_COMMENT_CRUD = 1150,
  STORE_COMMENT_CRUD_REPLY = 1151,
  GET_STORE_WARNING_TYPE = 1152,
  GET_STORE_WARNING_TYPE_REPLY = 1153,
  WARN_STORE = 1154,
  WARN_STORE_REPLY = 1155,
  NOTIFICATION_RECEIVED_REPLY = 1156,
  GET_AGENT_INFO = 1157,
  GET_AGENT_INFO_RELY = 1158,
  GIFT_CLAIM = 1159,
  GIFT_CLAIM_REPLY = 1160,
  GET_USER_SETTING = 1161,
  GET_USER_SETTTING_REPLY = 1162,
  SET_USER_SETTING = 1163,
  SET_USER_SETTING_REPLY = 1164,
  GET_GIFT_TYPE = 1165,
  GET_GIFT_TYPE_REPLY = 1166,
  GET_GIFT = 1167,
  GET_GIFT_REPLY = 1168,
  GET_GIFT_FINISH = 1169,
  SET_GIFT_STATUS = 1170,
  SEND_GIFT_MESSAGE = 1171,
  SEND_GIFT_MESSAGE_REPLY = 1172,
  FTP_INFO = 1173,
  FTP_INFO_REPLY = 1174,
  CLEAR_ALL_NOTI = 1175,
  CLEAR_ALL_NOTI_REPLY = 1176,
  USE_GIFT = 1177,
  USE_GIFT_REPLY = 1178,
  CAN_USE_GIFT = 1179,
  CAN_USE_GIFT_REPLY = 1180,
  CHECK_BILL = 1181,
  CHECK_BILL_REPLY = 1182,
  ADD_FIELD = 1183,
  ADD_FIELD_REPLY = 1184,
  GET_TRAN_CONFIRM_INFO = 1185,
  GET_TRAN_CONFIRM_INFO_REPLY = 1186,
  GET_FORM_FIELDS = 1187,
  GET_FORM_FIELDS_REPLY = 1188,
  SUBMIT_FORM = 1189,
  SUBMIT_FORM_REPLY = 1190,
  GET_VALUE_FOR_DROPBOX = 1191,
  GET_VALUE_FOR_DROPBOX_REPLY = 1192,
  GET_CATEGORY = 1193,
  GET_CATEGORY_REPLY = 1194,
  TRANSLATE_CONFIRM_INFO = 1195,
  TRANSLATE_CONFIRM_INFO_REPLY = 1196,
  MUST_UPDATE_INFO = 1197,
  MUST_UPDATE_INFO_REPLY = 1198,
  DGD_GET_FEE = 1199,
  DGD_GET_FEE_REPLY = 1200,
  GET_BALANCE = 1201,
  GET_BALANCE_REPLY = 1202,
  GET_INFO_ALERT_TYPE = 1203,
  GET_INFO_ALERT_TYPE_REPLY = 1204,
  SUBMIT_INFO_ALERT = 1205,
  SUBMIT_INFO_ALERT_REPLY = 1206,
  GET_C2C_INFO = 1207,
  GET_C2C_INFO_REPLY = 1208,
  GET_OTP_FOR_CLIENT = 1209,
  GET_OTP_FOR_CLIENT_REPLY = 1210,
  GET_LIQUIDITY = 1211,
  GET_LIQUIDITY_REPLY = 1212,
  GET_CARD_LIST = 1213,
  GET_CARD_LIST_REPLY = 1214,
  DELETE_TOKEN = 1215,
  DELETE_TOKEN_REPLY = 1216,
  CREATE_TOKEN = 1217,
  CREATE_TOKEN_REPLY = 1218,
  GET_CARD_TYPE = 1219,
  GET_CARD_TYPE_REPLY = 1220,
  GET_FEE_BANK = 1221,
  GET_FEE_BANK_REPLY = 1222,
  CREATE_ORDER_CUNGMUA = 1223,
  CREATE_ORDER_CUNGMUA_REPLY = 1224,
  CONFIRM_WALLET_MAPPING = 1225,
  CONFIRM_WALLET_MAPPING_REPLY = 1226,
  CHECK_USER_RESET_PASSWORD = 1227,
  CHECK_USER_RESET_PASSWORD_REPLY = 1228,
  RESET_PASSWORD = 1229,
  RESET_PASSWORD_REPLY = 1230,
  WALLET_MAP = 1231,
  WALLET_MAP_REPLY = 1232,
  ATM_WALLET_MAPPING = 1233,
  ATM_WALLET_MAPPING_REPLY = 1234,
  ATM_WALLET_UNMAPPING = 1235,
  ATM_WALLET_UNMAPPING_REPLY = 1236,
  SEND_EMAIL = 1237,
  SEND_EMAIL_REPLY = 1238,
  BUILD_URL_NAPAS = 1239,
  BUILD_URL_NAPAS_REPLY = 1240
};
bool MsgType_IsValid(int value);
const MsgType MsgType_MIN = ACK;
const MsgType MsgType_MAX = BUILD_URL_NAPAS_REPLY;
const int MsgType_ARRAYSIZE = MsgType_MAX + 1;

enum phim123 {
  CANCEL = 0,
  CONFIRM = 1
};
bool phim123_IsValid(int value);
const phim123 phim123_MIN = CANCEL;
const phim123 phim123_MAX = CONFIRM;
const int phim123_ARRAYSIZE = phim123_MAX + 1;

enum SystemError {
  SERVICE_IS_PAUSED = -10,
  ALL_OK = 0,
  MSG_FORMAT_NOT_CORRECT = 1,
  NOT_HELLO_YET = 2,
  NUMBER_NOT_VALID = 3,
  SYSTEM_ERROR = 4,
  NOT_SET_UP = 5,
  NUMBER_EXISTED = 6,
  OLD_PIN_NOT_CORRECT = 7,
  IS_BLOCKING = 8
};
bool SystemError_IsValid(int value);
const SystemError SystemError_MIN = SERVICE_IS_PAUSED;
const SystemError SystemError_MAX = IS_BLOCKING;
const int SystemError_ARRAYSIZE = SystemError_MAX + 1;

enum FeeType {
  MOMO = 0,
  CASH = 1
};
bool FeeType_IsValid(int value);
const FeeType FeeType_MIN = MOMO;
const FeeType FeeType_MAX = CASH;
const int FeeType_ARRAYSIZE = FeeType_MAX + 1;

enum GetBillInfoAction {
  SYNC = 1,
  GET_ONE = 2,
  GET_SAVED = 3
};
bool GetBillInfoAction_IsValid(int value);
const GetBillInfoAction GetBillInfoAction_MIN = SYNC;
const GetBillInfoAction GetBillInfoAction_MAX = GET_SAVED;
const int GetBillInfoAction_ARRAYSIZE = GetBillInfoAction_MAX + 1;

enum NotificationType {
  NOTI_DETAIL = 0,
  NOTI_TRANSACTION = 1,
  NOTI_NEW_MOMOER = 2,
  NOTI_ADVERTISE = 3,
  NOTI_MONEY_REQUEST = 4,
  NOTI_UPDATE_INFO = 5,
  NOTI_NOTICE = 6,
  NOTI_DEPOSIT_WITHDRAW_AT_PLACE = 7,
  NOTI_GENERIC = 8,
  NOTI_STUDENT = 9,
  NOTI_123PHIM = 10,
  NOTI_PAY_ONE_BILL = 11,
  NOTI_SERVICE_ONE_BILL = 12,
  NOTI_QR_CODE = 13,
  NOTI_CASH_MONEY = 14,
  NOTI_WITHDRAW_MONEY = 15,
  NOTI_FIND_LOCATION = 16,
  NOTI_BORROW_MONEY = 17,
  NOTI_LIXI_VIEW = 18,
  NOTI_LIXI_CREATE = 19,
  NOTI_VOUCHER_VIEW = 20,
  NOTI_VOUCHER_CREATE = 21,
  NOTI_TOPUP = 22,
  NOTI_TRANSFER = 23,
  NOTI_GIFT_RECEIVE = 24,
  NOTI_GIFT_REPLY = 25,
  NOTI_MAP_WALLET = 26,
  REMIND_EXPIRED = 27,
  POPUP_INFORMATION = 28
};
bool NotificationType_IsValid(int value);
const NotificationType NotificationType_MIN = NOTI_DETAIL;
const NotificationType NotificationType_MAX = POPUP_INFORMATION;
const int NotificationType_ARRAYSIZE = NotificationType_MAX + 1;

enum NotiCategory {
  SYSTEM = 0,
  ADVERT = 1
};
bool NotiCategory_IsValid(int value);
const NotiCategory NotiCategory_MIN = SYSTEM;
const NotiCategory NotiCategory_MAX = ADVERT;
const int NotiCategory_ARRAYSIZE = NotiCategory_MAX + 1;

enum DynamicConfigName {
  DEPOSIT_AT_HOME_STATUS = 1,
  WITHDRAW_AT_HOME_STATUS = 2,
  VISA_MASTER_STATUS = 3,
  ATM_STATUS = 4
};
bool DynamicConfigName_IsValid(int value);
const DynamicConfigName DynamicConfigName_MIN = DEPOSIT_AT_HOME_STATUS;
const DynamicConfigName DynamicConfigName_MAX = ATM_STATUS;
const int DynamicConfigName_ARRAYSIZE = DynamicConfigName_MAX + 1;

enum DynamicConfigValue {
  STATUS_ACTIVE = 1,
  STATUS_INACTIVE = 2
};
bool DynamicConfigValue_IsValid(int value);
const DynamicConfigValue DynamicConfigValue_MIN = STATUS_ACTIVE;
const DynamicConfigValue DynamicConfigValue_MAX = STATUS_INACTIVE;
const int DynamicConfigValue_ARRAYSIZE = DynamicConfigValue_MAX + 1;

// ===================================================================

class TextValueMsg : public ::google::protobuf::MessageLite {
 public:
  TextValueMsg();
  virtual ~TextValueMsg();

  TextValueMsg(const TextValueMsg& from);

  inline TextValueMsg& operator=(const TextValueMsg& from) {
    CopyFrom(from);
    return *this;
  }

  static const TextValueMsg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TextValueMsg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TextValueMsg* other);

  // implements Message ----------------------------------------------

  TextValueMsg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TextValueMsg& from);
  void MergeFrom(const TextValueMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.mservice.momo.msg.TextValue keys = 1;
  inline int keys_size() const;
  inline void clear_keys();
  static const int kKeysFieldNumber = 1;
  inline const ::com::mservice::momo::msg::TextValue& keys(int index) const;
  inline ::com::mservice::momo::msg::TextValue* mutable_keys(int index);
  inline ::com::mservice::momo::msg::TextValue* add_keys();
  inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::TextValue >&
      keys() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::TextValue >*
      mutable_keys();

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.TextValueMsg)
 private:

  ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::TextValue > keys_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static TextValueMsg* default_instance_;
};
// -------------------------------------------------------------------

class FormReply : public ::google::protobuf::MessageLite {
 public:
  FormReply();
  virtual ~FormReply();

  FormReply(const FormReply& from);

  inline FormReply& operator=(const FormReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const FormReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FormReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FormReply* other);

  // implements Message ----------------------------------------------

  FormReply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FormReply& from);
  void MergeFrom(const FormReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.mservice.momo.msg.TextValue list_info = 1;
  inline int list_info_size() const;
  inline void clear_list_info();
  static const int kListInfoFieldNumber = 1;
  inline const ::com::mservice::momo::msg::TextValue& list_info(int index) const;
  inline ::com::mservice::momo::msg::TextValue* mutable_list_info(int index);
  inline ::com::mservice::momo::msg::TextValue* add_list_info();
  inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::TextValue >&
      list_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::TextValue >*
      mutable_list_info();

  // optional uint32 next = 2;
  inline bool has_next() const;
  inline void clear_next();
  static const int kNextFieldNumber = 2;
  inline ::google::protobuf::uint32 next() const;
  inline void set_next(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.FormReply)
 private:
  inline void set_has_next();
  inline void clear_has_next();

  ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::TextValue > list_info_;
  ::google::protobuf::uint32 next_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static FormReply* default_instance_;
};
// -------------------------------------------------------------------

class FormField : public ::google::protobuf::MessageLite {
 public:
  FormField();
  virtual ~FormField();

  FormField(const FormField& from);

  inline FormField& operator=(const FormField& from) {
    CopyFrom(from);
    return *this;
  }

  static const FormField& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FormField* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FormField* other);

  // implements Message ----------------------------------------------

  FormField* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FormField& from);
  void MergeFrom(const FormField& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.mservice.momo.msg.FieldItem list_field_item = 1;
  inline int list_field_item_size() const;
  inline void clear_list_field_item();
  static const int kListFieldItemFieldNumber = 1;
  inline const ::com::mservice::momo::msg::FieldItem& list_field_item(int index) const;
  inline ::com::mservice::momo::msg::FieldItem* mutable_list_field_item(int index);
  inline ::com::mservice::momo::msg::FieldItem* add_list_field_item();
  inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::FieldItem >&
      list_field_item() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::FieldItem >*
      mutable_list_field_item();

  // repeated .com.mservice.momo.msg.ValueForDropBox list_value = 2;
  inline int list_value_size() const;
  inline void clear_list_value();
  static const int kListValueFieldNumber = 2;
  inline const ::com::mservice::momo::msg::ValueForDropBox& list_value(int index) const;
  inline ::com::mservice::momo::msg::ValueForDropBox* mutable_list_value(int index);
  inline ::com::mservice::momo::msg::ValueForDropBox* add_list_value();
  inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::ValueForDropBox >&
      list_value() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::ValueForDropBox >*
      mutable_list_value();

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.FormField)
 private:

  ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::FieldItem > list_field_item_;
  ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::ValueForDropBox > list_value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static FormField* default_instance_;
};
// -------------------------------------------------------------------

class ValueForDropBox : public ::google::protobuf::MessageLite {
 public:
  ValueForDropBox();
  virtual ~ValueForDropBox();

  ValueForDropBox(const ValueForDropBox& from);

  inline ValueForDropBox& operator=(const ValueForDropBox& from) {
    CopyFrom(from);
    return *this;
  }

  static const ValueForDropBox& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ValueForDropBox* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ValueForDropBox* other);

  // implements Message ----------------------------------------------

  ValueForDropBox* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ValueForDropBox& from);
  void MergeFrom(const ValueForDropBox& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string link_to_drop_key = 1;
  inline bool has_link_to_drop_key() const;
  inline void clear_link_to_drop_key();
  static const int kLinkToDropKeyFieldNumber = 1;
  inline const ::std::string& link_to_drop_key() const;
  inline void set_link_to_drop_key(const ::std::string& value);
  inline void set_link_to_drop_key(const char* value);
  inline void set_link_to_drop_key(const char* value, size_t size);
  inline ::std::string* mutable_link_to_drop_key();
  inline ::std::string* release_link_to_drop_key();
  inline void set_allocated_link_to_drop_key(::std::string* link_to_drop_key);

  // repeated .com.mservice.momo.msg.TextValue list_value = 2;
  inline int list_value_size() const;
  inline void clear_list_value();
  static const int kListValueFieldNumber = 2;
  inline const ::com::mservice::momo::msg::TextValue& list_value(int index) const;
  inline ::com::mservice::momo::msg::TextValue* mutable_list_value(int index);
  inline ::com::mservice::momo::msg::TextValue* add_list_value();
  inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::TextValue >&
      list_value() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::TextValue >*
      mutable_list_value();

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.ValueForDropBox)
 private:
  inline void set_has_link_to_drop_key();
  inline void clear_has_link_to_drop_key();

  ::std::string* link_to_drop_key_;
  ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::TextValue > list_value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static ValueForDropBox* default_instance_;
};
// -------------------------------------------------------------------

class GetServiceByLastTime : public ::google::protobuf::MessageLite {
 public:
  GetServiceByLastTime();
  virtual ~GetServiceByLastTime();

  GetServiceByLastTime(const GetServiceByLastTime& from);

  inline GetServiceByLastTime& operator=(const GetServiceByLastTime& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetServiceByLastTime& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetServiceByLastTime* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetServiceByLastTime* other);

  // implements Message ----------------------------------------------

  GetServiceByLastTime* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetServiceByLastTime& from);
  void MergeFrom(const GetServiceByLastTime& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 last_time = 1;
  inline bool has_last_time() const;
  inline void clear_last_time();
  static const int kLastTimeFieldNumber = 1;
  inline ::google::protobuf::uint64 last_time() const;
  inline void set_last_time(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.GetServiceByLastTime)
 private:
  inline void set_has_last_time();
  inline void clear_has_last_time();

  ::google::protobuf::uint64 last_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static GetServiceByLastTime* default_instance_;
};
// -------------------------------------------------------------------

class GetServiceByServiceId : public ::google::protobuf::MessageLite {
 public:
  GetServiceByServiceId();
  virtual ~GetServiceByServiceId();

  GetServiceByServiceId(const GetServiceByServiceId& from);

  inline GetServiceByServiceId& operator=(const GetServiceByServiceId& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetServiceByServiceId& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetServiceByServiceId* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetServiceByServiceId* other);

  // implements Message ----------------------------------------------

  GetServiceByServiceId* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetServiceByServiceId& from);
  void MergeFrom(const GetServiceByServiceId& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string service_id = 1;
  inline bool has_service_id() const;
  inline void clear_service_id();
  static const int kServiceIdFieldNumber = 1;
  inline const ::std::string& service_id() const;
  inline void set_service_id(const ::std::string& value);
  inline void set_service_id(const char* value);
  inline void set_service_id(const char* value, size_t size);
  inline ::std::string* mutable_service_id();
  inline ::std::string* release_service_id();
  inline void set_allocated_service_id(::std::string* service_id);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.GetServiceByServiceId)
 private:
  inline void set_has_service_id();
  inline void clear_has_service_id();

  ::std::string* service_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static GetServiceByServiceId* default_instance_;
};
// -------------------------------------------------------------------

class WholeSystemPaused : public ::google::protobuf::MessageLite {
 public:
  WholeSystemPaused();
  virtual ~WholeSystemPaused();

  WholeSystemPaused(const WholeSystemPaused& from);

  inline WholeSystemPaused& operator=(const WholeSystemPaused& from) {
    CopyFrom(from);
    return *this;
  }

  static const WholeSystemPaused& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const WholeSystemPaused* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(WholeSystemPaused* other);

  // implements Message ----------------------------------------------

  WholeSystemPaused* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const WholeSystemPaused& from);
  void MergeFrom(const WholeSystemPaused& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string caption = 1;
  inline bool has_caption() const;
  inline void clear_caption();
  static const int kCaptionFieldNumber = 1;
  inline const ::std::string& caption() const;
  inline void set_caption(const ::std::string& value);
  inline void set_caption(const char* value);
  inline void set_caption(const char* value, size_t size);
  inline ::std::string* mutable_caption();
  inline ::std::string* release_caption();
  inline void set_allocated_caption(::std::string* caption);

  // optional string body = 2;
  inline bool has_body() const;
  inline void clear_body();
  static const int kBodyFieldNumber = 2;
  inline const ::std::string& body() const;
  inline void set_body(const ::std::string& value);
  inline void set_body(const char* value);
  inline void set_body(const char* value, size_t size);
  inline ::std::string* mutable_body();
  inline ::std::string* release_body();
  inline void set_allocated_body(::std::string* body);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.WholeSystemPaused)
 private:
  inline void set_has_caption();
  inline void clear_has_caption();
  inline void set_has_body();
  inline void clear_has_body();

  ::std::string* caption_;
  ::std::string* body_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static WholeSystemPaused* default_instance_;
};
// -------------------------------------------------------------------

class GetServiceLayout : public ::google::protobuf::MessageLite {
 public:
  GetServiceLayout();
  virtual ~GetServiceLayout();

  GetServiceLayout(const GetServiceLayout& from);

  inline GetServiceLayout& operator=(const GetServiceLayout& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetServiceLayout& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetServiceLayout* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetServiceLayout* other);

  // implements Message ----------------------------------------------

  GetServiceLayout* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetServiceLayout& from);
  void MergeFrom(const GetServiceLayout& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string service_id = 1;
  inline bool has_service_id() const;
  inline void clear_service_id();
  static const int kServiceIdFieldNumber = 1;
  inline const ::std::string& service_id() const;
  inline void set_service_id(const ::std::string& value);
  inline void set_service_id(const char* value);
  inline void set_service_id(const char* value, size_t size);
  inline ::std::string* mutable_service_id();
  inline ::std::string* release_service_id();
  inline void set_allocated_service_id(::std::string* service_id);

  // optional string bill_id = 2;
  inline bool has_bill_id() const;
  inline void clear_bill_id();
  static const int kBillIdFieldNumber = 2;
  inline const ::std::string& bill_id() const;
  inline void set_bill_id(const ::std::string& value);
  inline void set_bill_id(const char* value);
  inline void set_bill_id(const char* value, size_t size);
  inline ::std::string* mutable_bill_id();
  inline ::std::string* release_bill_id();
  inline void set_allocated_bill_id(::std::string* bill_id);

  // optional bool has_check_bill = 3;
  inline bool has_has_check_bill() const;
  inline void clear_has_check_bill();
  static const int kHasCheckBillFieldNumber = 3;
  inline bool has_check_bill() const;
  inline void set_has_check_bill(bool value);

  // optional string service_type = 4;
  inline bool has_service_type() const;
  inline void clear_service_type();
  static const int kServiceTypeFieldNumber = 4;
  inline const ::std::string& service_type() const;
  inline void set_service_type(const ::std::string& value);
  inline void set_service_type(const char* value);
  inline void set_service_type(const char* value, size_t size);
  inline ::std::string* mutable_service_type();
  inline ::std::string* release_service_type();
  inline void set_allocated_service_type(::std::string* service_type);

  // optional bool is_promo = 5;
  inline bool has_is_promo() const;
  inline void clear_is_promo();
  static const int kIsPromoFieldNumber = 5;
  inline bool is_promo() const;
  inline void set_is_promo(bool value);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.GetServiceLayout)
 private:
  inline void set_has_service_id();
  inline void clear_has_service_id();
  inline void set_has_bill_id();
  inline void clear_has_bill_id();
  inline void set_has_has_check_bill();
  inline void clear_has_has_check_bill();
  inline void set_has_service_type();
  inline void clear_has_service_type();
  inline void set_has_is_promo();
  inline void clear_has_is_promo();

  ::std::string* service_id_;
  ::std::string* bill_id_;
  ::std::string* service_type_;
  bool has_check_bill_;
  bool is_promo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static GetServiceLayout* default_instance_;
};
// -------------------------------------------------------------------

class Invitee : public ::google::protobuf::MessageLite {
 public:
  Invitee();
  virtual ~Invitee();

  Invitee(const Invitee& from);

  inline Invitee& operator=(const Invitee& from) {
    CopyFrom(from);
    return *this;
  }

  static const Invitee& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Invitee* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Invitee* other);

  // implements Message ----------------------------------------------

  Invitee* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Invitee& from);
  void MergeFrom(const Invitee& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string phone = 2;
  inline bool has_phone() const;
  inline void clear_phone();
  static const int kPhoneFieldNumber = 2;
  inline const ::std::string& phone() const;
  inline void set_phone(const ::std::string& value);
  inline void set_phone(const char* value);
  inline void set_phone(const char* value, size_t size);
  inline ::std::string* mutable_phone();
  inline ::std::string* release_phone();
  inline void set_allocated_phone(::std::string* phone);

  // optional uint64 time = 3;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 3;
  inline ::google::protobuf::uint64 time() const;
  inline void set_time(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.Invitee)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_phone();
  inline void clear_has_phone();
  inline void set_has_time();
  inline void clear_has_time();

  ::std::string* name_;
  ::std::string* phone_;
  ::google::protobuf::uint64 time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static Invitee* default_instance_;
};
// -------------------------------------------------------------------

class InviteStatisticReply : public ::google::protobuf::MessageLite {
 public:
  InviteStatisticReply();
  virtual ~InviteStatisticReply();

  InviteStatisticReply(const InviteStatisticReply& from);

  inline InviteStatisticReply& operator=(const InviteStatisticReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const InviteStatisticReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const InviteStatisticReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(InviteStatisticReply* other);

  // implements Message ----------------------------------------------

  InviteStatisticReply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const InviteStatisticReply& from);
  void MergeFrom(const InviteStatisticReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.mservice.momo.msg.Invitee invitee_list = 1;
  inline int invitee_list_size() const;
  inline void clear_invitee_list();
  static const int kInviteeListFieldNumber = 1;
  inline const ::com::mservice::momo::msg::Invitee& invitee_list(int index) const;
  inline ::com::mservice::momo::msg::Invitee* mutable_invitee_list(int index);
  inline ::com::mservice::momo::msg::Invitee* add_invitee_list();
  inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::Invitee >&
      invitee_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::Invitee >*
      mutable_invitee_list();

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.InviteStatisticReply)
 private:

  ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::Invitee > invitee_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static InviteStatisticReply* default_instance_;
};
// -------------------------------------------------------------------

class TextValue : public ::google::protobuf::MessageLite {
 public:
  TextValue();
  virtual ~TextValue();

  TextValue(const TextValue& from);

  inline TextValue& operator=(const TextValue& from) {
    CopyFrom(from);
    return *this;
  }

  static const TextValue& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TextValue* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TextValue* other);

  // implements Message ----------------------------------------------

  TextValue* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TextValue& from);
  void MergeFrom(const TextValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string text = 1;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 1;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // optional string id = 3;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 3;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.TextValue)
 private:
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_id();
  inline void clear_has_id();

  ::std::string* text_;
  ::std::string* value_;
  ::std::string* id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static TextValue* default_instance_;
};
// -------------------------------------------------------------------

class Service : public ::google::protobuf::MessageLite {
 public:
  Service();
  virtual ~Service();

  Service(const Service& from);

  inline Service& operator=(const Service& from) {
    CopyFrom(from);
    return *this;
  }

  static const Service& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Service* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Service* other);

  // implements Message ----------------------------------------------

  Service* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Service& from);
  void MergeFrom(const Service& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string service_type = 1;
  inline bool has_service_type() const;
  inline void clear_service_type();
  static const int kServiceTypeFieldNumber = 1;
  inline const ::std::string& service_type() const;
  inline void set_service_type(const ::std::string& value);
  inline void set_service_type(const char* value);
  inline void set_service_type(const char* value, size_t size);
  inline ::std::string* mutable_service_type();
  inline ::std::string* release_service_type();
  inline void set_allocated_service_type(::std::string* service_type);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.Service)
 private:
  inline void set_has_service_type();
  inline void clear_has_service_type();

  ::std::string* service_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static Service* default_instance_;
};
// -------------------------------------------------------------------

class ServiceItem : public ::google::protobuf::MessageLite {
 public:
  ServiceItem();
  virtual ~ServiceItem();

  ServiceItem(const ServiceItem& from);

  inline ServiceItem& operator=(const ServiceItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const ServiceItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ServiceItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ServiceItem* other);

  // implements Message ----------------------------------------------

  ServiceItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ServiceItem& from);
  void MergeFrom(const ServiceItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string service_type = 1;
  inline bool has_service_type() const;
  inline void clear_service_type();
  static const int kServiceTypeFieldNumber = 1;
  inline const ::std::string& service_type() const;
  inline void set_service_type(const ::std::string& value);
  inline void set_service_type(const char* value);
  inline void set_service_type(const char* value, size_t size);
  inline ::std::string* mutable_service_type();
  inline ::std::string* release_service_type();
  inline void set_allocated_service_type(::std::string* service_type);

  // optional string partner_code = 2;
  inline bool has_partner_code() const;
  inline void clear_partner_code();
  static const int kPartnerCodeFieldNumber = 2;
  inline const ::std::string& partner_code() const;
  inline void set_partner_code(const ::std::string& value);
  inline void set_partner_code(const char* value);
  inline void set_partner_code(const char* value, size_t size);
  inline ::std::string* mutable_partner_code();
  inline ::std::string* release_partner_code();
  inline void set_allocated_partner_code(::std::string* partner_code);

  // optional string service_id = 3;
  inline bool has_service_id() const;
  inline void clear_service_id();
  static const int kServiceIdFieldNumber = 3;
  inline const ::std::string& service_id() const;
  inline void set_service_id(const ::std::string& value);
  inline void set_service_id(const char* value);
  inline void set_service_id(const char* value, size_t size);
  inline ::std::string* mutable_service_id();
  inline ::std::string* release_service_id();
  inline void set_allocated_service_id(::std::string* service_id);

  // optional string service_name = 4;
  inline bool has_service_name() const;
  inline void clear_service_name();
  static const int kServiceNameFieldNumber = 4;
  inline const ::std::string& service_name() const;
  inline void set_service_name(const ::std::string& value);
  inline void set_service_name(const char* value);
  inline void set_service_name(const char* value, size_t size);
  inline ::std::string* mutable_service_name();
  inline ::std::string* release_service_name();
  inline void set_allocated_service_name(::std::string* service_name);

  // optional string partner_site = 5;
  inline bool has_partner_site() const;
  inline void clear_partner_site();
  static const int kPartnerSiteFieldNumber = 5;
  inline const ::std::string& partner_site() const;
  inline void set_partner_site(const ::std::string& value);
  inline void set_partner_site(const char* value);
  inline void set_partner_site(const char* value, size_t size);
  inline ::std::string* mutable_partner_site();
  inline ::std::string* release_partner_site();
  inline void set_allocated_partner_site(::std::string* partner_site);

  // optional string icon_url = 6;
  inline bool has_icon_url() const;
  inline void clear_icon_url();
  static const int kIconUrlFieldNumber = 6;
  inline const ::std::string& icon_url() const;
  inline void set_icon_url(const ::std::string& value);
  inline void set_icon_url(const char* value);
  inline void set_icon_url(const char* value, size_t size);
  inline ::std::string* mutable_icon_url();
  inline ::std::string* release_icon_url();
  inline void set_allocated_icon_url(::std::string* icon_url);

  // optional uint32 status = 7;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 7;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // optional string text_popup = 8;
  inline bool has_text_popup() const;
  inline void clear_text_popup();
  static const int kTextPopupFieldNumber = 8;
  inline const ::std::string& text_popup() const;
  inline void set_text_popup(const ::std::string& value);
  inline void set_text_popup(const char* value);
  inline void set_text_popup(const char* value, size_t size);
  inline ::std::string* mutable_text_popup();
  inline ::std::string* release_text_popup();
  inline void set_allocated_text_popup(::std::string* text_popup);

  // optional bool has_check_debit = 9;
  inline bool has_has_check_debit() const;
  inline void clear_has_check_debit();
  static const int kHasCheckDebitFieldNumber = 9;
  inline bool has_check_debit() const;
  inline void set_has_check_debit(bool value);

  // optional string title_dialog = 10;
  inline bool has_title_dialog() const;
  inline void clear_title_dialog();
  static const int kTitleDialogFieldNumber = 10;
  inline const ::std::string& title_dialog() const;
  inline void set_title_dialog(const ::std::string& value);
  inline void set_title_dialog(const char* value);
  inline void set_title_dialog(const char* value, size_t size);
  inline ::std::string* mutable_title_dialog();
  inline ::std::string* release_title_dialog();
  inline void set_allocated_title_dialog(::std::string* title_dialog);

  // optional uint64 last_update = 11;
  inline bool has_last_update() const;
  inline void clear_last_update();
  static const int kLastUpdateFieldNumber = 11;
  inline ::google::protobuf::uint64 last_update() const;
  inline void set_last_update(::google::protobuf::uint64 value);

  // optional string billid_type = 12;
  inline bool has_billid_type() const;
  inline void clear_billid_type();
  static const int kBillidTypeFieldNumber = 12;
  inline const ::std::string& billid_type() const;
  inline void set_billid_type(const ::std::string& value);
  inline void set_billid_type(const char* value);
  inline void set_billid_type(const char* value, size_t size);
  inline ::std::string* mutable_billid_type();
  inline ::std::string* release_billid_type();
  inline void set_allocated_billid_type(::std::string* billid_type);

  // optional bool is_promo = 13;
  inline bool has_is_promo() const;
  inline void clear_is_promo();
  static const int kIsPromoFieldNumber = 13;
  inline bool is_promo() const;
  inline void set_is_promo(bool value);

  // optional uint32 total_form = 14;
  inline bool has_total_form() const;
  inline void clear_total_form();
  static const int kTotalFormFieldNumber = 14;
  inline ::google::protobuf::uint32 total_form() const;
  inline void set_total_form(::google::protobuf::uint32 value);

  // optional uint32 star = 15;
  inline bool has_star() const;
  inline void clear_star();
  static const int kStarFieldNumber = 15;
  inline ::google::protobuf::uint32 star() const;
  inline void set_star(::google::protobuf::uint32 value);

  // optional string category_name = 16;
  inline bool has_category_name() const;
  inline void clear_category_name();
  static const int kCategoryNameFieldNumber = 16;
  inline const ::std::string& category_name() const;
  inline void set_category_name(const ::std::string& value);
  inline void set_category_name(const char* value);
  inline void set_category_name(const char* value, size_t size);
  inline ::std::string* mutable_category_name();
  inline ::std::string* release_category_name();
  inline void set_allocated_category_name(::std::string* category_name);

  // optional string category_id = 17;
  inline bool has_category_id() const;
  inline void clear_category_id();
  static const int kCategoryIdFieldNumber = 17;
  inline const ::std::string& category_id() const;
  inline void set_category_id(const ::std::string& value);
  inline void set_category_id(const char* value);
  inline void set_category_id(const char* value, size_t size);
  inline ::std::string* mutable_category_id();
  inline ::std::string* release_category_id();
  inline void set_allocated_category_id(::std::string* category_id);

  // optional string web_payment_url = 18;
  inline bool has_web_payment_url() const;
  inline void clear_web_payment_url();
  static const int kWebPaymentUrlFieldNumber = 18;
  inline const ::std::string& web_payment_url() const;
  inline void set_web_payment_url(const ::std::string& value);
  inline void set_web_payment_url(const char* value);
  inline void set_web_payment_url(const char* value, size_t size);
  inline ::std::string* mutable_web_payment_url();
  inline ::std::string* release_web_payment_url();
  inline void set_allocated_web_payment_url(::std::string* web_payment_url);

  // optional string secret_key = 19;
  inline bool has_secret_key() const;
  inline void clear_secret_key();
  static const int kSecretKeyFieldNumber = 19;
  inline const ::std::string& secret_key() const;
  inline void set_secret_key(const ::std::string& value);
  inline void set_secret_key(const char* value);
  inline void set_secret_key(const char* value, size_t size);
  inline ::std::string* mutable_secret_key();
  inline ::std::string* release_secret_key();
  inline void set_allocated_secret_key(::std::string* secret_key);

  // optional uint32 order = 20;
  inline bool has_order() const;
  inline void clear_order();
  static const int kOrderFieldNumber = 20;
  inline ::google::protobuf::uint32 order() const;
  inline void set_order(::google::protobuf::uint32 value);

  // optional string billpay_extra = 21;
  inline bool has_billpay_extra() const;
  inline void clear_billpay_extra();
  static const int kBillpayExtraFieldNumber = 21;
  inline const ::std::string& billpay_extra() const;
  inline void set_billpay_extra(const ::std::string& value);
  inline void set_billpay_extra(const char* value);
  inline void set_billpay_extra(const char* value, size_t size);
  inline ::std::string* mutable_billpay_extra();
  inline ::std::string* release_billpay_extra();
  inline void set_allocated_billpay_extra(::std::string* billpay_extra);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.ServiceItem)
 private:
  inline void set_has_service_type();
  inline void clear_has_service_type();
  inline void set_has_partner_code();
  inline void clear_has_partner_code();
  inline void set_has_service_id();
  inline void clear_has_service_id();
  inline void set_has_service_name();
  inline void clear_has_service_name();
  inline void set_has_partner_site();
  inline void clear_has_partner_site();
  inline void set_has_icon_url();
  inline void clear_has_icon_url();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_text_popup();
  inline void clear_has_text_popup();
  inline void set_has_has_check_debit();
  inline void clear_has_has_check_debit();
  inline void set_has_title_dialog();
  inline void clear_has_title_dialog();
  inline void set_has_last_update();
  inline void clear_has_last_update();
  inline void set_has_billid_type();
  inline void clear_has_billid_type();
  inline void set_has_is_promo();
  inline void clear_has_is_promo();
  inline void set_has_total_form();
  inline void clear_has_total_form();
  inline void set_has_star();
  inline void clear_has_star();
  inline void set_has_category_name();
  inline void clear_has_category_name();
  inline void set_has_category_id();
  inline void clear_has_category_id();
  inline void set_has_web_payment_url();
  inline void clear_has_web_payment_url();
  inline void set_has_secret_key();
  inline void clear_has_secret_key();
  inline void set_has_order();
  inline void clear_has_order();
  inline void set_has_billpay_extra();
  inline void clear_has_billpay_extra();

  ::std::string* service_type_;
  ::std::string* partner_code_;
  ::std::string* service_id_;
  ::std::string* service_name_;
  ::std::string* partner_site_;
  ::std::string* icon_url_;
  ::std::string* text_popup_;
  ::google::protobuf::uint32 status_;
  bool has_check_debit_;
  bool is_promo_;
  ::std::string* title_dialog_;
  ::google::protobuf::uint64 last_update_;
  ::std::string* billid_type_;
  ::google::protobuf::uint32 total_form_;
  ::google::protobuf::uint32 star_;
  ::std::string* category_name_;
  ::std::string* category_id_;
  ::std::string* web_payment_url_;
  ::std::string* secret_key_;
  ::std::string* billpay_extra_;
  ::google::protobuf::uint32 order_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(21 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static ServiceItem* default_instance_;
};
// -------------------------------------------------------------------

class ServiceReply : public ::google::protobuf::MessageLite {
 public:
  ServiceReply();
  virtual ~ServiceReply();

  ServiceReply(const ServiceReply& from);

  inline ServiceReply& operator=(const ServiceReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const ServiceReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ServiceReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ServiceReply* other);

  // implements Message ----------------------------------------------

  ServiceReply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ServiceReply& from);
  void MergeFrom(const ServiceReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.mservice.momo.msg.ServiceItem service_list = 1;
  inline int service_list_size() const;
  inline void clear_service_list();
  static const int kServiceListFieldNumber = 1;
  inline const ::com::mservice::momo::msg::ServiceItem& service_list(int index) const;
  inline ::com::mservice::momo::msg::ServiceItem* mutable_service_list(int index);
  inline ::com::mservice::momo::msg::ServiceItem* add_service_list();
  inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::ServiceItem >&
      service_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::ServiceItem >*
      mutable_service_list();

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.ServiceReply)
 private:

  ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::ServiceItem > service_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static ServiceReply* default_instance_;
};
// -------------------------------------------------------------------

class FieldItem : public ::google::protobuf::MessageLite {
 public:
  FieldItem();
  virtual ~FieldItem();

  FieldItem(const FieldItem& from);

  inline FieldItem& operator=(const FieldItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const FieldItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FieldItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FieldItem* other);

  // implements Message ----------------------------------------------

  FieldItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FieldItem& from);
  void MergeFrom(const FieldItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string field_label = 1;
  inline bool has_field_label() const;
  inline void clear_field_label();
  static const int kFieldLabelFieldNumber = 1;
  inline const ::std::string& field_label() const;
  inline void set_field_label(const ::std::string& value);
  inline void set_field_label(const char* value);
  inline void set_field_label(const char* value, size_t size);
  inline ::std::string* mutable_field_label();
  inline ::std::string* release_field_label();
  inline void set_allocated_field_label(::std::string* field_label);

  // optional string field_type = 2;
  inline bool has_field_type() const;
  inline void clear_field_type();
  static const int kFieldTypeFieldNumber = 2;
  inline const ::std::string& field_type() const;
  inline void set_field_type(const ::std::string& value);
  inline void set_field_type(const char* value);
  inline void set_field_type(const char* value, size_t size);
  inline ::std::string* mutable_field_type();
  inline ::std::string* release_field_type();
  inline void set_allocated_field_type(::std::string* field_type);

  // optional bool is_amount = 3;
  inline bool has_is_amount() const;
  inline void clear_is_amount();
  static const int kIsAmountFieldNumber = 3;
  inline bool is_amount() const;
  inline void set_is_amount(bool value);

  // optional bool is_bill_id = 4;
  inline bool has_is_bill_id() const;
  inline void clear_is_bill_id();
  static const int kIsBillIdFieldNumber = 4;
  inline bool is_bill_id() const;
  inline void set_is_bill_id(bool value);

  // optional string key = 5;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 5;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional uint32 require = 6;
  inline bool has_require() const;
  inline void clear_require();
  static const int kRequireFieldNumber = 6;
  inline ::google::protobuf::uint32 require() const;
  inline void set_require(::google::protobuf::uint32 value);

  // optional uint32 has_child = 7;
  inline bool has_has_child() const;
  inline void clear_has_child();
  static const int kHasChildFieldNumber = 7;
  inline ::google::protobuf::uint32 has_child() const;
  inline void set_has_child(::google::protobuf::uint32 value);

  // optional uint32 line = 8;
  inline bool has_line() const;
  inline void clear_line();
  static const int kLineFieldNumber = 8;
  inline ::google::protobuf::uint32 line() const;
  inline void set_line(::google::protobuf::uint32 value);

  // optional bool readonly = 9;
  inline bool has_readonly() const;
  inline void clear_readonly();
  static const int kReadonlyFieldNumber = 9;
  inline bool readonly() const;
  inline void set_readonly(bool value);

  // optional string value = 10;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 10;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.FieldItem)
 private:
  inline void set_has_field_label();
  inline void clear_has_field_label();
  inline void set_has_field_type();
  inline void clear_has_field_type();
  inline void set_has_is_amount();
  inline void clear_has_is_amount();
  inline void set_has_is_bill_id();
  inline void clear_has_is_bill_id();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_require();
  inline void clear_has_require();
  inline void set_has_has_child();
  inline void clear_has_has_child();
  inline void set_has_line();
  inline void clear_has_line();
  inline void set_has_readonly();
  inline void clear_has_readonly();
  inline void set_has_value();
  inline void clear_has_value();

  ::std::string* field_label_;
  ::std::string* field_type_;
  ::std::string* key_;
  bool is_amount_;
  bool is_bill_id_;
  bool readonly_;
  ::google::protobuf::uint32 require_;
  ::google::protobuf::uint32 has_child_;
  ::google::protobuf::uint32 line_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static FieldItem* default_instance_;
};
// -------------------------------------------------------------------

class ExtraInfo : public ::google::protobuf::MessageLite {
 public:
  ExtraInfo();
  virtual ~ExtraInfo();

  ExtraInfo(const ExtraInfo& from);

  inline ExtraInfo& operator=(const ExtraInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ExtraInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ExtraInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ExtraInfo* other);

  // implements Message ----------------------------------------------

  ExtraInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ExtraInfo& from);
  void MergeFrom(const ExtraInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string bill_detail_id = 1;
  inline bool has_bill_detail_id() const;
  inline void clear_bill_detail_id();
  static const int kBillDetailIdFieldNumber = 1;
  inline const ::std::string& bill_detail_id() const;
  inline void set_bill_detail_id(const ::std::string& value);
  inline void set_bill_detail_id(const char* value);
  inline void set_bill_detail_id(const char* value, size_t size);
  inline ::std::string* mutable_bill_detail_id();
  inline ::std::string* release_bill_detail_id();
  inline void set_allocated_bill_detail_id(::std::string* bill_detail_id);

  // optional string amount = 2;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 2;
  inline const ::std::string& amount() const;
  inline void set_amount(const ::std::string& value);
  inline void set_amount(const char* value);
  inline void set_amount(const char* value, size_t size);
  inline ::std::string* mutable_amount();
  inline ::std::string* release_amount();
  inline void set_allocated_amount(::std::string* amount);

  // optional string from_date = 3;
  inline bool has_from_date() const;
  inline void clear_from_date();
  static const int kFromDateFieldNumber = 3;
  inline const ::std::string& from_date() const;
  inline void set_from_date(const ::std::string& value);
  inline void set_from_date(const char* value);
  inline void set_from_date(const char* value, size_t size);
  inline ::std::string* mutable_from_date();
  inline ::std::string* release_from_date();
  inline void set_allocated_from_date(::std::string* from_date);

  // optional string to_date = 4;
  inline bool has_to_date() const;
  inline void clear_to_date();
  static const int kToDateFieldNumber = 4;
  inline const ::std::string& to_date() const;
  inline void set_to_date(const ::std::string& value);
  inline void set_to_date(const char* value);
  inline void set_to_date(const char* value, size_t size);
  inline ::std::string* mutable_to_date();
  inline ::std::string* release_to_date();
  inline void set_allocated_to_date(::std::string* to_date);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.ExtraInfo)
 private:
  inline void set_has_bill_detail_id();
  inline void clear_has_bill_detail_id();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_from_date();
  inline void clear_has_from_date();
  inline void set_has_to_date();
  inline void clear_has_to_date();

  ::std::string* bill_detail_id_;
  ::std::string* amount_;
  ::std::string* from_date_;
  ::std::string* to_date_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static ExtraInfo* default_instance_;
};
// -------------------------------------------------------------------

class GetServiceLayoutReply : public ::google::protobuf::MessageLite {
 public:
  GetServiceLayoutReply();
  virtual ~GetServiceLayoutReply();

  GetServiceLayoutReply(const GetServiceLayoutReply& from);

  inline GetServiceLayoutReply& operator=(const GetServiceLayoutReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetServiceLayoutReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetServiceLayoutReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetServiceLayoutReply* other);

  // implements Message ----------------------------------------------

  GetServiceLayoutReply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetServiceLayoutReply& from);
  void MergeFrom(const GetServiceLayoutReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 total_amount = 1;
  inline bool has_total_amount() const;
  inline void clear_total_amount();
  static const int kTotalAmountFieldNumber = 1;
  inline ::google::protobuf::uint64 total_amount() const;
  inline void set_total_amount(::google::protobuf::uint64 value);

  // repeated .com.mservice.momo.msg.FieldItem list_field = 2;
  inline int list_field_size() const;
  inline void clear_list_field();
  static const int kListFieldFieldNumber = 2;
  inline const ::com::mservice::momo::msg::FieldItem& list_field(int index) const;
  inline ::com::mservice::momo::msg::FieldItem* mutable_list_field(int index);
  inline ::com::mservice::momo::msg::FieldItem* add_list_field();
  inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::FieldItem >&
      list_field() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::FieldItem >*
      mutable_list_field();

  // repeated .com.mservice.momo.msg.TextValue array_price = 3;
  inline int array_price_size() const;
  inline void clear_array_price();
  static const int kArrayPriceFieldNumber = 3;
  inline const ::com::mservice::momo::msg::TextValue& array_price(int index) const;
  inline ::com::mservice::momo::msg::TextValue* mutable_array_price(int index);
  inline ::com::mservice::momo::msg::TextValue* add_array_price();
  inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::TextValue >&
      array_price() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::TextValue >*
      mutable_array_price();

  // repeated .com.mservice.momo.msg.TextValue customer_info = 4;
  inline int customer_info_size() const;
  inline void clear_customer_info();
  static const int kCustomerInfoFieldNumber = 4;
  inline const ::com::mservice::momo::msg::TextValue& customer_info(int index) const;
  inline ::com::mservice::momo::msg::TextValue* mutable_customer_info(int index);
  inline ::com::mservice::momo::msg::TextValue* add_customer_info();
  inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::TextValue >&
      customer_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::TextValue >*
      mutable_customer_info();

  // repeated .com.mservice.momo.msg.ExtraInfo extra_info = 5;
  inline int extra_info_size() const;
  inline void clear_extra_info();
  static const int kExtraInfoFieldNumber = 5;
  inline const ::com::mservice::momo::msg::ExtraInfo& extra_info(int index) const;
  inline ::com::mservice::momo::msg::ExtraInfo* mutable_extra_info(int index);
  inline ::com::mservice::momo::msg::ExtraInfo* add_extra_info();
  inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::ExtraInfo >&
      extra_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::ExtraInfo >*
      mutable_extra_info();

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.GetServiceLayoutReply)
 private:
  inline void set_has_total_amount();
  inline void clear_has_total_amount();

  ::google::protobuf::uint64 total_amount_;
  ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::FieldItem > list_field_;
  ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::TextValue > array_price_;
  ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::TextValue > customer_info_;
  ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::ExtraInfo > extra_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static GetServiceLayoutReply* default_instance_;
};
// -------------------------------------------------------------------

class Promotion : public ::google::protobuf::MessageLite {
 public:
  Promotion();
  virtual ~Promotion();

  Promotion(const Promotion& from);

  inline Promotion& operator=(const Promotion& from) {
    CopyFrom(from);
    return *this;
  }

  static const Promotion& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Promotion* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Promotion* other);

  // implements Message ----------------------------------------------

  Promotion* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Promotion& from);
  void MergeFrom(const Promotion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional uint64 from_date = 2;
  inline bool has_from_date() const;
  inline void clear_from_date();
  static const int kFromDateFieldNumber = 2;
  inline ::google::protobuf::uint64 from_date() const;
  inline void set_from_date(::google::protobuf::uint64 value);

  // optional uint64 to_date = 3;
  inline bool has_to_date() const;
  inline void clear_to_date();
  static const int kToDateFieldNumber = 3;
  inline ::google::protobuf::uint64 to_date() const;
  inline void set_to_date(::google::protobuf::uint64 value);

  // optional bool is_active = 4;
  inline bool has_is_active() const;
  inline void clear_is_active();
  static const int kIsActiveFieldNumber = 4;
  inline bool is_active() const;
  inline void set_is_active(bool value);

  // optional string promotion_name = 6;
  inline bool has_promotion_name() const;
  inline void clear_promotion_name();
  static const int kPromotionNameFieldNumber = 6;
  inline const ::std::string& promotion_name() const;
  inline void set_promotion_name(const ::std::string& value);
  inline void set_promotion_name(const char* value);
  inline void set_promotion_name(const char* value, size_t size);
  inline ::std::string* mutable_promotion_name();
  inline ::std::string* release_promotion_name();
  inline void set_allocated_promotion_name(::std::string* promotion_name);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.Promotion)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_from_date();
  inline void clear_has_from_date();
  inline void set_has_to_date();
  inline void clear_has_to_date();
  inline void set_has_is_active();
  inline void clear_has_is_active();
  inline void set_has_promotion_name();
  inline void clear_has_promotion_name();

  ::std::string* id_;
  ::google::protobuf::uint64 from_date_;
  ::google::protobuf::uint64 to_date_;
  ::std::string* promotion_name_;
  bool is_active_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static Promotion* default_instance_;
};
// -------------------------------------------------------------------

class GetPromotionReply : public ::google::protobuf::MessageLite {
 public:
  GetPromotionReply();
  virtual ~GetPromotionReply();

  GetPromotionReply(const GetPromotionReply& from);

  inline GetPromotionReply& operator=(const GetPromotionReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetPromotionReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetPromotionReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetPromotionReply* other);

  // implements Message ----------------------------------------------

  GetPromotionReply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetPromotionReply& from);
  void MergeFrom(const GetPromotionReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.mservice.momo.msg.Promotion promotion_list = 1;
  inline int promotion_list_size() const;
  inline void clear_promotion_list();
  static const int kPromotionListFieldNumber = 1;
  inline const ::com::mservice::momo::msg::Promotion& promotion_list(int index) const;
  inline ::com::mservice::momo::msg::Promotion* mutable_promotion_list(int index);
  inline ::com::mservice::momo::msg::Promotion* add_promotion_list();
  inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::Promotion >&
      promotion_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::Promotion >*
      mutable_promotion_list();

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.GetPromotionReply)
 private:

  ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::Promotion > promotion_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static GetPromotionReply* default_instance_;
};
// -------------------------------------------------------------------

class GetPromotionDetail : public ::google::protobuf::MessageLite {
 public:
  GetPromotionDetail();
  virtual ~GetPromotionDetail();

  GetPromotionDetail(const GetPromotionDetail& from);

  inline GetPromotionDetail& operator=(const GetPromotionDetail& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetPromotionDetail& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetPromotionDetail* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetPromotionDetail* other);

  // implements Message ----------------------------------------------

  GetPromotionDetail* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetPromotionDetail& from);
  void MergeFrom(const GetPromotionDetail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.GetPromotionDetail)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::std::string* id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static GetPromotionDetail* default_instance_;
};
// -------------------------------------------------------------------

class GetPromotionDetailReply : public ::google::protobuf::MessageLite {
 public:
  GetPromotionDetailReply();
  virtual ~GetPromotionDetailReply();

  GetPromotionDetailReply(const GetPromotionDetailReply& from);

  inline GetPromotionDetailReply& operator=(const GetPromotionDetailReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetPromotionDetailReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetPromotionDetailReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetPromotionDetailReply* other);

  // implements Message ----------------------------------------------

  GetPromotionDetailReply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetPromotionDetailReply& from);
  void MergeFrom(const GetPromotionDetailReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string intro_data = 1;
  inline bool has_intro_data() const;
  inline void clear_intro_data();
  static const int kIntroDataFieldNumber = 1;
  inline const ::std::string& intro_data() const;
  inline void set_intro_data(const ::std::string& value);
  inline void set_intro_data(const char* value);
  inline void set_intro_data(const char* value, size_t size);
  inline ::std::string* mutable_intro_data();
  inline ::std::string* release_intro_data();
  inline void set_allocated_intro_data(::std::string* intro_data);

  // optional string intro_sms = 2;
  inline bool has_intro_sms() const;
  inline void clear_intro_sms();
  static const int kIntroSmsFieldNumber = 2;
  inline const ::std::string& intro_sms() const;
  inline void set_intro_sms(const ::std::string& value);
  inline void set_intro_sms(const char* value);
  inline void set_intro_sms(const char* value, size_t size);
  inline ::std::string* mutable_intro_sms();
  inline ::std::string* release_intro_sms();
  inline void set_allocated_intro_sms(::std::string* intro_sms);

  // optional uint32 duration = 3;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 3;
  inline ::google::protobuf::uint32 duration() const;
  inline void set_duration(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.GetPromotionDetailReply)
 private:
  inline void set_has_intro_data();
  inline void clear_has_intro_data();
  inline void set_has_intro_sms();
  inline void clear_has_intro_sms();
  inline void set_has_duration();
  inline void clear_has_duration();

  ::std::string* intro_data_;
  ::std::string* intro_sms_;
  ::google::protobuf::uint32 duration_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static GetPromotionDetailReply* default_instance_;
};
// -------------------------------------------------------------------

class MinMax : public ::google::protobuf::MessageLite {
 public:
  MinMax();
  virtual ~MinMax();

  MinMax(const MinMax& from);

  inline MinMax& operator=(const MinMax& from) {
    CopyFrom(from);
    return *this;
  }

  static const MinMax& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MinMax* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MinMax* other);

  // implements Message ----------------------------------------------

  MinMax* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MinMax& from);
  void MergeFrom(const MinMax& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 tran_type = 1;
  inline bool has_tran_type() const;
  inline void clear_tran_type();
  static const int kTranTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 tran_type() const;
  inline void set_tran_type(::google::protobuf::uint32 value);

  // optional bool is_named = 2;
  inline bool has_is_named() const;
  inline void clear_is_named();
  static const int kIsNamedFieldNumber = 2;
  inline bool is_named() const;
  inline void set_is_named(bool value);

  // optional uint64 min_value = 3;
  inline bool has_min_value() const;
  inline void clear_min_value();
  static const int kMinValueFieldNumber = 3;
  inline ::google::protobuf::uint64 min_value() const;
  inline void set_min_value(::google::protobuf::uint64 value);

  // optional uint64 max_value = 4;
  inline bool has_max_value() const;
  inline void clear_max_value();
  static const int kMaxValueFieldNumber = 4;
  inline ::google::protobuf::uint64 max_value() const;
  inline void set_max_value(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.MinMax)
 private:
  inline void set_has_tran_type();
  inline void clear_has_tran_type();
  inline void set_has_is_named();
  inline void clear_has_is_named();
  inline void set_has_min_value();
  inline void clear_has_min_value();
  inline void set_has_max_value();
  inline void clear_has_max_value();

  ::google::protobuf::uint32 tran_type_;
  bool is_named_;
  ::google::protobuf::uint64 min_value_;
  ::google::protobuf::uint64 max_value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static MinMax* default_instance_;
};
// -------------------------------------------------------------------

class MinMaxReply : public ::google::protobuf::MessageLite {
 public:
  MinMaxReply();
  virtual ~MinMaxReply();

  MinMaxReply(const MinMaxReply& from);

  inline MinMaxReply& operator=(const MinMaxReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const MinMaxReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MinMaxReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MinMaxReply* other);

  // implements Message ----------------------------------------------

  MinMaxReply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MinMaxReply& from);
  void MergeFrom(const MinMaxReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.mservice.momo.msg.MinMax min_max_list = 1;
  inline int min_max_list_size() const;
  inline void clear_min_max_list();
  static const int kMinMaxListFieldNumber = 1;
  inline const ::com::mservice::momo::msg::MinMax& min_max_list(int index) const;
  inline ::com::mservice::momo::msg::MinMax* mutable_min_max_list(int index);
  inline ::com::mservice::momo::msg::MinMax* add_min_max_list();
  inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::MinMax >&
      min_max_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::MinMax >*
      mutable_min_max_list();

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.MinMaxReply)
 private:

  ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::MinMax > min_max_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static MinMaxReply* default_instance_;
};
// -------------------------------------------------------------------

class CreateOrder123Phim : public ::google::protobuf::MessageLite {
 public:
  CreateOrder123Phim();
  virtual ~CreateOrder123Phim();

  CreateOrder123Phim(const CreateOrder123Phim& from);

  inline CreateOrder123Phim& operator=(const CreateOrder123Phim& from) {
    CopyFrom(from);
    return *this;
  }

  static const CreateOrder123Phim& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CreateOrder123Phim* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CreateOrder123Phim* other);

  // implements Message ----------------------------------------------

  CreateOrder123Phim* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CreateOrder123Phim& from);
  void MergeFrom(const CreateOrder123Phim& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 session_id = 1;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  inline ::google::protobuf::uint64 session_id() const;
  inline void set_session_id(::google::protobuf::uint64 value);

  // repeated string seat_list = 2;
  inline int seat_list_size() const;
  inline void clear_seat_list();
  static const int kSeatListFieldNumber = 2;
  inline const ::std::string& seat_list(int index) const;
  inline ::std::string* mutable_seat_list(int index);
  inline void set_seat_list(int index, const ::std::string& value);
  inline void set_seat_list(int index, const char* value);
  inline void set_seat_list(int index, const char* value, size_t size);
  inline ::std::string* add_seat_list();
  inline void add_seat_list(const ::std::string& value);
  inline void add_seat_list(const char* value);
  inline void add_seat_list(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& seat_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_seat_list();

  // optional string device_id = 3;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 3;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional string phone_number = 4;
  inline bool has_phone_number() const;
  inline void clear_phone_number();
  static const int kPhoneNumberFieldNumber = 4;
  inline const ::std::string& phone_number() const;
  inline void set_phone_number(const ::std::string& value);
  inline void set_phone_number(const char* value);
  inline void set_phone_number(const char* value, size_t size);
  inline ::std::string* mutable_phone_number();
  inline ::std::string* release_phone_number();
  inline void set_allocated_phone_number(::std::string* phone_number);

  // optional string email = 5;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 5;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.CreateOrder123Phim)
 private:
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_phone_number();
  inline void clear_has_phone_number();
  inline void set_has_email();
  inline void clear_has_email();

  ::google::protobuf::uint64 session_id_;
  ::google::protobuf::RepeatedPtrField< ::std::string> seat_list_;
  ::std::string* device_id_;
  ::std::string* phone_number_;
  ::std::string* email_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static CreateOrder123Phim* default_instance_;
};
// -------------------------------------------------------------------

class Seat : public ::google::protobuf::MessageLite {
 public:
  Seat();
  virtual ~Seat();

  Seat(const Seat& from);

  inline Seat& operator=(const Seat& from) {
    CopyFrom(from);
    return *this;
  }

  static const Seat& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Seat* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Seat* other);

  // implements Message ----------------------------------------------

  Seat* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Seat& from);
  void MergeFrom(const Seat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string seat = 1;
  inline bool has_seat() const;
  inline void clear_seat();
  static const int kSeatFieldNumber = 1;
  inline const ::std::string& seat() const;
  inline void set_seat(const ::std::string& value);
  inline void set_seat(const char* value);
  inline void set_seat(const char* value, size_t size);
  inline ::std::string* mutable_seat();
  inline ::std::string* release_seat();
  inline void set_allocated_seat(::std::string* seat);

  // optional uint32 price = 2;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 2;
  inline ::google::protobuf::uint32 price() const;
  inline void set_price(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.Seat)
 private:
  inline void set_has_seat();
  inline void clear_has_seat();
  inline void set_has_price();
  inline void clear_has_price();

  ::std::string* seat_;
  ::google::protobuf::uint32 price_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static Seat* default_instance_;
};
// -------------------------------------------------------------------

class CreateOrder123PhimReply : public ::google::protobuf::MessageLite {
 public:
  CreateOrder123PhimReply();
  virtual ~CreateOrder123PhimReply();

  CreateOrder123PhimReply(const CreateOrder123PhimReply& from);

  inline CreateOrder123PhimReply& operator=(const CreateOrder123PhimReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const CreateOrder123PhimReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CreateOrder123PhimReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CreateOrder123PhimReply* other);

  // implements Message ----------------------------------------------

  CreateOrder123PhimReply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CreateOrder123PhimReply& from);
  void MergeFrom(const CreateOrder123PhimReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string invoice_no = 1;
  inline bool has_invoice_no() const;
  inline void clear_invoice_no();
  static const int kInvoiceNoFieldNumber = 1;
  inline const ::std::string& invoice_no() const;
  inline void set_invoice_no(const ::std::string& value);
  inline void set_invoice_no(const char* value);
  inline void set_invoice_no(const char* value, size_t size);
  inline ::std::string* mutable_invoice_no();
  inline ::std::string* release_invoice_no();
  inline void set_allocated_invoice_no(::std::string* invoice_no);

  // optional string ticket_code = 2;
  inline bool has_ticket_code() const;
  inline void clear_ticket_code();
  static const int kTicketCodeFieldNumber = 2;
  inline const ::std::string& ticket_code() const;
  inline void set_ticket_code(const ::std::string& value);
  inline void set_ticket_code(const char* value);
  inline void set_ticket_code(const char* value, size_t size);
  inline ::std::string* mutable_ticket_code();
  inline ::std::string* release_ticket_code();
  inline void set_allocated_ticket_code(::std::string* ticket_code);

  // optional uint64 total_amount = 3;
  inline bool has_total_amount() const;
  inline void clear_total_amount();
  static const int kTotalAmountFieldNumber = 3;
  inline ::google::protobuf::uint64 total_amount() const;
  inline void set_total_amount(::google::protobuf::uint64 value);

  // repeated .com.mservice.momo.msg.Seat seat_list = 4;
  inline int seat_list_size() const;
  inline void clear_seat_list();
  static const int kSeatListFieldNumber = 4;
  inline const ::com::mservice::momo::msg::Seat& seat_list(int index) const;
  inline ::com::mservice::momo::msg::Seat* mutable_seat_list(int index);
  inline ::com::mservice::momo::msg::Seat* add_seat_list();
  inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::Seat >&
      seat_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::Seat >*
      mutable_seat_list();

  // optional uint32 rcode = 5;
  inline bool has_rcode() const;
  inline void clear_rcode();
  static const int kRcodeFieldNumber = 5;
  inline ::google::protobuf::uint32 rcode() const;
  inline void set_rcode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.CreateOrder123PhimReply)
 private:
  inline void set_has_invoice_no();
  inline void clear_has_invoice_no();
  inline void set_has_ticket_code();
  inline void clear_has_ticket_code();
  inline void set_has_total_amount();
  inline void clear_has_total_amount();
  inline void set_has_rcode();
  inline void clear_has_rcode();

  ::std::string* invoice_no_;
  ::std::string* ticket_code_;
  ::google::protobuf::uint64 total_amount_;
  ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::Seat > seat_list_;
  ::google::protobuf::uint32 rcode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static CreateOrder123PhimReply* default_instance_;
};
// -------------------------------------------------------------------

class StandardSync : public ::google::protobuf::MessageLite {
 public:
  StandardSync();
  virtual ~StandardSync();

  StandardSync(const StandardSync& from);

  inline StandardSync& operator=(const StandardSync& from) {
    CopyFrom(from);
    return *this;
  }

  static const StandardSync& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StandardSync* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StandardSync* other);

  // implements Message ----------------------------------------------

  StandardSync* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StandardSync& from);
  void MergeFrom(const StandardSync& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 last_update_time = 1;
  inline bool has_last_update_time() const;
  inline void clear_last_update_time();
  static const int kLastUpdateTimeFieldNumber = 1;
  inline ::google::protobuf::uint64 last_update_time() const;
  inline void set_last_update_time(::google::protobuf::uint64 value);

  // optional uint64 target_time = 2;
  inline bool has_target_time() const;
  inline void clear_target_time();
  static const int kTargetTimeFieldNumber = 2;
  inline ::google::protobuf::uint64 target_time() const;
  inline void set_target_time(::google::protobuf::uint64 value);

  // optional uint64 batch_size = 3;
  inline bool has_batch_size() const;
  inline void clear_batch_size();
  static const int kBatchSizeFieldNumber = 3;
  inline ::google::protobuf::uint64 batch_size() const;
  inline void set_batch_size(::google::protobuf::uint64 value);

  // optional uint64 batch_direction = 4;
  inline bool has_batch_direction() const;
  inline void clear_batch_direction();
  static const int kBatchDirectionFieldNumber = 4;
  inline ::google::protobuf::uint64 batch_direction() const;
  inline void set_batch_direction(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.StandardSync)
 private:
  inline void set_has_last_update_time();
  inline void clear_has_last_update_time();
  inline void set_has_target_time();
  inline void clear_has_target_time();
  inline void set_has_batch_size();
  inline void clear_has_batch_size();
  inline void set_has_batch_direction();
  inline void clear_has_batch_direction();

  ::google::protobuf::uint64 last_update_time_;
  ::google::protobuf::uint64 target_time_;
  ::google::protobuf::uint64 batch_size_;
  ::google::protobuf::uint64 batch_direction_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static StandardSync* default_instance_;
};
// -------------------------------------------------------------------

class StandardReply : public ::google::protobuf::MessageLite {
 public:
  StandardReply();
  virtual ~StandardReply();

  StandardReply(const StandardReply& from);

  inline StandardReply& operator=(const StandardReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const StandardReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StandardReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StandardReply* other);

  // implements Message ----------------------------------------------

  StandardReply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StandardReply& from);
  void MergeFrom(const StandardReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline bool result() const;
  inline void set_result(bool value);

  // optional string desc = 2;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 2;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  inline void set_allocated_desc(::std::string* desc);

  // optional uint32 rcode = 3;
  inline bool has_rcode() const;
  inline void clear_rcode();
  static const int kRcodeFieldNumber = 3;
  inline ::google::protobuf::uint32 rcode() const;
  inline void set_rcode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.StandardReply)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_desc();
  inline void clear_has_desc();
  inline void set_has_rcode();
  inline void clear_has_rcode();

  ::std::string* desc_;
  bool result_;
  ::google::protobuf::uint32 rcode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static StandardReply* default_instance_;
};
// -------------------------------------------------------------------

class BanketVerifyOtp : public ::google::protobuf::MessageLite {
 public:
  BanketVerifyOtp();
  virtual ~BanketVerifyOtp();

  BanketVerifyOtp(const BanketVerifyOtp& from);

  inline BanketVerifyOtp& operator=(const BanketVerifyOtp& from) {
    CopyFrom(from);
    return *this;
  }

  static const BanketVerifyOtp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BanketVerifyOtp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BanketVerifyOtp* other);

  // implements Message ----------------------------------------------

  BanketVerifyOtp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BanketVerifyOtp& from);
  void MergeFrom(const BanketVerifyOtp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string merchant_trans_id = 1;
  inline bool has_merchant_trans_id() const;
  inline void clear_merchant_trans_id();
  static const int kMerchantTransIdFieldNumber = 1;
  inline const ::std::string& merchant_trans_id() const;
  inline void set_merchant_trans_id(const ::std::string& value);
  inline void set_merchant_trans_id(const char* value);
  inline void set_merchant_trans_id(const char* value, size_t size);
  inline ::std::string* mutable_merchant_trans_id();
  inline ::std::string* release_merchant_trans_id();
  inline void set_allocated_merchant_trans_id(::std::string* merchant_trans_id);

  // optional string trans_id = 2;
  inline bool has_trans_id() const;
  inline void clear_trans_id();
  static const int kTransIdFieldNumber = 2;
  inline const ::std::string& trans_id() const;
  inline void set_trans_id(const ::std::string& value);
  inline void set_trans_id(const char* value);
  inline void set_trans_id(const char* value, size_t size);
  inline ::std::string* mutable_trans_id();
  inline ::std::string* release_trans_id();
  inline void set_allocated_trans_id(::std::string* trans_id);

  // optional uint64 full_amount = 3;
  inline bool has_full_amount() const;
  inline void clear_full_amount();
  static const int kFullAmountFieldNumber = 3;
  inline ::google::protobuf::uint64 full_amount() const;
  inline void set_full_amount(::google::protobuf::uint64 value);

  // optional string otp = 4;
  inline bool has_otp() const;
  inline void clear_otp();
  static const int kOtpFieldNumber = 4;
  inline const ::std::string& otp() const;
  inline void set_otp(const ::std::string& value);
  inline void set_otp(const char* value);
  inline void set_otp(const char* value, size_t size);
  inline ::std::string* mutable_otp();
  inline ::std::string* release_otp();
  inline void set_allocated_otp(::std::string* otp);

  // optional uint64 fee_amount = 5;
  inline bool has_fee_amount() const;
  inline void clear_fee_amount();
  static const int kFeeAmountFieldNumber = 5;
  inline ::google::protobuf::uint64 fee_amount() const;
  inline void set_fee_amount(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.BanketVerifyOtp)
 private:
  inline void set_has_merchant_trans_id();
  inline void clear_has_merchant_trans_id();
  inline void set_has_trans_id();
  inline void clear_has_trans_id();
  inline void set_has_full_amount();
  inline void clear_has_full_amount();
  inline void set_has_otp();
  inline void clear_has_otp();
  inline void set_has_fee_amount();
  inline void clear_has_fee_amount();

  ::std::string* merchant_trans_id_;
  ::std::string* trans_id_;
  ::google::protobuf::uint64 full_amount_;
  ::std::string* otp_;
  ::google::protobuf::uint64 fee_amount_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static BanketVerifyOtp* default_instance_;
};
// -------------------------------------------------------------------

class IdList : public ::google::protobuf::MessageLite {
 public:
  IdList();
  virtual ~IdList();

  IdList(const IdList& from);

  inline IdList& operator=(const IdList& from) {
    CopyFrom(from);
    return *this;
  }

  static const IdList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IdList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IdList* other);

  // implements Message ----------------------------------------------

  IdList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IdList& from);
  void MergeFrom(const IdList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 ids = 1;
  inline int ids_size() const;
  inline void clear_ids();
  static const int kIdsFieldNumber = 1;
  inline ::google::protobuf::uint64 ids(int index) const;
  inline void set_ids(int index, ::google::protobuf::uint64 value);
  inline void add_ids(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      ids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_ids();

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.IdList)
 private:

  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > ids_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static IdList* default_instance_;
};
// -------------------------------------------------------------------

class BankOfBanknet : public ::google::protobuf::MessageLite {
 public:
  BankOfBanknet();
  virtual ~BankOfBanknet();

  BankOfBanknet(const BankOfBanknet& from);

  inline BankOfBanknet& operator=(const BankOfBanknet& from) {
    CopyFrom(from);
    return *this;
  }

  static const BankOfBanknet& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BankOfBanknet* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BankOfBanknet* other);

  // implements Message ----------------------------------------------

  BankOfBanknet* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BankOfBanknet& from);
  void MergeFrom(const BankOfBanknet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string bank_id = 1;
  inline int bank_id_size() const;
  inline void clear_bank_id();
  static const int kBankIdFieldNumber = 1;
  inline const ::std::string& bank_id(int index) const;
  inline ::std::string* mutable_bank_id(int index);
  inline void set_bank_id(int index, const ::std::string& value);
  inline void set_bank_id(int index, const char* value);
  inline void set_bank_id(int index, const char* value, size_t size);
  inline ::std::string* add_bank_id();
  inline void add_bank_id(const ::std::string& value);
  inline void add_bank_id(const char* value);
  inline void add_bank_id(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& bank_id() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_bank_id();

  // repeated string bank_name = 2;
  inline int bank_name_size() const;
  inline void clear_bank_name();
  static const int kBankNameFieldNumber = 2;
  inline const ::std::string& bank_name(int index) const;
  inline ::std::string* mutable_bank_name(int index);
  inline void set_bank_name(int index, const ::std::string& value);
  inline void set_bank_name(int index, const char* value);
  inline void set_bank_name(int index, const char* value, size_t size);
  inline ::std::string* add_bank_name();
  inline void add_bank_name(const ::std::string& value);
  inline void add_bank_name(const char* value);
  inline void add_bank_name(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& bank_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_bank_name();

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.BankOfBanknet)
 private:

  ::google::protobuf::RepeatedPtrField< ::std::string> bank_id_;
  ::google::protobuf::RepeatedPtrField< ::std::string> bank_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static BankOfBanknet* default_instance_;
};
// -------------------------------------------------------------------

class TranStatisticPerDayReply : public ::google::protobuf::MessageLite {
 public:
  TranStatisticPerDayReply();
  virtual ~TranStatisticPerDayReply();

  TranStatisticPerDayReply(const TranStatisticPerDayReply& from);

  inline TranStatisticPerDayReply& operator=(const TranStatisticPerDayReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const TranStatisticPerDayReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TranStatisticPerDayReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TranStatisticPerDayReply* other);

  // implements Message ----------------------------------------------

  TranStatisticPerDayReply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TranStatisticPerDayReply& from);
  void MergeFrom(const TranStatisticPerDayReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 total_count = 1;
  inline bool has_total_count() const;
  inline void clear_total_count();
  static const int kTotalCountFieldNumber = 1;
  inline ::google::protobuf::uint32 total_count() const;
  inline void set_total_count(::google::protobuf::uint32 value);

  // optional uint32 remain_count = 2;
  inline bool has_remain_count() const;
  inline void clear_remain_count();
  static const int kRemainCountFieldNumber = 2;
  inline ::google::protobuf::uint32 remain_count() const;
  inline void set_remain_count(::google::protobuf::uint32 value);

  // optional uint64 total_amount = 3;
  inline bool has_total_amount() const;
  inline void clear_total_amount();
  static const int kTotalAmountFieldNumber = 3;
  inline ::google::protobuf::uint64 total_amount() const;
  inline void set_total_amount(::google::protobuf::uint64 value);

  // optional uint64 max_amount = 4;
  inline bool has_max_amount() const;
  inline void clear_max_amount();
  static const int kMaxAmountFieldNumber = 4;
  inline ::google::protobuf::uint64 max_amount() const;
  inline void set_max_amount(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.TranStatisticPerDayReply)
 private:
  inline void set_has_total_count();
  inline void clear_has_total_count();
  inline void set_has_remain_count();
  inline void clear_has_remain_count();
  inline void set_has_total_amount();
  inline void clear_has_total_amount();
  inline void set_has_max_amount();
  inline void clear_has_max_amount();

  ::google::protobuf::uint32 total_count_;
  ::google::protobuf::uint32 remain_count_;
  ::google::protobuf::uint64 total_amount_;
  ::google::protobuf::uint64 max_amount_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static TranStatisticPerDayReply* default_instance_;
};
// -------------------------------------------------------------------

class GetFee : public ::google::protobuf::MessageLite {
 public:
  GetFee();
  virtual ~GetFee();

  GetFee(const GetFee& from);

  inline GetFee& operator=(const GetFee& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetFee& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetFee* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetFee* other);

  // implements Message ----------------------------------------------

  GetFee* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetFee& from);
  void MergeFrom(const GetFee& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string bank_id = 1;
  inline bool has_bank_id() const;
  inline void clear_bank_id();
  static const int kBankIdFieldNumber = 1;
  inline const ::std::string& bank_id() const;
  inline void set_bank_id(const ::std::string& value);
  inline void set_bank_id(const char* value);
  inline void set_bank_id(const char* value, size_t size);
  inline ::std::string* mutable_bank_id();
  inline ::std::string* release_bank_id();
  inline void set_allocated_bank_id(::std::string* bank_id);

  // optional uint32 tran_type = 2;
  inline bool has_tran_type() const;
  inline void clear_tran_type();
  static const int kTranTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 tran_type() const;
  inline void set_tran_type(::google::protobuf::uint32 value);

  // optional uint32 channel = 3;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 3;
  inline ::google::protobuf::uint32 channel() const;
  inline void set_channel(::google::protobuf::uint32 value);

  // optional uint32 io_city = 4;
  inline bool has_io_city() const;
  inline void clear_io_city();
  static const int kIoCityFieldNumber = 4;
  inline ::google::protobuf::uint32 io_city() const;
  inline void set_io_city(::google::protobuf::uint32 value);

  // optional uint64 amount = 5;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 5;
  inline ::google::protobuf::uint64 amount() const;
  inline void set_amount(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.GetFee)
 private:
  inline void set_has_bank_id();
  inline void clear_has_bank_id();
  inline void set_has_tran_type();
  inline void clear_has_tran_type();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_io_city();
  inline void clear_has_io_city();
  inline void set_has_amount();
  inline void clear_has_amount();

  ::std::string* bank_id_;
  ::google::protobuf::uint32 tran_type_;
  ::google::protobuf::uint32 channel_;
  ::google::protobuf::uint64 amount_;
  ::google::protobuf::uint32 io_city_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static GetFee* default_instance_;
};
// -------------------------------------------------------------------

class GetFeeReply : public ::google::protobuf::MessageLite {
 public:
  GetFeeReply();
  virtual ~GetFeeReply();

  GetFeeReply(const GetFeeReply& from);

  inline GetFeeReply& operator=(const GetFeeReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetFeeReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetFeeReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetFeeReply* other);

  // implements Message ----------------------------------------------

  GetFeeReply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetFeeReply& from);
  void MergeFrom(const GetFeeReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double dymanic_fee = 1;
  inline bool has_dymanic_fee() const;
  inline void clear_dymanic_fee();
  static const int kDymanicFeeFieldNumber = 1;
  inline double dymanic_fee() const;
  inline void set_dymanic_fee(double value);

  // optional uint32 static_fee = 2;
  inline bool has_static_fee() const;
  inline void clear_static_fee();
  static const int kStaticFeeFieldNumber = 2;
  inline ::google::protobuf::uint32 static_fee() const;
  inline void set_static_fee(::google::protobuf::uint32 value);

  // optional string bank_id = 3;
  inline bool has_bank_id() const;
  inline void clear_bank_id();
  static const int kBankIdFieldNumber = 3;
  inline const ::std::string& bank_id() const;
  inline void set_bank_id(const ::std::string& value);
  inline void set_bank_id(const char* value);
  inline void set_bank_id(const char* value, size_t size);
  inline ::std::string* mutable_bank_id();
  inline ::std::string* release_bank_id();
  inline void set_allocated_bank_id(::std::string* bank_id);

  // optional uint32 tran_type = 4;
  inline bool has_tran_type() const;
  inline void clear_tran_type();
  static const int kTranTypeFieldNumber = 4;
  inline ::google::protobuf::uint32 tran_type() const;
  inline void set_tran_type(::google::protobuf::uint32 value);

  // optional uint32 channel = 5;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 5;
  inline ::google::protobuf::uint32 channel() const;
  inline void set_channel(::google::protobuf::uint32 value);

  // optional uint32 io_city = 6;
  inline bool has_io_city() const;
  inline void clear_io_city();
  static const int kIoCityFieldNumber = 6;
  inline ::google::protobuf::uint32 io_city() const;
  inline void set_io_city(::google::protobuf::uint32 value);

  // optional uint32 fee_type = 7;
  inline bool has_fee_type() const;
  inline void clear_fee_type();
  static const int kFeeTypeFieldNumber = 7;
  inline ::google::protobuf::uint32 fee_type() const;
  inline void set_fee_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.GetFeeReply)
 private:
  inline void set_has_dymanic_fee();
  inline void clear_has_dymanic_fee();
  inline void set_has_static_fee();
  inline void clear_has_static_fee();
  inline void set_has_bank_id();
  inline void clear_has_bank_id();
  inline void set_has_tran_type();
  inline void clear_has_tran_type();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_io_city();
  inline void clear_has_io_city();
  inline void set_has_fee_type();
  inline void clear_has_fee_type();

  double dymanic_fee_;
  ::std::string* bank_id_;
  ::google::protobuf::uint32 static_fee_;
  ::google::protobuf::uint32 tran_type_;
  ::google::protobuf::uint32 channel_;
  ::google::protobuf::uint32 io_city_;
  ::google::protobuf::uint32 fee_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static GetFeeReply* default_instance_;
};
// -------------------------------------------------------------------

class NewUser : public ::google::protobuf::MessageLite {
 public:
  NewUser();
  virtual ~NewUser();

  NewUser(const NewUser& from);

  inline NewUser& operator=(const NewUser& from) {
    CopyFrom(from);
    return *this;
  }

  static const NewUser& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NewUser* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NewUser* other);

  // implements Message ----------------------------------------------

  NewUser* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NewUser& from);
  void MergeFrom(const NewUser& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 new_number = 1;
  inline bool has_new_number() const;
  inline void clear_new_number();
  static const int kNewNumberFieldNumber = 1;
  inline ::google::protobuf::uint32 new_number() const;
  inline void set_new_number(::google::protobuf::uint32 value);

  // optional uint64 time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline ::google::protobuf::uint64 time() const;
  inline void set_time(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.NewUser)
 private:
  inline void set_has_new_number();
  inline void clear_has_new_number();
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::uint64 time_;
  ::google::protobuf::uint32 new_number_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static NewUser* default_instance_;
};
// -------------------------------------------------------------------

class TicketInfo : public ::google::protobuf::MessageLite {
 public:
  TicketInfo();
  virtual ~TicketInfo();

  TicketInfo(const TicketInfo& from);

  inline TicketInfo& operator=(const TicketInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const TicketInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TicketInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TicketInfo* other);

  // implements Message ----------------------------------------------

  TicketInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TicketInfo& from);
  void MergeFrom(const TicketInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 rcode = 1;
  inline bool has_rcode() const;
  inline void clear_rcode();
  static const int kRcodeFieldNumber = 1;
  inline ::google::protobuf::uint32 rcode() const;
  inline void set_rcode(::google::protobuf::uint32 value);

  // optional string provider_id = 2;
  inline bool has_provider_id() const;
  inline void clear_provider_id();
  static const int kProviderIdFieldNumber = 2;
  inline const ::std::string& provider_id() const;
  inline void set_provider_id(const ::std::string& value);
  inline void set_provider_id(const char* value);
  inline void set_provider_id(const char* value, size_t size);
  inline ::std::string* mutable_provider_id();
  inline ::std::string* release_provider_id();
  inline void set_allocated_provider_id(::std::string* provider_id);

  // optional string bill_id = 3;
  inline bool has_bill_id() const;
  inline void clear_bill_id();
  static const int kBillIdFieldNumber = 3;
  inline const ::std::string& bill_id() const;
  inline void set_bill_id(const ::std::string& value);
  inline void set_bill_id(const char* value);
  inline void set_bill_id(const char* value, size_t size);
  inline ::std::string* mutable_bill_id();
  inline ::std::string* release_bill_id();
  inline void set_allocated_bill_id(::std::string* bill_id);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.TicketInfo)
 private:
  inline void set_has_rcode();
  inline void clear_has_rcode();
  inline void set_has_provider_id();
  inline void clear_has_provider_id();
  inline void set_has_bill_id();
  inline void clear_has_bill_id();

  ::std::string* provider_id_;
  ::std::string* bill_id_;
  ::google::protobuf::uint32 rcode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static TicketInfo* default_instance_;
};
// -------------------------------------------------------------------

class RegStatus : public ::google::protobuf::MessageLite {
 public:
  RegStatus();
  virtual ~RegStatus();

  RegStatus(const RegStatus& from);

  inline RegStatus& operator=(const RegStatus& from) {
    CopyFrom(from);
    return *this;
  }

  static const RegStatus& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RegStatus* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RegStatus* other);

  // implements Message ----------------------------------------------

  RegStatus* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RegStatus& from);
  void MergeFrom(const RegStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_setup = 1;
  inline bool has_is_setup() const;
  inline void clear_is_setup();
  static const int kIsSetupFieldNumber = 1;
  inline bool is_setup() const;
  inline void set_is_setup(bool value);

  // optional bool is_reged = 2;
  inline bool has_is_reged() const;
  inline void clear_is_reged();
  static const int kIsRegedFieldNumber = 2;
  inline bool is_reged() const;
  inline void set_is_reged(bool value);

  // optional bool is_active = 3;
  inline bool has_is_active() const;
  inline void clear_is_active();
  static const int kIsActiveFieldNumber = 3;
  inline bool is_active() const;
  inline void set_is_active(bool value);

  // optional bool is_named = 4;
  inline bool has_is_named() const;
  inline void clear_is_named();
  static const int kIsNamedFieldNumber = 4;
  inline bool is_named() const;
  inline void set_is_named(bool value);

  // optional bool is_frozen = 5;
  inline bool has_is_frozen() const;
  inline void clear_is_frozen();
  static const int kIsFrozenFieldNumber = 5;
  inline bool is_frozen() const;
  inline void set_is_frozen(bool value);

  // optional bool is_suppend = 6;
  inline bool has_is_suppend() const;
  inline void clear_is_suppend();
  static const int kIsSuppendFieldNumber = 6;
  inline bool is_suppend() const;
  inline void set_is_suppend(bool value);

  // optional bool is_stopped = 7;
  inline bool has_is_stopped() const;
  inline void clear_is_stopped();
  static const int kIsStoppedFieldNumber = 7;
  inline bool is_stopped() const;
  inline void set_is_stopped(bool value);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.RegStatus)
 private:
  inline void set_has_is_setup();
  inline void clear_has_is_setup();
  inline void set_has_is_reged();
  inline void clear_has_is_reged();
  inline void set_has_is_active();
  inline void clear_has_is_active();
  inline void set_has_is_named();
  inline void clear_has_is_named();
  inline void set_has_is_frozen();
  inline void clear_has_is_frozen();
  inline void set_has_is_suppend();
  inline void clear_has_is_suppend();
  inline void set_has_is_stopped();
  inline void clear_has_is_stopped();

  bool is_setup_;
  bool is_reged_;
  bool is_active_;
  bool is_named_;
  bool is_frozen_;
  bool is_suppend_;
  bool is_stopped_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static RegStatus* default_instance_;
};
// -------------------------------------------------------------------

class Hello : public ::google::protobuf::MessageLite {
 public:
  Hello();
  virtual ~Hello();

  Hello(const Hello& from);

  inline Hello& operator=(const Hello& from) {
    CopyFrom(from);
    return *this;
  }

  static const Hello& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Hello* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Hello* other);

  // implements Message ----------------------------------------------

  Hello* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Hello& from);
  void MergeFrom(const Hello& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string imei = 1;
  inline bool has_imei() const;
  inline void clear_imei();
  static const int kImeiFieldNumber = 1;
  inline const ::std::string& imei() const;
  inline void set_imei(const ::std::string& value);
  inline void set_imei(const char* value);
  inline void set_imei(const char* value, size_t size);
  inline ::std::string* mutable_imei();
  inline ::std::string* release_imei();
  inline void set_allocated_imei(::std::string* imei);

  // optional string imei_key = 2;
  inline bool has_imei_key() const;
  inline void clear_imei_key();
  static const int kImeiKeyFieldNumber = 2;
  inline const ::std::string& imei_key() const;
  inline void set_imei_key(const ::std::string& value);
  inline void set_imei_key(const char* value);
  inline void set_imei_key(const char* value, size_t size);
  inline ::std::string* mutable_imei_key();
  inline ::std::string* release_imei_key();
  inline void set_allocated_imei_key(::std::string* imei_key);

  // optional string session_key = 3;
  inline bool has_session_key() const;
  inline void clear_session_key();
  static const int kSessionKeyFieldNumber = 3;
  inline const ::std::string& session_key() const;
  inline void set_session_key(const ::std::string& value);
  inline void set_session_key(const char* value);
  inline void set_session_key(const char* value, size_t size);
  inline ::std::string* mutable_session_key();
  inline ::std::string* release_session_key();
  inline void set_allocated_session_key(::std::string* session_key);

  // optional string device_os = 4;
  inline bool has_device_os() const;
  inline void clear_device_os();
  static const int kDeviceOsFieldNumber = 4;
  inline const ::std::string& device_os() const;
  inline void set_device_os(const ::std::string& value);
  inline void set_device_os(const char* value);
  inline void set_device_os(const char* value, size_t size);
  inline ::std::string* mutable_device_os();
  inline ::std::string* release_device_os();
  inline void set_allocated_device_os(::std::string* device_os);

  // optional string device_key = 5;
  inline bool has_device_key() const;
  inline void clear_device_key();
  static const int kDeviceKeyFieldNumber = 5;
  inline const ::std::string& device_key() const;
  inline void set_device_key(const ::std::string& value);
  inline void set_device_key(const char* value);
  inline void set_device_key(const char* value, size_t size);
  inline ::std::string* mutable_device_key();
  inline ::std::string* release_device_key();
  inline void set_allocated_device_key(::std::string* device_key);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.Hello)
 private:
  inline void set_has_imei();
  inline void clear_has_imei();
  inline void set_has_imei_key();
  inline void clear_has_imei_key();
  inline void set_has_session_key();
  inline void clear_has_session_key();
  inline void set_has_device_os();
  inline void clear_has_device_os();
  inline void set_has_device_key();
  inline void clear_has_device_key();

  ::std::string* imei_;
  ::std::string* imei_key_;
  ::std::string* session_key_;
  ::std::string* device_os_;
  ::std::string* device_key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static Hello* default_instance_;
};
// -------------------------------------------------------------------

class HelloReply : public ::google::protobuf::MessageLite {
 public:
  HelloReply();
  virtual ~HelloReply();

  HelloReply(const HelloReply& from);

  inline HelloReply& operator=(const HelloReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const HelloReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const HelloReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(HelloReply* other);

  // implements Message ----------------------------------------------

  HelloReply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const HelloReply& from);
  void MergeFrom(const HelloReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef HelloReply_ResultCode ResultCode;
  static const ResultCode ALL_OK = HelloReply_ResultCode_ALL_OK;
  static const ResultCode PHONE_NOT_CORRECT = HelloReply_ResultCode_PHONE_NOT_CORRECT;
  static const ResultCode LOG_ON = HelloReply_ResultCode_LOG_ON;
  static const ResultCode LOG_ON_ANOTHER_DEVICE = HelloReply_ResultCode_LOG_ON_ANOTHER_DEVICE;
  static const ResultCode NOT_LOG_ON = HelloReply_ResultCode_NOT_LOG_ON;
  static inline bool ResultCode_IsValid(int value) {
    return HelloReply_ResultCode_IsValid(value);
  }
  static const ResultCode ResultCode_MIN =
    HelloReply_ResultCode_ResultCode_MIN;
  static const ResultCode ResultCode_MAX =
    HelloReply_ResultCode_ResultCode_MAX;
  static const int ResultCode_ARRAYSIZE =
    HelloReply_ResultCode_ResultCode_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional uint32 rcode = 1;
  inline bool has_rcode() const;
  inline void clear_rcode();
  static const int kRcodeFieldNumber = 1;
  inline ::google::protobuf::uint32 rcode() const;
  inline void set_rcode(::google::protobuf::uint32 value);

  // optional string rdesc = 2;
  inline bool has_rdesc() const;
  inline void clear_rdesc();
  static const int kRdescFieldNumber = 2;
  inline const ::std::string& rdesc() const;
  inline void set_rdesc(const ::std::string& value);
  inline void set_rdesc(const char* value);
  inline void set_rdesc(const char* value, size_t size);
  inline ::std::string* mutable_rdesc();
  inline ::std::string* release_rdesc();
  inline void set_allocated_rdesc(::std::string* rdesc);

  // optional uint32 version_code = 3;
  inline bool has_version_code() const;
  inline void clear_version_code();
  static const int kVersionCodeFieldNumber = 3;
  inline ::google::protobuf::uint32 version_code() const;
  inline void set_version_code(::google::protobuf::uint32 value);

  // optional string version_name = 4;
  inline bool has_version_name() const;
  inline void clear_version_name();
  static const int kVersionNameFieldNumber = 4;
  inline const ::std::string& version_name() const;
  inline void set_version_name(const ::std::string& value);
  inline void set_version_name(const char* value);
  inline void set_version_name(const char* value, size_t size);
  inline ::std::string* mutable_version_name();
  inline ::std::string* release_version_name();
  inline void set_allocated_version_name(::std::string* version_name);

  // optional .com.mservice.momo.msg.RegStatus reg_status = 5;
  inline bool has_reg_status() const;
  inline void clear_reg_status();
  static const int kRegStatusFieldNumber = 5;
  inline const ::com::mservice::momo::msg::RegStatus& reg_status() const;
  inline ::com::mservice::momo::msg::RegStatus* mutable_reg_status();
  inline ::com::mservice::momo::msg::RegStatus* release_reg_status();
  inline void set_allocated_reg_status(::com::mservice::momo::msg::RegStatus* reg_status);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.HelloReply)
 private:
  inline void set_has_rcode();
  inline void clear_has_rcode();
  inline void set_has_rdesc();
  inline void clear_has_rdesc();
  inline void set_has_version_code();
  inline void clear_has_version_code();
  inline void set_has_version_name();
  inline void clear_has_version_name();
  inline void set_has_reg_status();
  inline void clear_has_reg_status();

  ::std::string* rdesc_;
  ::google::protobuf::uint32 rcode_;
  ::google::protobuf::uint32 version_code_;
  ::std::string* version_name_;
  ::com::mservice::momo::msg::RegStatus* reg_status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static HelloReply* default_instance_;
};
// -------------------------------------------------------------------

class VerifyOtp : public ::google::protobuf::MessageLite {
 public:
  VerifyOtp();
  virtual ~VerifyOtp();

  VerifyOtp(const VerifyOtp& from);

  inline VerifyOtp& operator=(const VerifyOtp& from) {
    CopyFrom(from);
    return *this;
  }

  static const VerifyOtp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const VerifyOtp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(VerifyOtp* other);

  // implements Message ----------------------------------------------

  VerifyOtp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const VerifyOtp& from);
  void MergeFrom(const VerifyOtp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string otp = 1;
  inline bool has_otp() const;
  inline void clear_otp();
  static const int kOtpFieldNumber = 1;
  inline const ::std::string& otp() const;
  inline void set_otp(const ::std::string& value);
  inline void set_otp(const char* value);
  inline void set_otp(const char* value, size_t size);
  inline ::std::string* mutable_otp();
  inline ::std::string* release_otp();
  inline void set_allocated_otp(::std::string* otp);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.VerifyOtp)
 private:
  inline void set_has_otp();
  inline void clear_has_otp();

  ::std::string* otp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static VerifyOtp* default_instance_;
};
// -------------------------------------------------------------------

class VerifyOtpReply : public ::google::protobuf::MessageLite {
 public:
  VerifyOtpReply();
  virtual ~VerifyOtpReply();

  VerifyOtpReply(const VerifyOtpReply& from);

  inline VerifyOtpReply& operator=(const VerifyOtpReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const VerifyOtpReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const VerifyOtpReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(VerifyOtpReply* other);

  // implements Message ----------------------------------------------

  VerifyOtpReply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const VerifyOtpReply& from);
  void MergeFrom(const VerifyOtpReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef VerifyOtpReply_ResultCode ResultCode;
  static const ResultCode ALL_OK = VerifyOtpReply_ResultCode_ALL_OK;
  static const ResultCode WRONG_OTP = VerifyOtpReply_ResultCode_WRONG_OTP;
  static const ResultCode TIME_OUT = VerifyOtpReply_ResultCode_TIME_OUT;
  static inline bool ResultCode_IsValid(int value) {
    return VerifyOtpReply_ResultCode_IsValid(value);
  }
  static const ResultCode ResultCode_MIN =
    VerifyOtpReply_ResultCode_ResultCode_MIN;
  static const ResultCode ResultCode_MAX =
    VerifyOtpReply_ResultCode_ResultCode_MAX;
  static const int ResultCode_ARRAYSIZE =
    VerifyOtpReply_ResultCode_ResultCode_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional bool result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline bool result() const;
  inline void set_result(bool value);

  // optional uint32 rcode = 2;
  inline bool has_rcode() const;
  inline void clear_rcode();
  static const int kRcodeFieldNumber = 2;
  inline ::google::protobuf::uint32 rcode() const;
  inline void set_rcode(::google::protobuf::uint32 value);

  // optional string imei_key = 3;
  inline bool has_imei_key() const;
  inline void clear_imei_key();
  static const int kImeiKeyFieldNumber = 3;
  inline const ::std::string& imei_key() const;
  inline void set_imei_key(const ::std::string& value);
  inline void set_imei_key(const char* value);
  inline void set_imei_key(const char* value, size_t size);
  inline ::std::string* mutable_imei_key();
  inline ::std::string* release_imei_key();
  inline void set_allocated_imei_key(::std::string* imei_key);

  // optional .com.mservice.momo.msg.RegStatus reg_status = 4;
  inline bool has_reg_status() const;
  inline void clear_reg_status();
  static const int kRegStatusFieldNumber = 4;
  inline const ::com::mservice::momo::msg::RegStatus& reg_status() const;
  inline ::com::mservice::momo::msg::RegStatus* mutable_reg_status();
  inline ::com::mservice::momo::msg::RegStatus* release_reg_status();
  inline void set_allocated_reg_status(::com::mservice::momo::msg::RegStatus* reg_status);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.VerifyOtpReply)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_rcode();
  inline void clear_has_rcode();
  inline void set_has_imei_key();
  inline void clear_has_imei_key();
  inline void set_has_reg_status();
  inline void clear_has_reg_status();

  bool result_;
  ::google::protobuf::uint32 rcode_;
  ::std::string* imei_key_;
  ::com::mservice::momo::msg::RegStatus* reg_status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static VerifyOtpReply* default_instance_;
};
// -------------------------------------------------------------------

class Register : public ::google::protobuf::MessageLite {
 public:
  Register();
  virtual ~Register();

  Register(const Register& from);

  inline Register& operator=(const Register& from) {
    CopyFrom(from);
    return *this;
  }

  static const Register& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Register* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Register* other);

  // implements Message ----------------------------------------------

  Register* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Register& from);
  void MergeFrom(const Register& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string card_id = 2;
  inline bool has_card_id() const;
  inline void clear_card_id();
  static const int kCardIdFieldNumber = 2;
  inline const ::std::string& card_id() const;
  inline void set_card_id(const ::std::string& value);
  inline void set_card_id(const char* value);
  inline void set_card_id(const char* value, size_t size);
  inline ::std::string* mutable_card_id();
  inline ::std::string* release_card_id();
  inline void set_allocated_card_id(::std::string* card_id);

  // optional string address = 3;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 3;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const char* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // optional string dob = 4;
  inline bool has_dob() const;
  inline void clear_dob();
  static const int kDobFieldNumber = 4;
  inline const ::std::string& dob() const;
  inline void set_dob(const ::std::string& value);
  inline void set_dob(const char* value);
  inline void set_dob(const char* value, size_t size);
  inline ::std::string* mutable_dob();
  inline ::std::string* release_dob();
  inline void set_allocated_dob(::std::string* dob);

  // optional string pin = 5;
  inline bool has_pin() const;
  inline void clear_pin();
  static const int kPinFieldNumber = 5;
  inline const ::std::string& pin() const;
  inline void set_pin(const ::std::string& value);
  inline void set_pin(const char* value);
  inline void set_pin(const char* value, size_t size);
  inline ::std::string* mutable_pin();
  inline ::std::string* release_pin();
  inline void set_allocated_pin(::std::string* pin);

  // optional string email = 6;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 6;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // optional string question = 7;
  inline bool has_question() const;
  inline void clear_question();
  static const int kQuestionFieldNumber = 7;
  inline const ::std::string& question() const;
  inline void set_question(const ::std::string& value);
  inline void set_question(const char* value);
  inline void set_question(const char* value, size_t size);
  inline ::std::string* mutable_question();
  inline ::std::string* release_question();
  inline void set_allocated_question(::std::string* question);

  // optional string answer = 8;
  inline bool has_answer() const;
  inline void clear_answer();
  static const int kAnswerFieldNumber = 8;
  inline const ::std::string& answer() const;
  inline void set_answer(const ::std::string& value);
  inline void set_answer(const char* value);
  inline void set_answer(const char* value, size_t size);
  inline ::std::string* mutable_answer();
  inline ::std::string* release_answer();
  inline void set_allocated_answer(::std::string* answer);

  // optional string reference = 9;
  inline bool has_reference() const;
  inline void clear_reference();
  static const int kReferenceFieldNumber = 9;
  inline const ::std::string& reference() const;
  inline void set_reference(const ::std::string& value);
  inline void set_reference(const char* value);
  inline void set_reference(const char* value, size_t size);
  inline ::std::string* mutable_reference();
  inline ::std::string* release_reference();
  inline void set_allocated_reference(::std::string* reference);

  // repeated .com.mservice.momo.msg.TextValue keyValue = 10;
  inline int keyvalue_size() const;
  inline void clear_keyvalue();
  static const int kKeyValueFieldNumber = 10;
  inline const ::com::mservice::momo::msg::TextValue& keyvalue(int index) const;
  inline ::com::mservice::momo::msg::TextValue* mutable_keyvalue(int index);
  inline ::com::mservice::momo::msg::TextValue* add_keyvalue();
  inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::TextValue >&
      keyvalue() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::TextValue >*
      mutable_keyvalue();

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.Register)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_card_id();
  inline void clear_has_card_id();
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_dob();
  inline void clear_has_dob();
  inline void set_has_pin();
  inline void clear_has_pin();
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_question();
  inline void clear_has_question();
  inline void set_has_answer();
  inline void clear_has_answer();
  inline void set_has_reference();
  inline void clear_has_reference();

  ::std::string* name_;
  ::std::string* card_id_;
  ::std::string* address_;
  ::std::string* dob_;
  ::std::string* pin_;
  ::std::string* email_;
  ::std::string* question_;
  ::std::string* answer_;
  ::std::string* reference_;
  ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::TextValue > keyvalue_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static Register* default_instance_;
};
// -------------------------------------------------------------------

class LogIn : public ::google::protobuf::MessageLite {
 public:
  LogIn();
  virtual ~LogIn();

  LogIn(const LogIn& from);

  inline LogIn& operator=(const LogIn& from) {
    CopyFrom(from);
    return *this;
  }

  static const LogIn& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LogIn* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LogIn* other);

  // implements Message ----------------------------------------------

  LogIn* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LogIn& from);
  void MergeFrom(const LogIn& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string mpin = 1;
  inline bool has_mpin() const;
  inline void clear_mpin();
  static const int kMpinFieldNumber = 1;
  inline const ::std::string& mpin() const;
  inline void set_mpin(const ::std::string& value);
  inline void set_mpin(const char* value);
  inline void set_mpin(const char* value, size_t size);
  inline ::std::string* mutable_mpin();
  inline ::std::string* release_mpin();
  inline void set_allocated_mpin(::std::string* mpin);

  // optional string device_model = 2;
  inline bool has_device_model() const;
  inline void clear_device_model();
  static const int kDeviceModelFieldNumber = 2;
  inline const ::std::string& device_model() const;
  inline void set_device_model(const ::std::string& value);
  inline void set_device_model(const char* value);
  inline void set_device_model(const char* value, size_t size);
  inline ::std::string* mutable_device_model();
  inline ::std::string* release_device_model();
  inline void set_allocated_device_model(::std::string* device_model);

  // optional string agent_type = 3;
  inline bool has_agent_type() const;
  inline void clear_agent_type();
  static const int kAgentTypeFieldNumber = 3;
  inline const ::std::string& agent_type() const;
  inline void set_agent_type(const ::std::string& value);
  inline void set_agent_type(const char* value);
  inline void set_agent_type(const char* value, size_t size);
  inline ::std::string* mutable_agent_type();
  inline ::std::string* release_agent_type();
  inline void set_allocated_agent_type(::std::string* agent_type);

  // optional string appVer = 4;
  inline bool has_appver() const;
  inline void clear_appver();
  static const int kAppVerFieldNumber = 4;
  inline const ::std::string& appver() const;
  inline void set_appver(const ::std::string& value);
  inline void set_appver(const char* value);
  inline void set_appver(const char* value, size_t size);
  inline ::std::string* mutable_appver();
  inline ::std::string* release_appver();
  inline void set_allocated_appver(::std::string* appver);

  // optional string codeVer = 5;
  inline bool has_codever() const;
  inline void clear_codever();
  static const int kCodeVerFieldNumber = 5;
  inline const ::std::string& codever() const;
  inline void set_codever(const ::std::string& value);
  inline void set_codever(const char* value);
  inline void set_codever(const char* value, size_t size);
  inline ::std::string* mutable_codever();
  inline ::std::string* release_codever();
  inline void set_allocated_codever(::std::string* codever);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.LogIn)
 private:
  inline void set_has_mpin();
  inline void clear_has_mpin();
  inline void set_has_device_model();
  inline void clear_has_device_model();
  inline void set_has_agent_type();
  inline void clear_has_agent_type();
  inline void set_has_appver();
  inline void clear_has_appver();
  inline void set_has_codever();
  inline void clear_has_codever();

  ::std::string* mpin_;
  ::std::string* device_model_;
  ::std::string* agent_type_;
  ::std::string* appver_;
  ::std::string* codever_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static LogIn* default_instance_;
};
// -------------------------------------------------------------------

class LogInReply : public ::google::protobuf::MessageLite {
 public:
  LogInReply();
  virtual ~LogInReply();

  LogInReply(const LogInReply& from);

  inline LogInReply& operator=(const LogInReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const LogInReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LogInReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LogInReply* other);

  // implements Message ----------------------------------------------

  LogInReply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LogInReply& from);
  void MergeFrom(const LogInReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef LogInReply_ResultCode ResultCode;
  static const ResultCode ALL_OK = LogInReply_ResultCode_ALL_OK;
  static const ResultCode PIN_INVALID = LogInReply_ResultCode_PIN_INVALID;
  static const ResultCode SYSTEM_ERROR = LogInReply_ResultCode_SYSTEM_ERROR;
  static const ResultCode AUTH_RETRY_EXCEED = LogInReply_ResultCode_AUTH_RETRY_EXCEED;
  static const ResultCode AUTH_EXPIRED = LogInReply_ResultCode_AUTH_EXPIRED;
  static const ResultCode NOT_SETUP = LogInReply_ResultCode_NOT_SETUP;
  static const ResultCode TEMP_LOCK = LogInReply_ResultCode_TEMP_LOCK;
  static const ResultCode AGENT_NOT_FOUND = LogInReply_ResultCode_AGENT_NOT_FOUND;
  static const ResultCode AGENT_CANCELLED = LogInReply_ResultCode_AGENT_CANCELLED;
  static inline bool ResultCode_IsValid(int value) {
    return LogInReply_ResultCode_IsValid(value);
  }
  static const ResultCode ResultCode_MIN =
    LogInReply_ResultCode_ResultCode_MIN;
  static const ResultCode ResultCode_MAX =
    LogInReply_ResultCode_ResultCode_MAX;
  static const int ResultCode_ARRAYSIZE =
    LogInReply_ResultCode_ResultCode_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional bool result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline bool result() const;
  inline void set_result(bool value);

  // optional uint32 rcode = 2;
  inline bool has_rcode() const;
  inline void clear_rcode();
  static const int kRcodeFieldNumber = 2;
  inline ::google::protobuf::uint32 rcode() const;
  inline void set_rcode(::google::protobuf::uint32 value);

  // optional string skey = 3;
  inline bool has_skey() const;
  inline void clear_skey();
  static const int kSkeyFieldNumber = 3;
  inline const ::std::string& skey() const;
  inline void set_skey(const ::std::string& value);
  inline void set_skey(const char* value);
  inline void set_skey(const char* value, size_t size);
  inline ::std::string* mutable_skey();
  inline ::std::string* release_skey();
  inline void set_allocated_skey(::std::string* skey);

  // optional uint64 time = 4;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 4;
  inline ::google::protobuf::uint64 time() const;
  inline void set_time(::google::protobuf::uint64 value);

  // optional uint32 login_remain_count = 5;
  inline bool has_login_remain_count() const;
  inline void clear_login_remain_count();
  static const int kLoginRemainCountFieldNumber = 5;
  inline ::google::protobuf::uint32 login_remain_count() const;
  inline void set_login_remain_count(::google::protobuf::uint32 value);

  // optional uint64 locked_until = 6;
  inline bool has_locked_until() const;
  inline void clear_locked_until();
  static const int kLockedUntilFieldNumber = 6;
  inline ::google::protobuf::uint64 locked_until() const;
  inline void set_locked_until(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.LogInReply)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_rcode();
  inline void clear_has_rcode();
  inline void set_has_skey();
  inline void clear_has_skey();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_login_remain_count();
  inline void clear_has_login_remain_count();
  inline void set_has_locked_until();
  inline void clear_has_locked_until();

  bool result_;
  ::google::protobuf::uint32 rcode_;
  ::std::string* skey_;
  ::google::protobuf::uint64 time_;
  ::google::protobuf::uint64 locked_until_;
  ::google::protobuf::uint32 login_remain_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static LogInReply* default_instance_;
};
// -------------------------------------------------------------------

class GetBillInfo : public ::google::protobuf::MessageLite {
 public:
  GetBillInfo();
  virtual ~GetBillInfo();

  GetBillInfo(const GetBillInfo& from);

  inline GetBillInfo& operator=(const GetBillInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetBillInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetBillInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetBillInfo* other);

  // implements Message ----------------------------------------------

  GetBillInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetBillInfo& from);
  void MergeFrom(const GetBillInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string provider_id = 1;
  inline bool has_provider_id() const;
  inline void clear_provider_id();
  static const int kProviderIdFieldNumber = 1;
  inline const ::std::string& provider_id() const;
  inline void set_provider_id(const ::std::string& value);
  inline void set_provider_id(const char* value);
  inline void set_provider_id(const char* value, size_t size);
  inline ::std::string* mutable_provider_id();
  inline ::std::string* release_provider_id();
  inline void set_allocated_provider_id(::std::string* provider_id);

  // optional string bill_id = 2;
  inline bool has_bill_id() const;
  inline void clear_bill_id();
  static const int kBillIdFieldNumber = 2;
  inline const ::std::string& bill_id() const;
  inline void set_bill_id(const ::std::string& value);
  inline void set_bill_id(const char* value);
  inline void set_bill_id(const char* value, size_t size);
  inline ::std::string* mutable_bill_id();
  inline ::std::string* release_bill_id();
  inline void set_allocated_bill_id(::std::string* bill_id);

  // optional int32 getBillInfoAction = 3;
  inline bool has_getbillinfoaction() const;
  inline void clear_getbillinfoaction();
  static const int kGetBillInfoActionFieldNumber = 3;
  inline ::google::protobuf::int32 getbillinfoaction() const;
  inline void set_getbillinfoaction(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.GetBillInfo)
 private:
  inline void set_has_provider_id();
  inline void clear_has_provider_id();
  inline void set_has_bill_id();
  inline void clear_has_bill_id();
  inline void set_has_getbillinfoaction();
  inline void clear_has_getbillinfoaction();

  ::std::string* provider_id_;
  ::std::string* bill_id_;
  ::google::protobuf::int32 getbillinfoaction_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static GetBillInfo* default_instance_;
};
// -------------------------------------------------------------------

class BillDetail : public ::google::protobuf::MessageLite {
 public:
  BillDetail();
  virtual ~BillDetail();

  BillDetail(const BillDetail& from);

  inline BillDetail& operator=(const BillDetail& from) {
    CopyFrom(from);
    return *this;
  }

  static const BillDetail& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BillDetail* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BillDetail* other);

  // implements Message ----------------------------------------------

  BillDetail* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BillDetail& from);
  void MergeFrom(const BillDetail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string bill_id = 1;
  inline bool has_bill_id() const;
  inline void clear_bill_id();
  static const int kBillIdFieldNumber = 1;
  inline const ::std::string& bill_id() const;
  inline void set_bill_id(const ::std::string& value);
  inline void set_bill_id(const char* value);
  inline void set_bill_id(const char* value, size_t size);
  inline ::std::string* mutable_bill_id();
  inline ::std::string* release_bill_id();
  inline void set_allocated_bill_id(::std::string* bill_id);

  // optional uint64 amount = 2;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 2;
  inline ::google::protobuf::uint64 amount() const;
  inline void set_amount(::google::protobuf::uint64 value);

  // optional string from_date = 3;
  inline bool has_from_date() const;
  inline void clear_from_date();
  static const int kFromDateFieldNumber = 3;
  inline const ::std::string& from_date() const;
  inline void set_from_date(const ::std::string& value);
  inline void set_from_date(const char* value);
  inline void set_from_date(const char* value, size_t size);
  inline ::std::string* mutable_from_date();
  inline ::std::string* release_from_date();
  inline void set_allocated_from_date(::std::string* from_date);

  // optional string to_date = 4;
  inline bool has_to_date() const;
  inline void clear_to_date();
  static const int kToDateFieldNumber = 4;
  inline const ::std::string& to_date() const;
  inline void set_to_date(const ::std::string& value);
  inline void set_to_date(const char* value);
  inline void set_to_date(const char* value, size_t size);
  inline ::std::string* mutable_to_date();
  inline ::std::string* release_to_date();
  inline void set_allocated_to_date(::std::string* to_date);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.BillDetail)
 private:
  inline void set_has_bill_id();
  inline void clear_has_bill_id();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_from_date();
  inline void clear_has_from_date();
  inline void set_has_to_date();
  inline void clear_has_to_date();

  ::std::string* bill_id_;
  ::google::protobuf::uint64 amount_;
  ::std::string* from_date_;
  ::std::string* to_date_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static BillDetail* default_instance_;
};
// -------------------------------------------------------------------

class GetBillInfoReply : public ::google::protobuf::MessageLite {
 public:
  GetBillInfoReply();
  virtual ~GetBillInfoReply();

  GetBillInfoReply(const GetBillInfoReply& from);

  inline GetBillInfoReply& operator=(const GetBillInfoReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetBillInfoReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetBillInfoReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetBillInfoReply* other);

  // implements Message ----------------------------------------------

  GetBillInfoReply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetBillInfoReply& from);
  void MergeFrom(const GetBillInfoReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef GetBillInfoReply_ResultCode ResultCode;
  static const ResultCode ALL_OK = GetBillInfoReply_ResultCode_ALL_OK;
  static const ResultCode WRONG_ACCOUNT_ID = GetBillInfoReply_ResultCode_WRONG_ACCOUNT_ID;
  static const ResultCode WRONG_AMOUNT = GetBillInfoReply_ResultCode_WRONG_AMOUNT;
  static const ResultCode SYSTEM_ERROR = GetBillInfoReply_ResultCode_SYSTEM_ERROR;
  static inline bool ResultCode_IsValid(int value) {
    return GetBillInfoReply_ResultCode_IsValid(value);
  }
  static const ResultCode ResultCode_MIN =
    GetBillInfoReply_ResultCode_ResultCode_MIN;
  static const ResultCode ResultCode_MAX =
    GetBillInfoReply_ResultCode_ResultCode_MAX;
  static const int ResultCode_ARRAYSIZE =
    GetBillInfoReply_ResultCode_ResultCode_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional bool result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline bool result() const;
  inline void set_result(bool value);

  // optional uint32 rcode = 2;
  inline bool has_rcode() const;
  inline void clear_rcode();
  static const int kRcodeFieldNumber = 2;
  inline ::google::protobuf::uint32 rcode() const;
  inline void set_rcode(::google::protobuf::uint32 value);

  // optional string rdesc = 3;
  inline bool has_rdesc() const;
  inline void clear_rdesc();
  static const int kRdescFieldNumber = 3;
  inline const ::std::string& rdesc() const;
  inline void set_rdesc(const ::std::string& value);
  inline void set_rdesc(const char* value);
  inline void set_rdesc(const char* value, size_t size);
  inline ::std::string* mutable_rdesc();
  inline ::std::string* release_rdesc();
  inline void set_allocated_rdesc(::std::string* rdesc);

  // optional string name = 4;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 4;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string phone = 5;
  inline bool has_phone() const;
  inline void clear_phone();
  static const int kPhoneFieldNumber = 5;
  inline const ::std::string& phone() const;
  inline void set_phone(const ::std::string& value);
  inline void set_phone(const char* value);
  inline void set_phone(const char* value, size_t size);
  inline ::std::string* mutable_phone();
  inline ::std::string* release_phone();
  inline void set_allocated_phone(::std::string* phone);

  // optional string address = 6;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 6;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const char* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // repeated .com.mservice.momo.msg.BillDetail bills = 7;
  inline int bills_size() const;
  inline void clear_bills();
  static const int kBillsFieldNumber = 7;
  inline const ::com::mservice::momo::msg::BillDetail& bills(int index) const;
  inline ::com::mservice::momo::msg::BillDetail* mutable_bills(int index);
  inline ::com::mservice::momo::msg::BillDetail* add_bills();
  inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::BillDetail >&
      bills() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::BillDetail >*
      mutable_bills();

  // optional .com.mservice.momo.msg.GetBillInfoAction action = 8;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 8;
  inline ::com::mservice::momo::msg::GetBillInfoAction action() const;
  inline void set_action(::com::mservice::momo::msg::GetBillInfoAction value);

  // optional string providerId = 9;
  inline bool has_providerid() const;
  inline void clear_providerid();
  static const int kProviderIdFieldNumber = 9;
  inline const ::std::string& providerid() const;
  inline void set_providerid(const ::std::string& value);
  inline void set_providerid(const char* value);
  inline void set_providerid(const char* value, size_t size);
  inline ::std::string* mutable_providerid();
  inline ::std::string* release_providerid();
  inline void set_allocated_providerid(::std::string* providerid);

  // optional string billId = 10;
  inline bool has_billid() const;
  inline void clear_billid();
  static const int kBillIdFieldNumber = 10;
  inline const ::std::string& billid() const;
  inline void set_billid(const ::std::string& value);
  inline void set_billid(const char* value);
  inline void set_billid(const char* value, size_t size);
  inline ::std::string* mutable_billid();
  inline ::std::string* release_billid();
  inline void set_allocated_billid(::std::string* billid);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.GetBillInfoReply)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_rcode();
  inline void clear_has_rcode();
  inline void set_has_rdesc();
  inline void clear_has_rdesc();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_phone();
  inline void clear_has_phone();
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_action();
  inline void clear_has_action();
  inline void set_has_providerid();
  inline void clear_has_providerid();
  inline void set_has_billid();
  inline void clear_has_billid();

  bool result_;
  ::google::protobuf::uint32 rcode_;
  ::std::string* rdesc_;
  ::std::string* name_;
  ::std::string* phone_;
  ::std::string* address_;
  ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::BillDetail > bills_;
  ::std::string* providerid_;
  ::std::string* billid_;
  int action_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static GetBillInfoReply* default_instance_;
};
// -------------------------------------------------------------------

class ChangePin : public ::google::protobuf::MessageLite {
 public:
  ChangePin();
  virtual ~ChangePin();

  ChangePin(const ChangePin& from);

  inline ChangePin& operator=(const ChangePin& from) {
    CopyFrom(from);
    return *this;
  }

  static const ChangePin& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ChangePin* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ChangePin* other);

  // implements Message ----------------------------------------------

  ChangePin* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChangePin& from);
  void MergeFrom(const ChangePin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string new_pin = 1;
  inline bool has_new_pin() const;
  inline void clear_new_pin();
  static const int kNewPinFieldNumber = 1;
  inline const ::std::string& new_pin() const;
  inline void set_new_pin(const ::std::string& value);
  inline void set_new_pin(const char* value);
  inline void set_new_pin(const char* value, size_t size);
  inline ::std::string* mutable_new_pin();
  inline ::std::string* release_new_pin();
  inline void set_allocated_new_pin(::std::string* new_pin);

  // optional string old_pin = 2;
  inline bool has_old_pin() const;
  inline void clear_old_pin();
  static const int kOldPinFieldNumber = 2;
  inline const ::std::string& old_pin() const;
  inline void set_old_pin(const ::std::string& value);
  inline void set_old_pin(const char* value);
  inline void set_old_pin(const char* value, size_t size);
  inline ::std::string* mutable_old_pin();
  inline ::std::string* release_old_pin();
  inline void set_allocated_old_pin(::std::string* old_pin);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.ChangePin)
 private:
  inline void set_has_new_pin();
  inline void clear_has_new_pin();
  inline void set_has_old_pin();
  inline void clear_has_old_pin();

  ::std::string* new_pin_;
  ::std::string* old_pin_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static ChangePin* default_instance_;
};
// -------------------------------------------------------------------

class WhoIsMomoer : public ::google::protobuf::MessageLite {
 public:
  WhoIsMomoer();
  virtual ~WhoIsMomoer();

  WhoIsMomoer(const WhoIsMomoer& from);

  inline WhoIsMomoer& operator=(const WhoIsMomoer& from) {
    CopyFrom(from);
    return *this;
  }

  static const WhoIsMomoer& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const WhoIsMomoer* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(WhoIsMomoer* other);

  // implements Message ----------------------------------------------

  WhoIsMomoer* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const WhoIsMomoer& from);
  void MergeFrom(const WhoIsMomoer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 numbers = 1;
  inline int numbers_size() const;
  inline void clear_numbers();
  static const int kNumbersFieldNumber = 1;
  inline ::google::protobuf::uint32 numbers(int index) const;
  inline void set_numbers(int index, ::google::protobuf::uint32 value);
  inline void add_numbers(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      numbers() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_numbers();

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.WhoIsMomoer)
 private:

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > numbers_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static WhoIsMomoer* default_instance_;
};
// -------------------------------------------------------------------

class ViewPaymentHistoryByBillId : public ::google::protobuf::MessageLite {
 public:
  ViewPaymentHistoryByBillId();
  virtual ~ViewPaymentHistoryByBillId();

  ViewPaymentHistoryByBillId(const ViewPaymentHistoryByBillId& from);

  inline ViewPaymentHistoryByBillId& operator=(const ViewPaymentHistoryByBillId& from) {
    CopyFrom(from);
    return *this;
  }

  static const ViewPaymentHistoryByBillId& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ViewPaymentHistoryByBillId* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ViewPaymentHistoryByBillId* other);

  // implements Message ----------------------------------------------

  ViewPaymentHistoryByBillId* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ViewPaymentHistoryByBillId& from);
  void MergeFrom(const ViewPaymentHistoryByBillId& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string billId = 1;
  inline bool has_billid() const;
  inline void clear_billid();
  static const int kBillIdFieldNumber = 1;
  inline const ::std::string& billid() const;
  inline void set_billid(const ::std::string& value);
  inline void set_billid(const char* value);
  inline void set_billid(const char* value, size_t size);
  inline ::std::string* mutable_billid();
  inline ::std::string* release_billid();
  inline void set_allocated_billid(::std::string* billid);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.ViewPaymentHistoryByBillId)
 private:
  inline void set_has_billid();
  inline void clear_has_billid();

  ::std::string* billid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static ViewPaymentHistoryByBillId* default_instance_;
};
// -------------------------------------------------------------------

class ViewPaymentHistoryByBillIdReply : public ::google::protobuf::MessageLite {
 public:
  ViewPaymentHistoryByBillIdReply();
  virtual ~ViewPaymentHistoryByBillIdReply();

  ViewPaymentHistoryByBillIdReply(const ViewPaymentHistoryByBillIdReply& from);

  inline ViewPaymentHistoryByBillIdReply& operator=(const ViewPaymentHistoryByBillIdReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const ViewPaymentHistoryByBillIdReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ViewPaymentHistoryByBillIdReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ViewPaymentHistoryByBillIdReply* other);

  // implements Message ----------------------------------------------

  ViewPaymentHistoryByBillIdReply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ViewPaymentHistoryByBillIdReply& from);
  void MergeFrom(const ViewPaymentHistoryByBillIdReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline bool result() const;
  inline void set_result(bool value);

  // optional string rcode = 2;
  inline bool has_rcode() const;
  inline void clear_rcode();
  static const int kRcodeFieldNumber = 2;
  inline const ::std::string& rcode() const;
  inline void set_rcode(const ::std::string& value);
  inline void set_rcode(const char* value);
  inline void set_rcode(const char* value, size_t size);
  inline ::std::string* mutable_rcode();
  inline ::std::string* release_rcode();
  inline void set_allocated_rcode(::std::string* rcode);

  // optional string payment_history = 3;
  inline bool has_payment_history() const;
  inline void clear_payment_history();
  static const int kPaymentHistoryFieldNumber = 3;
  inline const ::std::string& payment_history() const;
  inline void set_payment_history(const ::std::string& value);
  inline void set_payment_history(const char* value);
  inline void set_payment_history(const char* value, size_t size);
  inline ::std::string* mutable_payment_history();
  inline ::std::string* release_payment_history();
  inline void set_allocated_payment_history(::std::string* payment_history);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.ViewPaymentHistoryByBillIdReply)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_rcode();
  inline void clear_has_rcode();
  inline void set_has_payment_history();
  inline void clear_has_payment_history();

  ::std::string* rcode_;
  ::std::string* payment_history_;
  bool result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static ViewPaymentHistoryByBillIdReply* default_instance_;
};
// -------------------------------------------------------------------

class DeviceInfo : public ::google::protobuf::MessageLite {
 public:
  DeviceInfo();
  virtual ~DeviceInfo();

  DeviceInfo(const DeviceInfo& from);

  inline DeviceInfo& operator=(const DeviceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const DeviceInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DeviceInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DeviceInfo* other);

  // implements Message ----------------------------------------------

  DeviceInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DeviceInfo& from);
  void MergeFrom(const DeviceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string deviceName = 1;
  inline bool has_devicename() const;
  inline void clear_devicename();
  static const int kDeviceNameFieldNumber = 1;
  inline const ::std::string& devicename() const;
  inline void set_devicename(const ::std::string& value);
  inline void set_devicename(const char* value);
  inline void set_devicename(const char* value, size_t size);
  inline ::std::string* mutable_devicename();
  inline ::std::string* release_devicename();
  inline void set_allocated_devicename(::std::string* devicename);

  // optional string deviceVersion = 2;
  inline bool has_deviceversion() const;
  inline void clear_deviceversion();
  static const int kDeviceVersionFieldNumber = 2;
  inline const ::std::string& deviceversion() const;
  inline void set_deviceversion(const ::std::string& value);
  inline void set_deviceversion(const char* value);
  inline void set_deviceversion(const char* value, size_t size);
  inline ::std::string* mutable_deviceversion();
  inline ::std::string* release_deviceversion();
  inline void set_allocated_deviceversion(::std::string* deviceversion);

  // optional string deviceModel = 3;
  inline bool has_devicemodel() const;
  inline void clear_devicemodel();
  static const int kDeviceModelFieldNumber = 3;
  inline const ::std::string& devicemodel() const;
  inline void set_devicemodel(const ::std::string& value);
  inline void set_devicemodel(const char* value);
  inline void set_devicemodel(const char* value, size_t size);
  inline ::std::string* mutable_devicemodel();
  inline ::std::string* release_devicemodel();
  inline void set_allocated_devicemodel(::std::string* devicemodel);

  // optional string deviceManufacturer = 4;
  inline bool has_devicemanufacturer() const;
  inline void clear_devicemanufacturer();
  static const int kDeviceManufacturerFieldNumber = 4;
  inline const ::std::string& devicemanufacturer() const;
  inline void set_devicemanufacturer(const ::std::string& value);
  inline void set_devicemanufacturer(const char* value);
  inline void set_devicemanufacturer(const char* value, size_t size);
  inline ::std::string* mutable_devicemanufacturer();
  inline ::std::string* release_devicemanufacturer();
  inline void set_allocated_devicemanufacturer(::std::string* devicemanufacturer);

  // optional string appVersion = 5;
  inline bool has_appversion() const;
  inline void clear_appversion();
  static const int kAppVersionFieldNumber = 5;
  inline const ::std::string& appversion() const;
  inline void set_appversion(const ::std::string& value);
  inline void set_appversion(const char* value);
  inline void set_appversion(const char* value, size_t size);
  inline ::std::string* mutable_appversion();
  inline ::std::string* release_appversion();
  inline void set_allocated_appversion(::std::string* appversion);

  // optional string deviceSWidth = 6;
  inline bool has_deviceswidth() const;
  inline void clear_deviceswidth();
  static const int kDeviceSWidthFieldNumber = 6;
  inline const ::std::string& deviceswidth() const;
  inline void set_deviceswidth(const ::std::string& value);
  inline void set_deviceswidth(const char* value);
  inline void set_deviceswidth(const char* value, size_t size);
  inline ::std::string* mutable_deviceswidth();
  inline ::std::string* release_deviceswidth();
  inline void set_allocated_deviceswidth(::std::string* deviceswidth);

  // optional string deviceSHeight = 7;
  inline bool has_devicesheight() const;
  inline void clear_devicesheight();
  static const int kDeviceSHeightFieldNumber = 7;
  inline const ::std::string& devicesheight() const;
  inline void set_devicesheight(const ::std::string& value);
  inline void set_devicesheight(const char* value);
  inline void set_devicesheight(const char* value, size_t size);
  inline ::std::string* mutable_devicesheight();
  inline ::std::string* release_devicesheight();
  inline void set_allocated_devicesheight(::std::string* devicesheight);

  // optional string devicePrimaryEmail = 8;
  inline bool has_deviceprimaryemail() const;
  inline void clear_deviceprimaryemail();
  static const int kDevicePrimaryEmailFieldNumber = 8;
  inline const ::std::string& deviceprimaryemail() const;
  inline void set_deviceprimaryemail(const ::std::string& value);
  inline void set_deviceprimaryemail(const char* value);
  inline void set_deviceprimaryemail(const char* value, size_t size);
  inline ::std::string* mutable_deviceprimaryemail();
  inline ::std::string* release_deviceprimaryemail();
  inline void set_allocated_deviceprimaryemail(::std::string* deviceprimaryemail);

  // optional string os = 9;
  inline bool has_os() const;
  inline void clear_os();
  static const int kOsFieldNumber = 9;
  inline const ::std::string& os() const;
  inline void set_os(const ::std::string& value);
  inline void set_os(const char* value);
  inline void set_os(const char* value, size_t size);
  inline ::std::string* mutable_os();
  inline ::std::string* release_os();
  inline void set_allocated_os(::std::string* os);

  // optional string token = 10;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 10;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.DeviceInfo)
 private:
  inline void set_has_devicename();
  inline void clear_has_devicename();
  inline void set_has_deviceversion();
  inline void clear_has_deviceversion();
  inline void set_has_devicemodel();
  inline void clear_has_devicemodel();
  inline void set_has_devicemanufacturer();
  inline void clear_has_devicemanufacturer();
  inline void set_has_appversion();
  inline void clear_has_appversion();
  inline void set_has_deviceswidth();
  inline void clear_has_deviceswidth();
  inline void set_has_devicesheight();
  inline void clear_has_devicesheight();
  inline void set_has_deviceprimaryemail();
  inline void clear_has_deviceprimaryemail();
  inline void set_has_os();
  inline void clear_has_os();
  inline void set_has_token();
  inline void clear_has_token();

  ::std::string* devicename_;
  ::std::string* deviceversion_;
  ::std::string* devicemodel_;
  ::std::string* devicemanufacturer_;
  ::std::string* appversion_;
  ::std::string* deviceswidth_;
  ::std::string* devicesheight_;
  ::std::string* deviceprimaryemail_;
  ::std::string* os_;
  ::std::string* token_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static DeviceInfo* default_instance_;
};
// -------------------------------------------------------------------

class GetAccessHistory : public ::google::protobuf::MessageLite {
 public:
  GetAccessHistory();
  virtual ~GetAccessHistory();

  GetAccessHistory(const GetAccessHistory& from);

  inline GetAccessHistory& operator=(const GetAccessHistory& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetAccessHistory& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetAccessHistory* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetAccessHistory* other);

  // implements Message ----------------------------------------------

  GetAccessHistory* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetAccessHistory& from);
  void MergeFrom(const GetAccessHistory& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 page_num = 1;
  inline bool has_page_num() const;
  inline void clear_page_num();
  static const int kPageNumFieldNumber = 1;
  inline ::google::protobuf::uint32 page_num() const;
  inline void set_page_num(::google::protobuf::uint32 value);

  // optional uint32 page_size = 2;
  inline bool has_page_size() const;
  inline void clear_page_size();
  static const int kPageSizeFieldNumber = 2;
  inline ::google::protobuf::uint32 page_size() const;
  inline void set_page_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.GetAccessHistory)
 private:
  inline void set_has_page_num();
  inline void clear_has_page_num();
  inline void set_has_page_size();
  inline void clear_has_page_size();

  ::google::protobuf::uint32 page_num_;
  ::google::protobuf::uint32 page_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static GetAccessHistory* default_instance_;
};
// -------------------------------------------------------------------

class AccessHistoryDetail : public ::google::protobuf::MessageLite {
 public:
  AccessHistoryDetail();
  virtual ~AccessHistoryDetail();

  AccessHistoryDetail(const AccessHistoryDetail& from);

  inline AccessHistoryDetail& operator=(const AccessHistoryDetail& from) {
    CopyFrom(from);
    return *this;
  }

  static const AccessHistoryDetail& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AccessHistoryDetail* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AccessHistoryDetail* other);

  // implements Message ----------------------------------------------

  AccessHistoryDetail* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AccessHistoryDetail& from);
  void MergeFrom(const AccessHistoryDetail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional uint64 time_in = 2;
  inline bool has_time_in() const;
  inline void clear_time_in();
  static const int kTimeInFieldNumber = 2;
  inline ::google::protobuf::uint64 time_in() const;
  inline void set_time_in(::google::protobuf::uint64 value);

  // optional uint64 time_out = 3;
  inline bool has_time_out() const;
  inline void clear_time_out();
  static const int kTimeOutFieldNumber = 3;
  inline ::google::protobuf::uint64 time_out() const;
  inline void set_time_out(::google::protobuf::uint64 value);

  // optional string device_model = 4;
  inline bool has_device_model() const;
  inline void clear_device_model();
  static const int kDeviceModelFieldNumber = 4;
  inline const ::std::string& device_model() const;
  inline void set_device_model(const ::std::string& value);
  inline void set_device_model(const char* value);
  inline void set_device_model(const char* value, size_t size);
  inline ::std::string* mutable_device_model();
  inline ::std::string* release_device_model();
  inline void set_allocated_device_model(::std::string* device_model);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.AccessHistoryDetail)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_time_in();
  inline void clear_has_time_in();
  inline void set_has_time_out();
  inline void clear_has_time_out();
  inline void set_has_device_model();
  inline void clear_has_device_model();

  ::std::string* ip_;
  ::google::protobuf::uint64 time_in_;
  ::google::protobuf::uint64 time_out_;
  ::std::string* device_model_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static AccessHistoryDetail* default_instance_;
};
// -------------------------------------------------------------------

class GetAccessHistoryReply : public ::google::protobuf::MessageLite {
 public:
  GetAccessHistoryReply();
  virtual ~GetAccessHistoryReply();

  GetAccessHistoryReply(const GetAccessHistoryReply& from);

  inline GetAccessHistoryReply& operator=(const GetAccessHistoryReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetAccessHistoryReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetAccessHistoryReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetAccessHistoryReply* other);

  // implements Message ----------------------------------------------

  GetAccessHistoryReply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetAccessHistoryReply& from);
  void MergeFrom(const GetAccessHistoryReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline bool result() const;
  inline void set_result(bool value);

  // repeated .com.mservice.momo.msg.AccessHistoryDetail access_detail = 2;
  inline int access_detail_size() const;
  inline void clear_access_detail();
  static const int kAccessDetailFieldNumber = 2;
  inline const ::com::mservice::momo::msg::AccessHistoryDetail& access_detail(int index) const;
  inline ::com::mservice::momo::msg::AccessHistoryDetail* mutable_access_detail(int index);
  inline ::com::mservice::momo::msg::AccessHistoryDetail* add_access_detail();
  inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::AccessHistoryDetail >&
      access_detail() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::AccessHistoryDetail >*
      mutable_access_detail();

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.GetAccessHistoryReply)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::AccessHistoryDetail > access_detail_;
  bool result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static GetAccessHistoryReply* default_instance_;
};
// -------------------------------------------------------------------

class StoreInfo : public ::google::protobuf::MessageLite {
 public:
  StoreInfo();
  virtual ~StoreInfo();

  StoreInfo(const StoreInfo& from);

  inline StoreInfo& operator=(const StoreInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const StoreInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StoreInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StoreInfo* other);

  // implements Message ----------------------------------------------

  StoreInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StoreInfo& from);
  void MergeFrom(const StoreInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string owner = 1;
  inline bool has_owner() const;
  inline void clear_owner();
  static const int kOwnerFieldNumber = 1;
  inline const ::std::string& owner() const;
  inline void set_owner(const ::std::string& value);
  inline void set_owner(const char* value);
  inline void set_owner(const char* value, size_t size);
  inline ::std::string* mutable_owner();
  inline ::std::string* release_owner();
  inline void set_allocated_owner(::std::string* owner);

  // optional string phone = 2;
  inline bool has_phone() const;
  inline void clear_phone();
  static const int kPhoneFieldNumber = 2;
  inline const ::std::string& phone() const;
  inline void set_phone(const ::std::string& value);
  inline void set_phone(const char* value);
  inline void set_phone(const char* value, size_t size);
  inline ::std::string* mutable_phone();
  inline ::std::string* release_phone();
  inline void set_allocated_phone(::std::string* phone);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string add = 4;
  inline bool has_add() const;
  inline void clear_add();
  static const int kAddFieldNumber = 4;
  inline const ::std::string& add() const;
  inline void set_add(const ::std::string& value);
  inline void set_add(const char* value);
  inline void set_add(const char* value, size_t size);
  inline ::std::string* mutable_add();
  inline ::std::string* release_add();
  inline void set_allocated_add(::std::string* add);

  // optional string street = 5;
  inline bool has_street() const;
  inline void clear_street();
  static const int kStreetFieldNumber = 5;
  inline const ::std::string& street() const;
  inline void set_street(const ::std::string& value);
  inline void set_street(const char* value);
  inline void set_street(const char* value, size_t size);
  inline ::std::string* mutable_street();
  inline ::std::string* release_street();
  inline void set_allocated_street(::std::string* street);

  // optional string ward = 6;
  inline bool has_ward() const;
  inline void clear_ward();
  static const int kWardFieldNumber = 6;
  inline const ::std::string& ward() const;
  inline void set_ward(const ::std::string& value);
  inline void set_ward(const char* value);
  inline void set_ward(const char* value, size_t size);
  inline ::std::string* mutable_ward();
  inline ::std::string* release_ward();
  inline void set_allocated_ward(::std::string* ward);

  // optional uint32 did = 7;
  inline bool has_did() const;
  inline void clear_did();
  static const int kDidFieldNumber = 7;
  inline ::google::protobuf::uint32 did() const;
  inline void set_did(::google::protobuf::uint32 value);

  // optional uint32 cid = 8;
  inline bool has_cid() const;
  inline void clear_cid();
  static const int kCidFieldNumber = 8;
  inline ::google::protobuf::uint32 cid() const;
  inline void set_cid(::google::protobuf::uint32 value);

  // optional uint32 aid = 9;
  inline bool has_aid() const;
  inline void clear_aid();
  static const int kAidFieldNumber = 9;
  inline ::google::protobuf::uint32 aid() const;
  inline void set_aid(::google::protobuf::uint32 value);

  // optional uint64 last_update_time = 10;
  inline bool has_last_update_time() const;
  inline void clear_last_update_time();
  static const int kLastUpdateTimeFieldNumber = 10;
  inline ::google::protobuf::uint64 last_update_time() const;
  inline void set_last_update_time(::google::protobuf::uint64 value);

  // optional bool deleted = 11;
  inline bool has_deleted() const;
  inline void clear_deleted();
  static const int kDeletedFieldNumber = 11;
  inline bool deleted() const;
  inline void set_deleted(bool value);

  // optional uint32 rowCoreId = 12;
  inline bool has_rowcoreid() const;
  inline void clear_rowcoreid();
  static const int kRowCoreIdFieldNumber = 12;
  inline ::google::protobuf::uint32 rowcoreid() const;
  inline void set_rowcoreid(::google::protobuf::uint32 value);

  // optional double lng = 13;
  inline bool has_lng() const;
  inline void clear_lng();
  static const int kLngFieldNumber = 13;
  inline double lng() const;
  inline void set_lng(double value);

  // optional double lat = 14;
  inline bool has_lat() const;
  inline void clear_lat();
  static const int kLatFieldNumber = 14;
  inline double lat() const;
  inline void set_lat(double value);

  // optional string momo_number = 15;
  inline bool has_momo_number() const;
  inline void clear_momo_number();
  static const int kMomoNumberFieldNumber = 15;
  inline const ::std::string& momo_number() const;
  inline void set_momo_number(const ::std::string& value);
  inline void set_momo_number(const char* value);
  inline void set_momo_number(const char* value, size_t size);
  inline ::std::string* mutable_momo_number();
  inline ::std::string* release_momo_number();
  inline void set_allocated_momo_number(::std::string* momo_number);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.StoreInfo)
 private:
  inline void set_has_owner();
  inline void clear_has_owner();
  inline void set_has_phone();
  inline void clear_has_phone();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_add();
  inline void clear_has_add();
  inline void set_has_street();
  inline void clear_has_street();
  inline void set_has_ward();
  inline void clear_has_ward();
  inline void set_has_did();
  inline void clear_has_did();
  inline void set_has_cid();
  inline void clear_has_cid();
  inline void set_has_aid();
  inline void clear_has_aid();
  inline void set_has_last_update_time();
  inline void clear_has_last_update_time();
  inline void set_has_deleted();
  inline void clear_has_deleted();
  inline void set_has_rowcoreid();
  inline void clear_has_rowcoreid();
  inline void set_has_lng();
  inline void clear_has_lng();
  inline void set_has_lat();
  inline void clear_has_lat();
  inline void set_has_momo_number();
  inline void clear_has_momo_number();

  ::std::string* owner_;
  ::std::string* phone_;
  ::std::string* name_;
  ::std::string* add_;
  ::std::string* street_;
  ::std::string* ward_;
  ::google::protobuf::uint32 did_;
  ::google::protobuf::uint32 cid_;
  ::google::protobuf::uint64 last_update_time_;
  ::google::protobuf::uint32 aid_;
  bool deleted_;
  double lng_;
  double lat_;
  ::std::string* momo_number_;
  ::google::protobuf::uint32 rowcoreid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static StoreInfo* default_instance_;
};
// -------------------------------------------------------------------

class SyncStoreLocationReply : public ::google::protobuf::MessageLite {
 public:
  SyncStoreLocationReply();
  virtual ~SyncStoreLocationReply();

  SyncStoreLocationReply(const SyncStoreLocationReply& from);

  inline SyncStoreLocationReply& operator=(const SyncStoreLocationReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const SyncStoreLocationReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SyncStoreLocationReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SyncStoreLocationReply* other);

  // implements Message ----------------------------------------------

  SyncStoreLocationReply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SyncStoreLocationReply& from);
  void MergeFrom(const SyncStoreLocationReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline bool result() const;
  inline void set_result(bool value);

  // repeated .com.mservice.momo.msg.StoreInfo stores = 2;
  inline int stores_size() const;
  inline void clear_stores();
  static const int kStoresFieldNumber = 2;
  inline const ::com::mservice::momo::msg::StoreInfo& stores(int index) const;
  inline ::com::mservice::momo::msg::StoreInfo* mutable_stores(int index);
  inline ::com::mservice::momo::msg::StoreInfo* add_stores();
  inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::StoreInfo >&
      stores() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::StoreInfo >*
      mutable_stores();

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.SyncStoreLocationReply)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::StoreInfo > stores_;
  bool result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static SyncStoreLocationReply* default_instance_;
};
// -------------------------------------------------------------------

class PhoneExist : public ::google::protobuf::MessageLite {
 public:
  PhoneExist();
  virtual ~PhoneExist();

  PhoneExist(const PhoneExist& from);

  inline PhoneExist& operator=(const PhoneExist& from) {
    CopyFrom(from);
    return *this;
  }

  static const PhoneExist& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PhoneExist* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PhoneExist* other);

  // implements Message ----------------------------------------------

  PhoneExist* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PhoneExist& from);
  void MergeFrom(const PhoneExist& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string number = 1;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 1;
  inline const ::std::string& number() const;
  inline void set_number(const ::std::string& value);
  inline void set_number(const char* value);
  inline void set_number(const char* value, size_t size);
  inline ::std::string* mutable_number();
  inline ::std::string* release_number();
  inline void set_allocated_number(::std::string* number);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.PhoneExist)
 private:
  inline void set_has_number();
  inline void clear_has_number();

  ::std::string* number_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static PhoneExist* default_instance_;
};
// -------------------------------------------------------------------

class AgentInfo : public ::google::protobuf::MessageLite {
 public:
  AgentInfo();
  virtual ~AgentInfo();

  AgentInfo(const AgentInfo& from);

  inline AgentInfo& operator=(const AgentInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const AgentInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AgentInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AgentInfo* other);

  // implements Message ----------------------------------------------

  AgentInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AgentInfo& from);
  void MergeFrom(const AgentInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline bool result() const;
  inline void set_result(bool value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string cardId = 3;
  inline bool has_cardid() const;
  inline void clear_cardid();
  static const int kCardIdFieldNumber = 3;
  inline const ::std::string& cardid() const;
  inline void set_cardid(const ::std::string& value);
  inline void set_cardid(const char* value);
  inline void set_cardid(const char* value, size_t size);
  inline ::std::string* mutable_cardid();
  inline ::std::string* release_cardid();
  inline void set_allocated_cardid(::std::string* cardid);

  // optional string address = 4;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 4;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const char* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // optional string dateOfBirth = 5;
  inline bool has_dateofbirth() const;
  inline void clear_dateofbirth();
  static const int kDateOfBirthFieldNumber = 5;
  inline const ::std::string& dateofbirth() const;
  inline void set_dateofbirth(const ::std::string& value);
  inline void set_dateofbirth(const char* value);
  inline void set_dateofbirth(const char* value, size_t size);
  inline ::std::string* mutable_dateofbirth();
  inline ::std::string* release_dateofbirth();
  inline void set_allocated_dateofbirth(::std::string* dateofbirth);

  // optional uint64 point = 6;
  inline bool has_point() const;
  inline void clear_point();
  static const int kPointFieldNumber = 6;
  inline ::google::protobuf::uint64 point() const;
  inline void set_point(::google::protobuf::uint64 value);

  // optional uint64 momo = 7;
  inline bool has_momo() const;
  inline void clear_momo();
  static const int kMomoFieldNumber = 7;
  inline ::google::protobuf::uint64 momo() const;
  inline void set_momo(::google::protobuf::uint64 value);

  // optional uint64 mload = 8;
  inline bool has_mload() const;
  inline void clear_mload();
  static const int kMloadFieldNumber = 8;
  inline ::google::protobuf::uint64 mload() const;
  inline void set_mload(::google::protobuf::uint64 value);

  // optional .com.mservice.momo.msg.RegStatus regStatus = 9;
  inline bool has_regstatus() const;
  inline void clear_regstatus();
  static const int kRegStatusFieldNumber = 9;
  inline const ::com::mservice::momo::msg::RegStatus& regstatus() const;
  inline ::com::mservice::momo::msg::RegStatus* mutable_regstatus();
  inline ::com::mservice::momo::msg::RegStatus* release_regstatus();
  inline void set_allocated_regstatus(::com::mservice::momo::msg::RegStatus* regstatus);

  // optional string bank_name = 10;
  inline bool has_bank_name() const;
  inline void clear_bank_name();
  static const int kBankNameFieldNumber = 10;
  inline const ::std::string& bank_name() const;
  inline void set_bank_name(const ::std::string& value);
  inline void set_bank_name(const char* value);
  inline void set_bank_name(const char* value, size_t size);
  inline ::std::string* mutable_bank_name();
  inline ::std::string* release_bank_name();
  inline void set_allocated_bank_name(::std::string* bank_name);

  // optional string bank_account = 11;
  inline bool has_bank_account() const;
  inline void clear_bank_account();
  static const int kBankAccountFieldNumber = 11;
  inline const ::std::string& bank_account() const;
  inline void set_bank_account(const ::std::string& value);
  inline void set_bank_account(const char* value);
  inline void set_bank_account(const char* value, size_t size);
  inline ::std::string* mutable_bank_account();
  inline ::std::string* release_bank_account();
  inline void set_allocated_bank_account(::std::string* bank_account);

  // optional string bank_code = 12;
  inline bool has_bank_code() const;
  inline void clear_bank_code();
  static const int kBankCodeFieldNumber = 12;
  inline const ::std::string& bank_code() const;
  inline void set_bank_code(const ::std::string& value);
  inline void set_bank_code(const char* value);
  inline void set_bank_code(const char* value, size_t size);
  inline ::std::string* mutable_bank_code();
  inline ::std::string* release_bank_code();
  inline void set_allocated_bank_code(::std::string* bank_code);

  // optional string email = 13;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 13;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // optional uint32 noname_count = 14;
  inline bool has_noname_count() const;
  inline void clear_noname_count();
  static const int kNonameCountFieldNumber = 14;
  inline ::google::protobuf::uint32 noname_count() const;
  inline void set_noname_count(::google::protobuf::uint32 value);

  // optional bool in_promotion = 15;
  inline bool has_in_promotion() const;
  inline void clear_in_promotion();
  static const int kInPromotionFieldNumber = 15;
  inline bool in_promotion() const;
  inline void set_in_promotion(bool value);

  // optional bool exist = 16;
  inline bool has_exist() const;
  inline void clear_exist();
  static const int kExistFieldNumber = 16;
  inline bool exist() const;
  inline void set_exist(bool value);

  // repeated .com.mservice.momo.msg.TextValue list_key_value = 17;
  inline int list_key_value_size() const;
  inline void clear_list_key_value();
  static const int kListKeyValueFieldNumber = 17;
  inline const ::com::mservice::momo::msg::TextValue& list_key_value(int index) const;
  inline ::com::mservice::momo::msg::TextValue* mutable_list_key_value(int index);
  inline ::com::mservice::momo::msg::TextValue* add_list_key_value();
  inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::TextValue >&
      list_key_value() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::TextValue >*
      mutable_list_key_value();

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.AgentInfo)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_cardid();
  inline void clear_has_cardid();
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_dateofbirth();
  inline void clear_has_dateofbirth();
  inline void set_has_point();
  inline void clear_has_point();
  inline void set_has_momo();
  inline void clear_has_momo();
  inline void set_has_mload();
  inline void clear_has_mload();
  inline void set_has_regstatus();
  inline void clear_has_regstatus();
  inline void set_has_bank_name();
  inline void clear_has_bank_name();
  inline void set_has_bank_account();
  inline void clear_has_bank_account();
  inline void set_has_bank_code();
  inline void clear_has_bank_code();
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_noname_count();
  inline void clear_has_noname_count();
  inline void set_has_in_promotion();
  inline void clear_has_in_promotion();
  inline void set_has_exist();
  inline void clear_has_exist();

  ::std::string* name_;
  ::std::string* cardid_;
  ::std::string* address_;
  ::std::string* dateofbirth_;
  ::google::protobuf::uint64 point_;
  ::google::protobuf::uint64 momo_;
  ::google::protobuf::uint64 mload_;
  ::com::mservice::momo::msg::RegStatus* regstatus_;
  ::std::string* bank_name_;
  ::std::string* bank_account_;
  bool result_;
  bool in_promotion_;
  bool exist_;
  ::google::protobuf::uint32 noname_count_;
  ::std::string* bank_code_;
  ::std::string* email_;
  ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::TextValue > list_key_value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(17 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static AgentInfo* default_instance_;
};
// -------------------------------------------------------------------

class BankNetToMomoRely : public ::google::protobuf::MessageLite {
 public:
  BankNetToMomoRely();
  virtual ~BankNetToMomoRely();

  BankNetToMomoRely(const BankNetToMomoRely& from);

  inline BankNetToMomoRely& operator=(const BankNetToMomoRely& from) {
    CopyFrom(from);
    return *this;
  }

  static const BankNetToMomoRely& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BankNetToMomoRely* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BankNetToMomoRely* other);

  // implements Message ----------------------------------------------

  BankNetToMomoRely* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BankNetToMomoRely& from);
  void MergeFrom(const BankNetToMomoRely& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline bool result() const;
  inline void set_result(bool value);

  // optional uint32 rcode = 2;
  inline bool has_rcode() const;
  inline void clear_rcode();
  static const int kRcodeFieldNumber = 2;
  inline ::google::protobuf::uint32 rcode() const;
  inline void set_rcode(::google::protobuf::uint32 value);

  // optional string merchant_trans_id = 3;
  inline bool has_merchant_trans_id() const;
  inline void clear_merchant_trans_id();
  static const int kMerchantTransIdFieldNumber = 3;
  inline const ::std::string& merchant_trans_id() const;
  inline void set_merchant_trans_id(const ::std::string& value);
  inline void set_merchant_trans_id(const char* value);
  inline void set_merchant_trans_id(const char* value, size_t size);
  inline ::std::string* mutable_merchant_trans_id();
  inline ::std::string* release_merchant_trans_id();
  inline void set_allocated_merchant_trans_id(::std::string* merchant_trans_id);

  // optional string trans_id = 4;
  inline bool has_trans_id() const;
  inline void clear_trans_id();
  static const int kTransIdFieldNumber = 4;
  inline const ::std::string& trans_id() const;
  inline void set_trans_id(const ::std::string& value);
  inline void set_trans_id(const char* value);
  inline void set_trans_id(const char* value, size_t size);
  inline ::std::string* mutable_trans_id();
  inline ::std::string* release_trans_id();
  inline void set_allocated_trans_id(::std::string* trans_id);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.BankNetToMomoRely)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_rcode();
  inline void clear_has_rcode();
  inline void set_has_merchant_trans_id();
  inline void clear_has_merchant_trans_id();
  inline void set_has_trans_id();
  inline void clear_has_trans_id();

  bool result_;
  ::google::protobuf::uint32 rcode_;
  ::std::string* merchant_trans_id_;
  ::std::string* trans_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static BankNetToMomoRely* default_instance_;
};
// -------------------------------------------------------------------

class MoneyRequest : public ::google::protobuf::MessageLite {
 public:
  MoneyRequest();
  virtual ~MoneyRequest();

  MoneyRequest(const MoneyRequest& from);

  inline MoneyRequest& operator=(const MoneyRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const MoneyRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MoneyRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MoneyRequest* other);

  // implements Message ----------------------------------------------

  MoneyRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MoneyRequest& from);
  void MergeFrom(const MoneyRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 to_number = 1;
  inline bool has_to_number() const;
  inline void clear_to_number();
  static const int kToNumberFieldNumber = 1;
  inline ::google::protobuf::uint32 to_number() const;
  inline void set_to_number(::google::protobuf::uint32 value);

  // optional uint64 amount = 2;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 2;
  inline ::google::protobuf::uint64 amount() const;
  inline void set_amount(::google::protobuf::uint64 value);

  // optional string content = 3;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 3;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // optional uint32 from_number = 4;
  inline bool has_from_number() const;
  inline void clear_from_number();
  static const int kFromNumberFieldNumber = 4;
  inline ::google::protobuf::uint32 from_number() const;
  inline void set_from_number(::google::protobuf::uint32 value);

  // optional string from_name = 5;
  inline bool has_from_name() const;
  inline void clear_from_name();
  static const int kFromNameFieldNumber = 5;
  inline const ::std::string& from_name() const;
  inline void set_from_name(const ::std::string& value);
  inline void set_from_name(const char* value);
  inline void set_from_name(const char* value, size_t size);
  inline ::std::string* mutable_from_name();
  inline ::std::string* release_from_name();
  inline void set_allocated_from_name(::std::string* from_name);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.MoneyRequest)
 private:
  inline void set_has_to_number();
  inline void clear_has_to_number();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_from_number();
  inline void clear_has_from_number();
  inline void set_has_from_name();
  inline void clear_has_from_name();

  ::google::protobuf::uint64 amount_;
  ::google::protobuf::uint32 to_number_;
  ::google::protobuf::uint32 from_number_;
  ::std::string* content_;
  ::std::string* from_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static MoneyRequest* default_instance_;
};
// -------------------------------------------------------------------

class TranHisV1 : public ::google::protobuf::MessageLite {
 public:
  TranHisV1();
  virtual ~TranHisV1();

  TranHisV1(const TranHisV1& from);

  inline TranHisV1& operator=(const TranHisV1& from) {
    CopyFrom(from);
    return *this;
  }

  static const TranHisV1& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TranHisV1* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TranHisV1* other);

  // implements Message ----------------------------------------------

  TranHisV1* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TranHisV1& from);
  void MergeFrom(const TranHisV1& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef TranHisV1_TranType TranType;
  static const TranType BANK_IN = TranHisV1_TranType_BANK_IN;
  static const TranType BANK_OUT = TranHisV1_TranType_BANK_OUT;
  static const TranType TOP_UP = TranHisV1_TranType_TOP_UP;
  static const TranType TOP_UP_GAME = TranHisV1_TranType_TOP_UP_GAME;
  static const TranType M2C = TranHisV1_TranType_M2C;
  static const TranType M2M = TranHisV1_TranType_M2M;
  static const TranType PAY_ONE_BILL = TranHisV1_TranType_PAY_ONE_BILL;
  static const TranType QUICK_PAYMENT = TranHisV1_TranType_QUICK_PAYMENT;
  static const TranType QUICK_DEPOSIT = TranHisV1_TranType_QUICK_DEPOSIT;
  static const TranType BANK_NET_TO_MOMO = TranHisV1_TranType_BANK_NET_TO_MOMO;
  static const TranType BANK_NET_VERIFY_OTP = TranHisV1_TranType_BANK_NET_VERIFY_OTP;
  static const TranType PAY_ONE_BILL_OTHER = TranHisV1_TranType_PAY_ONE_BILL_OTHER;
  static const TranType TRANSFER_MONEY_TO_PLACE = TranHisV1_TranType_TRANSFER_MONEY_TO_PLACE;
  static const TranType BILL_PAY_TELEPHONE = TranHisV1_TranType_BILL_PAY_TELEPHONE;
  static const TranType BILL_PAY_TICKET_AIRLINE = TranHisV1_TranType_BILL_PAY_TICKET_AIRLINE;
  static const TranType BILL_PAY_TICKET_TRAIN = TranHisV1_TranType_BILL_PAY_TICKET_TRAIN;
  static const TranType BILL_PAY_INSURANCE = TranHisV1_TranType_BILL_PAY_INSURANCE;
  static const TranType BILL_PAY_INTERNET = TranHisV1_TranType_BILL_PAY_INTERNET;
  static const TranType BILL_PAY_OTHER = TranHisV1_TranType_BILL_PAY_OTHER;
  static const TranType DEPOSIT_CASH_OTHER = TranHisV1_TranType_DEPOSIT_CASH_OTHER;
  static const TranType BUY_MOBILITY_CARD = TranHisV1_TranType_BUY_MOBILITY_CARD;
  static const TranType BUY_GAME_CARD = TranHisV1_TranType_BUY_GAME_CARD;
  static const TranType BUY_OTHER = TranHisV1_TranType_BUY_OTHER;
  static const TranType DEPOSIT_CASH = TranHisV1_TranType_DEPOSIT_CASH;
  static const TranType BILL_PAY_CINEMA = TranHisV1_TranType_BILL_PAY_CINEMA;
  static const TranType MOMO_TO_BANK_MANUAL = TranHisV1_TranType_MOMO_TO_BANK_MANUAL;
  static const TranType DEPOSIT_AT_HOME = TranHisV1_TranType_DEPOSIT_AT_HOME;
  static const TranType WITHDRAW_AT_HOME = TranHisV1_TranType_WITHDRAW_AT_HOME;
  static const TranType BONUS = TranHisV1_TranType_BONUS;
  static const TranType FEE = TranHisV1_TranType_FEE;
  static const TranType PHIM123 = TranHisV1_TranType_PHIM123;
  static const TranType PAY_NUOCCL_BILL = TranHisV1_TranType_PAY_NUOCCL_BILL;
  static const TranType PAY_AVG_BILL = TranHisV1_TranType_PAY_AVG_BILL;
  static const TranType PAY_ONE_BILL_SERVICE = TranHisV1_TranType_PAY_ONE_BILL_SERVICE;
  static const TranType BUY_GIFT = TranHisV1_TranType_BUY_GIFT;
  static const TranType SEND_GIFT = TranHisV1_TranType_SEND_GIFT;
  static const TranType GIFT_TO_MPOINT = TranHisV1_TranType_GIFT_TO_MPOINT;
  static const TranType GIFT_RECEIVE = TranHisV1_TranType_GIFT_RECEIVE;
  static const TranType NAMED = TranHisV1_TranType_NAMED;
  static const TranType PAY_BACK = TranHisV1_TranType_PAY_BACK;
  static const TranType PROMOTION = TranHisV1_TranType_PROMOTION;
  static const TranType VOUCHER = TranHisV1_TranType_VOUCHER;
  static const TranType POINT = TranHisV1_TranType_POINT;
  static const TranType GIFT_CLAIM = TranHisV1_TranType_GIFT_CLAIM;
  static const TranType MPOINT_CLAIM = TranHisV1_TranType_MPOINT_CLAIM;
  static const TranType C2C = TranHisV1_TranType_C2C;
  static const TranType C2C_RECEIVE = TranHisV1_TranType_C2C_RECEIVE;
  static const TranType C2C_BONUS_SEND = TranHisV1_TranType_C2C_BONUS_SEND;
  static const TranType C2C_BONUS_RECEIVE = TranHisV1_TranType_C2C_BONUS_RECEIVE;
  static const TranType VM_PROCESS_CASH_IN = TranHisV1_TranType_VM_PROCESS_CASH_IN;
  static const TranType BONUS_DGD = TranHisV1_TranType_BONUS_DGD;
  static const TranType BONUS_300 = TranHisV1_TranType_BONUS_300;
  static const TranType PAY_ONE_SALE_OFF_BILL = TranHisV1_TranType_PAY_ONE_SALE_OFF_BILL;
  static const TranType TRANSFER_ONE_BILL = TranHisV1_TranType_TRANSFER_ONE_BILL;
  static const TranType PAY_SDK_BILL = TranHisV1_TranType_PAY_SDK_BILL;
  static const TranType PAY_IPOS_BILL = TranHisV1_TranType_PAY_IPOS_BILL;
  static const TranType ATM_CASH_IN = TranHisV1_TranType_ATM_CASH_IN;
  static const TranType ATM_CASH_IN_REPLY = TranHisV1_TranType_ATM_CASH_IN_REPLY;
  static const TranType ATM_CASH_OUT = TranHisV1_TranType_ATM_CASH_OUT;
  static const TranType ATM_CASH_OUT_REPLY = TranHisV1_TranType_ATM_CASH_OUT_REPLY;
  static inline bool TranType_IsValid(int value) {
    return TranHisV1_TranType_IsValid(value);
  }
  static const TranType TranType_MIN =
    TranHisV1_TranType_TranType_MIN;
  static const TranType TranType_MAX =
    TranHisV1_TranType_TranType_MAX;
  static const int TranType_ARRAYSIZE =
    TranHisV1_TranType_TranType_ARRAYSIZE;

  typedef TranHisV1_ResultCode ResultCode;
  static const ResultCode SYSTEM_ERROR = TranHisV1_ResultCode_SYSTEM_ERROR;
  static const ResultCode ALL_OK = TranHisV1_ResultCode_ALL_OK;
  static const ResultCode PARTNER_NUMBER_NOT_VALID = TranHisV1_ResultCode_PARTNER_NUMBER_NOT_VALID;
  static const ResultCode SESSION_EXPIRED = TranHisV1_ResultCode_SESSION_EXPIRED;
  static const ResultCode NOT_SUPPORT = TranHisV1_ResultCode_NOT_SUPPORT;
  static const ResultCode NO_SUCH_GIFT = TranHisV1_ResultCode_NO_SUCH_GIFT;
  static const ResultCode GIFT_TYPE_NOT_ACTIVE = TranHisV1_ResultCode_GIFT_TYPE_NOT_ACTIVE;
  static const ResultCode WRONG_PRICE_AMOUNT = TranHisV1_ResultCode_WRONG_PRICE_AMOUNT;
  static const ResultCode ALREADY_OWNED = TranHisV1_ResultCode_ALREADY_OWNED;
  static const ResultCode NOT_TRANSFERABLE = TranHisV1_ResultCode_NOT_TRANSFERABLE;
  static const ResultCode CUSTOM_ERROR = TranHisV1_ResultCode_CUSTOM_ERROR;
  static const ResultCode NOT_OWNED = TranHisV1_ResultCode_NOT_OWNED;
  static inline bool ResultCode_IsValid(int value) {
    return TranHisV1_ResultCode_IsValid(value);
  }
  static const ResultCode ResultCode_MIN =
    TranHisV1_ResultCode_ResultCode_MIN;
  static const ResultCode ResultCode_MAX =
    TranHisV1_ResultCode_ResultCode_MAX;
  static const int ResultCode_ARRAYSIZE =
    TranHisV1_ResultCode_ResultCode_ARRAYSIZE;

  typedef TranHisV1_SourceFrom SourceFrom;
  static const SourceFrom MOMO = TranHisV1_SourceFrom_MOMO;
  static const SourceFrom BANKLINKED = TranHisV1_SourceFrom_BANKLINKED;
  static const SourceFrom MASTERCARD = TranHisV1_SourceFrom_MASTERCARD;
  static const SourceFrom VISA = TranHisV1_SourceFrom_VISA;
  static const SourceFrom BANK_NET_2_VERIFY_OTP = TranHisV1_SourceFrom_BANK_NET_2_VERIFY_OTP;
  static const SourceFrom PAY123 = TranHisV1_SourceFrom_PAY123;
  static inline bool SourceFrom_IsValid(int value) {
    return TranHisV1_SourceFrom_IsValid(value);
  }
  static const SourceFrom SourceFrom_MIN =
    TranHisV1_SourceFrom_SourceFrom_MIN;
  static const SourceFrom SourceFrom_MAX =
    TranHisV1_SourceFrom_SourceFrom_MAX;
  static const int SourceFrom_ARRAYSIZE =
    TranHisV1_SourceFrom_SourceFrom_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional uint64 tranId = 1;
  inline bool has_tranid() const;
  inline void clear_tranid();
  static const int kTranIdFieldNumber = 1;
  inline ::google::protobuf::uint64 tranid() const;
  inline void set_tranid(::google::protobuf::uint64 value);

  // optional uint64 client_time = 2;
  inline bool has_client_time() const;
  inline void clear_client_time();
  static const int kClientTimeFieldNumber = 2;
  inline ::google::protobuf::uint64 client_time() const;
  inline void set_client_time(::google::protobuf::uint64 value);

  // optional uint64 ackTime = 3;
  inline bool has_acktime() const;
  inline void clear_acktime();
  static const int kAckTimeFieldNumber = 3;
  inline ::google::protobuf::uint64 acktime() const;
  inline void set_acktime(::google::protobuf::uint64 value);

  // optional uint64 finishTime = 4;
  inline bool has_finishtime() const;
  inline void clear_finishtime();
  static const int kFinishTimeFieldNumber = 4;
  inline ::google::protobuf::uint64 finishtime() const;
  inline void set_finishtime(::google::protobuf::uint64 value);

  // optional uint32 tranType = 5;
  inline bool has_trantype() const;
  inline void clear_trantype();
  static const int kTranTypeFieldNumber = 5;
  inline ::google::protobuf::uint32 trantype() const;
  inline void set_trantype(::google::protobuf::uint32 value);

  // optional uint32 io = 6;
  inline bool has_io() const;
  inline void clear_io();
  static const int kIoFieldNumber = 6;
  inline ::google::protobuf::uint32 io() const;
  inline void set_io(::google::protobuf::uint32 value);

  // optional uint32 category = 7;
  inline bool has_category() const;
  inline void clear_category();
  static const int kCategoryFieldNumber = 7;
  inline ::google::protobuf::uint32 category() const;
  inline void set_category(::google::protobuf::uint32 value);

  // optional string partnerId = 8;
  inline bool has_partnerid() const;
  inline void clear_partnerid();
  static const int kPartnerIdFieldNumber = 8;
  inline const ::std::string& partnerid() const;
  inline void set_partnerid(const ::std::string& value);
  inline void set_partnerid(const char* value);
  inline void set_partnerid(const char* value, size_t size);
  inline ::std::string* mutable_partnerid();
  inline ::std::string* release_partnerid();
  inline void set_allocated_partnerid(::std::string* partnerid);

  // optional string partnerCode = 9;
  inline bool has_partnercode() const;
  inline void clear_partnercode();
  static const int kPartnerCodeFieldNumber = 9;
  inline const ::std::string& partnercode() const;
  inline void set_partnercode(const ::std::string& value);
  inline void set_partnercode(const char* value);
  inline void set_partnercode(const char* value, size_t size);
  inline ::std::string* mutable_partnercode();
  inline ::std::string* release_partnercode();
  inline void set_allocated_partnercode(::std::string* partnercode);

  // optional string partnerName = 10;
  inline bool has_partnername() const;
  inline void clear_partnername();
  static const int kPartnerNameFieldNumber = 10;
  inline const ::std::string& partnername() const;
  inline void set_partnername(const ::std::string& value);
  inline void set_partnername(const char* value);
  inline void set_partnername(const char* value, size_t size);
  inline ::std::string* mutable_partnername();
  inline ::std::string* release_partnername();
  inline void set_allocated_partnername(::std::string* partnername);

  // optional string partner_ref = 11;
  inline bool has_partner_ref() const;
  inline void clear_partner_ref();
  static const int kPartnerRefFieldNumber = 11;
  inline const ::std::string& partner_ref() const;
  inline void set_partner_ref(const ::std::string& value);
  inline void set_partner_ref(const char* value);
  inline void set_partner_ref(const char* value, size_t size);
  inline ::std::string* mutable_partner_ref();
  inline ::std::string* release_partner_ref();
  inline void set_allocated_partner_ref(::std::string* partner_ref);

  // optional string billId = 12;
  inline bool has_billid() const;
  inline void clear_billid();
  static const int kBillIdFieldNumber = 12;
  inline const ::std::string& billid() const;
  inline void set_billid(const ::std::string& value);
  inline void set_billid(const char* value);
  inline void set_billid(const char* value, size_t size);
  inline ::std::string* mutable_billid();
  inline ::std::string* release_billid();
  inline void set_allocated_billid(::std::string* billid);

  // optional uint64 amount = 13;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 13;
  inline ::google::protobuf::uint64 amount() const;
  inline void set_amount(::google::protobuf::uint64 value);

  // optional string comment = 14;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 14;
  inline const ::std::string& comment() const;
  inline void set_comment(const ::std::string& value);
  inline void set_comment(const char* value);
  inline void set_comment(const char* value, size_t size);
  inline ::std::string* mutable_comment();
  inline ::std::string* release_comment();
  inline void set_allocated_comment(::std::string* comment);

  // optional uint32 status = 15;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 15;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // optional uint32 error = 16;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 16;
  inline ::google::protobuf::uint32 error() const;
  inline void set_error(::google::protobuf::uint32 value);

  // optional uint64 command_Ind = 17;
  inline bool has_command_ind() const;
  inline void clear_command_ind();
  static const int kCommandIndFieldNumber = 17;
  inline ::google::protobuf::uint64 command_ind() const;
  inline void set_command_ind(::google::protobuf::uint64 value);

  // optional uint32 source_from = 18;
  inline bool has_source_from() const;
  inline void clear_source_from();
  static const int kSourceFromFieldNumber = 18;
  inline ::google::protobuf::uint32 source_from() const;
  inline void set_source_from(::google::protobuf::uint32 value);

  // optional string partner_extra_1 = 19;
  inline bool has_partner_extra_1() const;
  inline void clear_partner_extra_1();
  static const int kPartnerExtra1FieldNumber = 19;
  inline const ::std::string& partner_extra_1() const;
  inline void set_partner_extra_1(const ::std::string& value);
  inline void set_partner_extra_1(const char* value);
  inline void set_partner_extra_1(const char* value, size_t size);
  inline ::std::string* mutable_partner_extra_1();
  inline ::std::string* release_partner_extra_1();
  inline void set_allocated_partner_extra_1(::std::string* partner_extra_1);

  // repeated .com.mservice.momo.msg.TextValue kvp = 20;
  inline int kvp_size() const;
  inline void clear_kvp();
  static const int kKvpFieldNumber = 20;
  inline const ::com::mservice::momo::msg::TextValue& kvp(int index) const;
  inline ::com::mservice::momo::msg::TextValue* mutable_kvp(int index);
  inline ::com::mservice::momo::msg::TextValue* add_kvp();
  inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::TextValue >&
      kvp() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::TextValue >*
      mutable_kvp();

  // optional string desc = 21;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 21;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  inline void set_allocated_desc(::std::string* desc);

  // optional string share = 22;
  inline bool has_share() const;
  inline void clear_share();
  static const int kShareFieldNumber = 22;
  inline const ::std::string& share() const;
  inline void set_share(const ::std::string& value);
  inline void set_share(const char* value);
  inline void set_share(const char* value, size_t size);
  inline ::std::string* mutable_share();
  inline ::std::string* release_share();
  inline void set_allocated_share(::std::string* share);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.TranHisV1)
 private:
  inline void set_has_tranid();
  inline void clear_has_tranid();
  inline void set_has_client_time();
  inline void clear_has_client_time();
  inline void set_has_acktime();
  inline void clear_has_acktime();
  inline void set_has_finishtime();
  inline void clear_has_finishtime();
  inline void set_has_trantype();
  inline void clear_has_trantype();
  inline void set_has_io();
  inline void clear_has_io();
  inline void set_has_category();
  inline void clear_has_category();
  inline void set_has_partnerid();
  inline void clear_has_partnerid();
  inline void set_has_partnercode();
  inline void clear_has_partnercode();
  inline void set_has_partnername();
  inline void clear_has_partnername();
  inline void set_has_partner_ref();
  inline void clear_has_partner_ref();
  inline void set_has_billid();
  inline void clear_has_billid();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_comment();
  inline void clear_has_comment();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_command_ind();
  inline void clear_has_command_ind();
  inline void set_has_source_from();
  inline void clear_has_source_from();
  inline void set_has_partner_extra_1();
  inline void clear_has_partner_extra_1();
  inline void set_has_desc();
  inline void clear_has_desc();
  inline void set_has_share();
  inline void clear_has_share();

  ::google::protobuf::uint64 tranid_;
  ::google::protobuf::uint64 client_time_;
  ::google::protobuf::uint64 acktime_;
  ::google::protobuf::uint64 finishtime_;
  ::google::protobuf::uint32 trantype_;
  ::google::protobuf::uint32 io_;
  ::std::string* partnerid_;
  ::std::string* partnercode_;
  ::std::string* partnername_;
  ::std::string* partner_ref_;
  ::google::protobuf::uint32 category_;
  ::google::protobuf::uint32 status_;
  ::std::string* billid_;
  ::google::protobuf::uint64 amount_;
  ::std::string* comment_;
  ::google::protobuf::uint64 command_ind_;
  ::google::protobuf::uint32 error_;
  ::google::protobuf::uint32 source_from_;
  ::std::string* partner_extra_1_;
  ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::TextValue > kvp_;
  ::std::string* desc_;
  ::std::string* share_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(22 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static TranHisV1* default_instance_;
};
// -------------------------------------------------------------------

class CardItem : public ::google::protobuf::MessageLite {
 public:
  CardItem();
  virtual ~CardItem();

  CardItem(const CardItem& from);

  inline CardItem& operator=(const CardItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const CardItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CardItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CardItem* other);

  // implements Message ----------------------------------------------

  CardItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CardItem& from);
  void MergeFrom(const CardItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CardItem_LockedType LockedType;
  static const LockedType FULL = CardItem_LockedType_FULL;
  static const LockedType PART = CardItem_LockedType_PART;
  static const LockedType BANKLINKED = CardItem_LockedType_BANKLINKED;
  static inline bool LockedType_IsValid(int value) {
    return CardItem_LockedType_IsValid(value);
  }
  static const LockedType LockedType_MIN =
    CardItem_LockedType_LockedType_MIN;
  static const LockedType LockedType_MAX =
    CardItem_LockedType_LockedType_MAX;
  static const int LockedType_ARRAYSIZE =
    CardItem_LockedType_LockedType_ARRAYSIZE;

  typedef CardItem_Channel Channel;
  static const Channel BANKNET = CardItem_Channel_BANKNET;
  static const Channel ONEPAY = CardItem_Channel_ONEPAY;
  static const Channel SMARTLINK = CardItem_Channel_SMARTLINK;
  static const Channel MANUAL = CardItem_Channel_MANUAL;
  static inline bool Channel_IsValid(int value) {
    return CardItem_Channel_IsValid(value);
  }
  static const Channel Channel_MIN =
    CardItem_Channel_Channel_MIN;
  static const Channel Channel_MAX =
    CardItem_Channel_Channel_MAX;
  static const int Channel_ARRAYSIZE =
    CardItem_Channel_Channel_ARRAYSIZE;

  typedef CardItem_IOCity IOCity;
  static const IOCity OUT = CardItem_IOCity_OUT;
  static const IOCity IN = CardItem_IOCity_IN;
  static inline bool IOCity_IsValid(int value) {
    return CardItem_IOCity_IsValid(value);
  }
  static const IOCity IOCity_MIN =
    CardItem_IOCity_IOCity_MIN;
  static const IOCity IOCity_MAX =
    CardItem_IOCity_IOCity_MAX;
  static const int IOCity_ARRAYSIZE =
    CardItem_IOCity_IOCity_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional string card_holder_year = 1;
  inline bool has_card_holder_year() const;
  inline void clear_card_holder_year();
  static const int kCardHolderYearFieldNumber = 1;
  inline const ::std::string& card_holder_year() const;
  inline void set_card_holder_year(const ::std::string& value);
  inline void set_card_holder_year(const char* value);
  inline void set_card_holder_year(const char* value, size_t size);
  inline ::std::string* mutable_card_holder_year();
  inline ::std::string* release_card_holder_year();
  inline void set_allocated_card_holder_year(::std::string* card_holder_year);

  // optional string card_holder_month = 2;
  inline bool has_card_holder_month() const;
  inline void clear_card_holder_month();
  static const int kCardHolderMonthFieldNumber = 2;
  inline const ::std::string& card_holder_month() const;
  inline void set_card_holder_month(const ::std::string& value);
  inline void set_card_holder_month(const char* value);
  inline void set_card_holder_month(const char* value, size_t size);
  inline ::std::string* mutable_card_holder_month();
  inline ::std::string* release_card_holder_month();
  inline void set_allocated_card_holder_month(::std::string* card_holder_month);

  // optional string card_holder_number = 3;
  inline bool has_card_holder_number() const;
  inline void clear_card_holder_number();
  static const int kCardHolderNumberFieldNumber = 3;
  inline const ::std::string& card_holder_number() const;
  inline void set_card_holder_number(const ::std::string& value);
  inline void set_card_holder_number(const char* value);
  inline void set_card_holder_number(const char* value, size_t size);
  inline ::std::string* mutable_card_holder_number();
  inline ::std::string* release_card_holder_number();
  inline void set_allocated_card_holder_number(::std::string* card_holder_number);

  // optional string card_holder_name = 4;
  inline bool has_card_holder_name() const;
  inline void clear_card_holder_name();
  static const int kCardHolderNameFieldNumber = 4;
  inline const ::std::string& card_holder_name() const;
  inline void set_card_holder_name(const ::std::string& value);
  inline void set_card_holder_name(const char* value);
  inline void set_card_holder_name(const char* value, size_t size);
  inline ::std::string* mutable_card_holder_name();
  inline ::std::string* release_card_holder_name();
  inline void set_allocated_card_holder_name(::std::string* card_holder_name);

  // optional string bankId = 5;
  inline bool has_bankid() const;
  inline void clear_bankid();
  static const int kBankIdFieldNumber = 5;
  inline const ::std::string& bankid() const;
  inline void set_bankid(const ::std::string& value);
  inline void set_bankid(const char* value);
  inline void set_bankid(const char* value, size_t size);
  inline ::std::string* mutable_bankid();
  inline ::std::string* release_bankid();
  inline void set_allocated_bankid(::std::string* bankid);

  // optional uint64 amount = 6;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 6;
  inline ::google::protobuf::uint64 amount() const;
  inline void set_amount(::google::protobuf::uint64 value);

  // optional uint32 locked_type = 7;
  inline bool has_locked_type() const;
  inline void clear_locked_type();
  static const int kLockedTypeFieldNumber = 7;
  inline ::google::protobuf::uint32 locked_type() const;
  inline void set_locked_type(::google::protobuf::uint32 value);

  // optional uint32 bank_type = 8;
  inline bool has_bank_type() const;
  inline void clear_bank_type();
  static const int kBankTypeFieldNumber = 8;
  inline ::google::protobuf::uint32 bank_type() const;
  inline void set_bank_type(::google::protobuf::uint32 value);

  // optional string bank_name = 9;
  inline bool has_bank_name() const;
  inline void clear_bank_name();
  static const int kBankNameFieldNumber = 9;
  inline const ::std::string& bank_name() const;
  inline void set_bank_name(const ::std::string& value);
  inline void set_bank_name(const char* value);
  inline void set_bank_name(const char* value, size_t size);
  inline ::std::string* mutable_bank_name();
  inline ::std::string* release_bank_name();
  inline void set_allocated_bank_name(::std::string* bank_name);

  // optional uint32 row_id = 10;
  inline bool has_row_id() const;
  inline void clear_row_id();
  static const int kRowIdFieldNumber = 10;
  inline ::google::protobuf::uint32 row_id() const;
  inline void set_row_id(::google::protobuf::uint32 value);

  // optional uint64 last_sync_time = 11;
  inline bool has_last_sync_time() const;
  inline void clear_last_sync_time();
  static const int kLastSyncTimeFieldNumber = 11;
  inline ::google::protobuf::uint64 last_sync_time() const;
  inline void set_last_sync_time(::google::protobuf::uint64 value);

  // optional uint32 status = 12;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 12;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // optional uint32 channel = 13;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 13;
  inline ::google::protobuf::uint32 channel() const;
  inline void set_channel(::google::protobuf::uint32 value);

  // optional uint32 io_city = 14;
  inline bool has_io_city() const;
  inline void clear_io_city();
  static const int kIoCityFieldNumber = 14;
  inline ::google::protobuf::uint32 io_city() const;
  inline void set_io_city(::google::protobuf::uint32 value);

  // optional uint32 tran_type = 15;
  inline bool has_tran_type() const;
  inline void clear_tran_type();
  static const int kTranTypeFieldNumber = 15;
  inline ::google::protobuf::uint32 tran_type() const;
  inline void set_tran_type(::google::protobuf::uint32 value);

  // optional string cardId = 16;
  inline bool has_cardid() const;
  inline void clear_cardid();
  static const int kCardIdFieldNumber = 16;
  inline const ::std::string& cardid() const;
  inline void set_cardid(const ::std::string& value);
  inline void set_cardid(const char* value);
  inline void set_cardid(const char* value, size_t size);
  inline ::std::string* mutable_cardid();
  inline ::std::string* release_cardid();
  inline void set_allocated_cardid(::std::string* cardid);

  // optional string cardType = 17;
  inline bool has_cardtype() const;
  inline void clear_cardtype();
  static const int kCardTypeFieldNumber = 17;
  inline const ::std::string& cardtype() const;
  inline void set_cardtype(const ::std::string& value);
  inline void set_cardtype(const char* value);
  inline void set_cardtype(const char* value, size_t size);
  inline ::std::string* mutable_cardtype();
  inline ::std::string* release_cardtype();
  inline void set_allocated_cardtype(::std::string* cardtype);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.CardItem)
 private:
  inline void set_has_card_holder_year();
  inline void clear_has_card_holder_year();
  inline void set_has_card_holder_month();
  inline void clear_has_card_holder_month();
  inline void set_has_card_holder_number();
  inline void clear_has_card_holder_number();
  inline void set_has_card_holder_name();
  inline void clear_has_card_holder_name();
  inline void set_has_bankid();
  inline void clear_has_bankid();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_locked_type();
  inline void clear_has_locked_type();
  inline void set_has_bank_type();
  inline void clear_has_bank_type();
  inline void set_has_bank_name();
  inline void clear_has_bank_name();
  inline void set_has_row_id();
  inline void clear_has_row_id();
  inline void set_has_last_sync_time();
  inline void clear_has_last_sync_time();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_io_city();
  inline void clear_has_io_city();
  inline void set_has_tran_type();
  inline void clear_has_tran_type();
  inline void set_has_cardid();
  inline void clear_has_cardid();
  inline void set_has_cardtype();
  inline void clear_has_cardtype();

  ::std::string* card_holder_year_;
  ::std::string* card_holder_month_;
  ::std::string* card_holder_number_;
  ::std::string* card_holder_name_;
  ::std::string* bankid_;
  ::google::protobuf::uint64 amount_;
  ::google::protobuf::uint32 locked_type_;
  ::google::protobuf::uint32 bank_type_;
  ::std::string* bank_name_;
  ::google::protobuf::uint64 last_sync_time_;
  ::google::protobuf::uint32 row_id_;
  ::google::protobuf::uint32 status_;
  ::google::protobuf::uint32 channel_;
  ::google::protobuf::uint32 io_city_;
  ::std::string* cardid_;
  ::std::string* cardtype_;
  ::google::protobuf::uint32 tran_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(17 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static CardItem* default_instance_;
};
// -------------------------------------------------------------------

class CardAddOrUpdate : public ::google::protobuf::MessageLite {
 public:
  CardAddOrUpdate();
  virtual ~CardAddOrUpdate();

  CardAddOrUpdate(const CardAddOrUpdate& from);

  inline CardAddOrUpdate& operator=(const CardAddOrUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  static const CardAddOrUpdate& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CardAddOrUpdate* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CardAddOrUpdate* other);

  // implements Message ----------------------------------------------

  CardAddOrUpdate* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CardAddOrUpdate& from);
  void MergeFrom(const CardAddOrUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.mservice.momo.msg.CardItem card_list = 1;
  inline int card_list_size() const;
  inline void clear_card_list();
  static const int kCardListFieldNumber = 1;
  inline const ::com::mservice::momo::msg::CardItem& card_list(int index) const;
  inline ::com::mservice::momo::msg::CardItem* mutable_card_list(int index);
  inline ::com::mservice::momo::msg::CardItem* add_card_list();
  inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::CardItem >&
      card_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::CardItem >*
      mutable_card_list();

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.CardAddOrUpdate)
 private:

  ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::CardItem > card_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static CardAddOrUpdate* default_instance_;
};
// -------------------------------------------------------------------

class CardAddOrUpdateReply : public ::google::protobuf::MessageLite {
 public:
  CardAddOrUpdateReply();
  virtual ~CardAddOrUpdateReply();

  CardAddOrUpdateReply(const CardAddOrUpdateReply& from);

  inline CardAddOrUpdateReply& operator=(const CardAddOrUpdateReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const CardAddOrUpdateReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CardAddOrUpdateReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CardAddOrUpdateReply* other);

  // implements Message ----------------------------------------------

  CardAddOrUpdateReply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CardAddOrUpdateReply& from);
  void MergeFrom(const CardAddOrUpdateReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.mservice.momo.msg.CardItem bank_net_to_momo_list = 1;
  inline int bank_net_to_momo_list_size() const;
  inline void clear_bank_net_to_momo_list();
  static const int kBankNetToMomoListFieldNumber = 1;
  inline const ::com::mservice::momo::msg::CardItem& bank_net_to_momo_list(int index) const;
  inline ::com::mservice::momo::msg::CardItem* mutable_bank_net_to_momo_list(int index);
  inline ::com::mservice::momo::msg::CardItem* add_bank_net_to_momo_list();
  inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::CardItem >&
      bank_net_to_momo_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::CardItem >*
      mutable_bank_net_to_momo_list();

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.CardAddOrUpdateReply)
 private:

  ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::CardItem > bank_net_to_momo_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static CardAddOrUpdateReply* default_instance_;
};
// -------------------------------------------------------------------

class CardSyncFirstTimeReply : public ::google::protobuf::MessageLite {
 public:
  CardSyncFirstTimeReply();
  virtual ~CardSyncFirstTimeReply();

  CardSyncFirstTimeReply(const CardSyncFirstTimeReply& from);

  inline CardSyncFirstTimeReply& operator=(const CardSyncFirstTimeReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const CardSyncFirstTimeReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CardSyncFirstTimeReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CardSyncFirstTimeReply* other);

  // implements Message ----------------------------------------------

  CardSyncFirstTimeReply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CardSyncFirstTimeReply& from);
  void MergeFrom(const CardSyncFirstTimeReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.mservice.momo.msg.CardItem CardList = 1;
  inline int cardlist_size() const;
  inline void clear_cardlist();
  static const int kCardListFieldNumber = 1;
  inline const ::com::mservice::momo::msg::CardItem& cardlist(int index) const;
  inline ::com::mservice::momo::msg::CardItem* mutable_cardlist(int index);
  inline ::com::mservice::momo::msg::CardItem* add_cardlist();
  inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::CardItem >&
      cardlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::CardItem >*
      mutable_cardlist();

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.CardSyncFirstTimeReply)
 private:

  ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::CardItem > cardlist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static CardSyncFirstTimeReply* default_instance_;
};
// -------------------------------------------------------------------

class TranHisSyncReply : public ::google::protobuf::MessageLite {
 public:
  TranHisSyncReply();
  virtual ~TranHisSyncReply();

  TranHisSyncReply(const TranHisSyncReply& from);

  inline TranHisSyncReply& operator=(const TranHisSyncReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const TranHisSyncReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TranHisSyncReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TranHisSyncReply* other);

  // implements Message ----------------------------------------------

  TranHisSyncReply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TranHisSyncReply& from);
  void MergeFrom(const TranHisSyncReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline bool result() const;
  inline void set_result(bool value);

  // repeated .com.mservice.momo.msg.TranHisV1 TranList = 2;
  inline int tranlist_size() const;
  inline void clear_tranlist();
  static const int kTranListFieldNumber = 2;
  inline const ::com::mservice::momo::msg::TranHisV1& tranlist(int index) const;
  inline ::com::mservice::momo::msg::TranHisV1* mutable_tranlist(int index);
  inline ::com::mservice::momo::msg::TranHisV1* add_tranlist();
  inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::TranHisV1 >&
      tranlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::TranHisV1 >*
      mutable_tranlist();

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.TranHisSyncReply)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::TranHisV1 > tranlist_;
  bool result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static TranHisSyncReply* default_instance_;
};
// -------------------------------------------------------------------

class Bill : public ::google::protobuf::MessageLite {
 public:
  Bill();
  virtual ~Bill();

  Bill(const Bill& from);

  inline Bill& operator=(const Bill& from) {
    CopyFrom(from);
    return *this;
  }

  static const Bill& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Bill* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Bill* other);

  // implements Message ----------------------------------------------

  Bill* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Bill& from);
  void MergeFrom(const Bill& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string providerId = 1;
  inline bool has_providerid() const;
  inline void clear_providerid();
  static const int kProviderIdFieldNumber = 1;
  inline const ::std::string& providerid() const;
  inline void set_providerid(const ::std::string& value);
  inline void set_providerid(const char* value);
  inline void set_providerid(const char* value, size_t size);
  inline ::std::string* mutable_providerid();
  inline ::std::string* release_providerid();
  inline void set_allocated_providerid(::std::string* providerid);

  // optional string billId = 2;
  inline bool has_billid() const;
  inline void clear_billid();
  static const int kBillIdFieldNumber = 2;
  inline const ::std::string& billid() const;
  inline void set_billid(const ::std::string& value);
  inline void set_billid(const char* value);
  inline void set_billid(const char* value, size_t size);
  inline ::std::string* mutable_billid();
  inline ::std::string* release_billid();
  inline void set_allocated_billid(::std::string* billid);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.Bill)
 private:
  inline void set_has_providerid();
  inline void clear_has_providerid();
  inline void set_has_billid();
  inline void clear_has_billid();

  ::std::string* providerid_;
  ::std::string* billid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static Bill* default_instance_;
};
// -------------------------------------------------------------------

class RemoveSavedBill : public ::google::protobuf::MessageLite {
 public:
  RemoveSavedBill();
  virtual ~RemoveSavedBill();

  RemoveSavedBill(const RemoveSavedBill& from);

  inline RemoveSavedBill& operator=(const RemoveSavedBill& from) {
    CopyFrom(from);
    return *this;
  }

  static const RemoveSavedBill& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RemoveSavedBill* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RemoveSavedBill* other);

  // implements Message ----------------------------------------------

  RemoveSavedBill* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RemoveSavedBill& from);
  void MergeFrom(const RemoveSavedBill& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.mservice.momo.msg.Bill bills = 1;
  inline int bills_size() const;
  inline void clear_bills();
  static const int kBillsFieldNumber = 1;
  inline const ::com::mservice::momo::msg::Bill& bills(int index) const;
  inline ::com::mservice::momo::msg::Bill* mutable_bills(int index);
  inline ::com::mservice::momo::msg::Bill* add_bills();
  inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::Bill >&
      bills() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::Bill >*
      mutable_bills();

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.RemoveSavedBill)
 private:

  ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::Bill > bills_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static RemoveSavedBill* default_instance_;
};
// -------------------------------------------------------------------

class RemoveSavedBillReply : public ::google::protobuf::MessageLite {
 public:
  RemoveSavedBillReply();
  virtual ~RemoveSavedBillReply();

  RemoveSavedBillReply(const RemoveSavedBillReply& from);

  inline RemoveSavedBillReply& operator=(const RemoveSavedBillReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const RemoveSavedBillReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RemoveSavedBillReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RemoveSavedBillReply* other);

  // implements Message ----------------------------------------------

  RemoveSavedBillReply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RemoveSavedBillReply& from);
  void MergeFrom(const RemoveSavedBillReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef RemoveSavedBillReply_Result Result;
  static const Result SUCCESS = RemoveSavedBillReply_Result_SUCCESS;
  static const Result FAIL = RemoveSavedBillReply_Result_FAIL;
  static inline bool Result_IsValid(int value) {
    return RemoveSavedBillReply_Result_IsValid(value);
  }
  static const Result Result_MIN =
    RemoveSavedBillReply_Result_Result_MIN;
  static const Result Result_MAX =
    RemoveSavedBillReply_Result_Result_MAX;
  static const int Result_ARRAYSIZE =
    RemoveSavedBillReply_Result_Result_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .com.mservice.momo.msg.RemoveSavedBillReply.Result result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::com::mservice::momo::msg::RemoveSavedBillReply_Result result() const;
  inline void set_result(::com::mservice::momo::msg::RemoveSavedBillReply_Result value);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.RemoveSavedBillReply)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static RemoveSavedBillReply* default_instance_;
};
// -------------------------------------------------------------------

class Notification : public ::google::protobuf::MessageLite {
 public:
  Notification();
  virtual ~Notification();

  Notification(const Notification& from);

  inline Notification& operator=(const Notification& from) {
    CopyFrom(from);
    return *this;
  }

  static const Notification& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Notification* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Notification* other);

  // implements Message ----------------------------------------------

  Notification* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Notification& from);
  void MergeFrom(const Notification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional uint32 priority = 2;
  inline bool has_priority() const;
  inline void clear_priority();
  static const int kPriorityFieldNumber = 2;
  inline ::google::protobuf::uint32 priority() const;
  inline void set_priority(::google::protobuf::uint32 value);

  // optional uint32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional string caption = 4;
  inline bool has_caption() const;
  inline void clear_caption();
  static const int kCaptionFieldNumber = 4;
  inline const ::std::string& caption() const;
  inline void set_caption(const ::std::string& value);
  inline void set_caption(const char* value);
  inline void set_caption(const char* value, size_t size);
  inline ::std::string* mutable_caption();
  inline ::std::string* release_caption();
  inline void set_allocated_caption(::std::string* caption);

  // optional string body = 5;
  inline bool has_body() const;
  inline void clear_body();
  static const int kBodyFieldNumber = 5;
  inline const ::std::string& body() const;
  inline void set_body(const ::std::string& value);
  inline void set_body(const char* value);
  inline void set_body(const char* value, size_t size);
  inline ::std::string* mutable_body();
  inline ::std::string* release_body();
  inline void set_allocated_body(::std::string* body);

  // optional uint64 tranId = 6;
  inline bool has_tranid() const;
  inline void clear_tranid();
  static const int kTranIdFieldNumber = 6;
  inline ::google::protobuf::uint64 tranid() const;
  inline void set_tranid(::google::protobuf::uint64 value);

  // optional uint64 cmdId = 7;
  inline bool has_cmdid() const;
  inline void clear_cmdid();
  static const int kCmdIdFieldNumber = 7;
  inline ::google::protobuf::uint64 cmdid() const;
  inline void set_cmdid(::google::protobuf::uint64 value);

  // optional uint64 time = 8;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 8;
  inline ::google::protobuf::uint64 time() const;
  inline void set_time(::google::protobuf::uint64 value);

  // optional uint32 sender = 9;
  inline bool has_sender() const;
  inline void clear_sender();
  static const int kSenderFieldNumber = 9;
  inline ::google::protobuf::uint32 sender() const;
  inline void set_sender(::google::protobuf::uint32 value);

  // optional uint32 status = 10;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 10;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // optional uint32 tranHisType = 11;
  inline bool has_tranhistype() const;
  inline void clear_tranhistype();
  static const int kTranHisTypeFieldNumber = 11;
  inline ::google::protobuf::uint32 tranhistype() const;
  inline void set_tranhistype(::google::protobuf::uint32 value);

  // optional string refId = 12;
  inline bool has_refid() const;
  inline void clear_refid();
  static const int kRefIdFieldNumber = 12;
  inline const ::std::string& refid() const;
  inline void set_refid(const ::std::string& value);
  inline void set_refid(const char* value);
  inline void set_refid(const char* value, size_t size);
  inline ::std::string* mutable_refid();
  inline ::std::string* release_refid();
  inline void set_allocated_refid(::std::string* refid);

  // optional string btnTitle = 13;
  inline bool has_btntitle() const;
  inline void clear_btntitle();
  static const int kBtnTitleFieldNumber = 13;
  inline const ::std::string& btntitle() const;
  inline void set_btntitle(const ::std::string& value);
  inline void set_btntitle(const char* value);
  inline void set_btntitle(const char* value, size_t size);
  inline ::std::string* mutable_btntitle();
  inline ::std::string* release_btntitle();
  inline void set_allocated_btntitle(::std::string* btntitle);

  // optional uint32 btnStatus = 14;
  inline bool has_btnstatus() const;
  inline void clear_btnstatus();
  static const int kBtnStatusFieldNumber = 14;
  inline ::google::protobuf::uint32 btnstatus() const;
  inline void set_btnstatus(::google::protobuf::uint32 value);

  // optional string htmlBody = 15;
  inline bool has_htmlbody() const;
  inline void clear_htmlbody();
  static const int kHtmlBodyFieldNumber = 15;
  inline const ::std::string& htmlbody() const;
  inline void set_htmlbody(const ::std::string& value);
  inline void set_htmlbody(const char* value);
  inline void set_htmlbody(const char* value, size_t size);
  inline ::std::string* mutable_htmlbody();
  inline ::std::string* release_htmlbody();
  inline void set_allocated_htmlbody(::std::string* htmlbody);

  // optional string extra = 16;
  inline bool has_extra() const;
  inline void clear_extra();
  static const int kExtraFieldNumber = 16;
  inline const ::std::string& extra() const;
  inline void set_extra(const ::std::string& value);
  inline void set_extra(const char* value);
  inline void set_extra(const char* value, size_t size);
  inline ::std::string* mutable_extra();
  inline ::std::string* release_extra();
  inline void set_allocated_extra(::std::string* extra);

  // optional uint32 category = 17;
  inline bool has_category() const;
  inline void clear_category();
  static const int kCategoryFieldNumber = 17;
  inline ::google::protobuf::uint32 category() const;
  inline void set_category(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.Notification)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_priority();
  inline void clear_has_priority();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_caption();
  inline void clear_has_caption();
  inline void set_has_body();
  inline void clear_has_body();
  inline void set_has_tranid();
  inline void clear_has_tranid();
  inline void set_has_cmdid();
  inline void clear_has_cmdid();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_sender();
  inline void clear_has_sender();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_tranhistype();
  inline void clear_has_tranhistype();
  inline void set_has_refid();
  inline void clear_has_refid();
  inline void set_has_btntitle();
  inline void clear_has_btntitle();
  inline void set_has_btnstatus();
  inline void clear_has_btnstatus();
  inline void set_has_htmlbody();
  inline void clear_has_htmlbody();
  inline void set_has_extra();
  inline void clear_has_extra();
  inline void set_has_category();
  inline void clear_has_category();

  ::std::string* id_;
  ::google::protobuf::uint32 priority_;
  ::google::protobuf::uint32 type_;
  ::std::string* caption_;
  ::std::string* body_;
  ::google::protobuf::uint64 tranid_;
  ::google::protobuf::uint64 cmdid_;
  ::google::protobuf::uint64 time_;
  ::google::protobuf::uint32 sender_;
  ::google::protobuf::uint32 status_;
  ::std::string* refid_;
  ::google::protobuf::uint32 tranhistype_;
  ::google::protobuf::uint32 btnstatus_;
  ::std::string* btntitle_;
  ::std::string* htmlbody_;
  ::std::string* extra_;
  ::google::protobuf::uint32 category_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(17 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static Notification* default_instance_;
};
// -------------------------------------------------------------------

class UpdateNotificationsStatus : public ::google::protobuf::MessageLite {
 public:
  UpdateNotificationsStatus();
  virtual ~UpdateNotificationsStatus();

  UpdateNotificationsStatus(const UpdateNotificationsStatus& from);

  inline UpdateNotificationsStatus& operator=(const UpdateNotificationsStatus& from) {
    CopyFrom(from);
    return *this;
  }

  static const UpdateNotificationsStatus& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UpdateNotificationsStatus* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UpdateNotificationsStatus* other);

  // implements Message ----------------------------------------------

  UpdateNotificationsStatus* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UpdateNotificationsStatus& from);
  void MergeFrom(const UpdateNotificationsStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.mservice.momo.msg.Notification notifications = 1;
  inline int notifications_size() const;
  inline void clear_notifications();
  static const int kNotificationsFieldNumber = 1;
  inline const ::com::mservice::momo::msg::Notification& notifications(int index) const;
  inline ::com::mservice::momo::msg::Notification* mutable_notifications(int index);
  inline ::com::mservice::momo::msg::Notification* add_notifications();
  inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::Notification >&
      notifications() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::Notification >*
      mutable_notifications();

  // optional uint32 flag = 2;
  inline bool has_flag() const;
  inline void clear_flag();
  static const int kFlagFieldNumber = 2;
  inline ::google::protobuf::uint32 flag() const;
  inline void set_flag(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.UpdateNotificationsStatus)
 private:
  inline void set_has_flag();
  inline void clear_has_flag();

  ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::Notification > notifications_;
  ::google::protobuf::uint32 flag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static UpdateNotificationsStatus* default_instance_;
};
// -------------------------------------------------------------------

class UpdateNotificationsStatusReply : public ::google::protobuf::MessageLite {
 public:
  UpdateNotificationsStatusReply();
  virtual ~UpdateNotificationsStatusReply();

  UpdateNotificationsStatusReply(const UpdateNotificationsStatusReply& from);

  inline UpdateNotificationsStatusReply& operator=(const UpdateNotificationsStatusReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const UpdateNotificationsStatusReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UpdateNotificationsStatusReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UpdateNotificationsStatusReply* other);

  // implements Message ----------------------------------------------

  UpdateNotificationsStatusReply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UpdateNotificationsStatusReply& from);
  void MergeFrom(const UpdateNotificationsStatusReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.mservice.momo.msg.Notification notifications = 1;
  inline int notifications_size() const;
  inline void clear_notifications();
  static const int kNotificationsFieldNumber = 1;
  inline const ::com::mservice::momo::msg::Notification& notifications(int index) const;
  inline ::com::mservice::momo::msg::Notification* mutable_notifications(int index);
  inline ::com::mservice::momo::msg::Notification* add_notifications();
  inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::Notification >&
      notifications() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::Notification >*
      mutable_notifications();

  // optional uint32 flag = 2;
  inline bool has_flag() const;
  inline void clear_flag();
  static const int kFlagFieldNumber = 2;
  inline ::google::protobuf::uint32 flag() const;
  inline void set_flag(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.UpdateNotificationsStatusReply)
 private:
  inline void set_has_flag();
  inline void clear_has_flag();

  ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::Notification > notifications_;
  ::google::protobuf::uint32 flag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static UpdateNotificationsStatusReply* default_instance_;
};
// -------------------------------------------------------------------

class NotificationSyncReply : public ::google::protobuf::MessageLite {
 public:
  NotificationSyncReply();
  virtual ~NotificationSyncReply();

  NotificationSyncReply(const NotificationSyncReply& from);

  inline NotificationSyncReply& operator=(const NotificationSyncReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const NotificationSyncReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotificationSyncReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotificationSyncReply* other);

  // implements Message ----------------------------------------------

  NotificationSyncReply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotificationSyncReply& from);
  void MergeFrom(const NotificationSyncReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.mservice.momo.msg.Notification notifications = 1;
  inline int notifications_size() const;
  inline void clear_notifications();
  static const int kNotificationsFieldNumber = 1;
  inline const ::com::mservice::momo::msg::Notification& notifications(int index) const;
  inline ::com::mservice::momo::msg::Notification* mutable_notifications(int index);
  inline ::com::mservice::momo::msg::Notification* add_notifications();
  inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::Notification >&
      notifications() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::Notification >*
      mutable_notifications();

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.NotificationSyncReply)
 private:

  ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::Notification > notifications_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static NotificationSyncReply* default_instance_;
};
// -------------------------------------------------------------------

class NotificationNew : public ::google::protobuf::MessageLite {
 public:
  NotificationNew();
  virtual ~NotificationNew();

  NotificationNew(const NotificationNew& from);

  inline NotificationNew& operator=(const NotificationNew& from) {
    CopyFrom(from);
    return *this;
  }

  static const NotificationNew& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotificationNew* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotificationNew* other);

  // implements Message ----------------------------------------------

  NotificationNew* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotificationNew& from);
  void MergeFrom(const NotificationNew& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .com.mservice.momo.msg.Notification notification = 1;
  inline bool has_notification() const;
  inline void clear_notification();
  static const int kNotificationFieldNumber = 1;
  inline const ::com::mservice::momo::msg::Notification& notification() const;
  inline ::com::mservice::momo::msg::Notification* mutable_notification();
  inline ::com::mservice::momo::msg::Notification* release_notification();
  inline void set_allocated_notification(::com::mservice::momo::msg::Notification* notification);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.NotificationNew)
 private:
  inline void set_has_notification();
  inline void clear_has_notification();

  ::com::mservice::momo::msg::Notification* notification_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static NotificationNew* default_instance_;
};
// -------------------------------------------------------------------

class NotificationReceived : public ::google::protobuf::MessageLite {
 public:
  NotificationReceived();
  virtual ~NotificationReceived();

  NotificationReceived(const NotificationReceived& from);

  inline NotificationReceived& operator=(const NotificationReceived& from) {
    CopyFrom(from);
    return *this;
  }

  static const NotificationReceived& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotificationReceived* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotificationReceived* other);

  // implements Message ----------------------------------------------

  NotificationReceived* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotificationReceived& from);
  void MergeFrom(const NotificationReceived& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string notificationId = 1;
  inline bool has_notificationid() const;
  inline void clear_notificationid();
  static const int kNotificationIdFieldNumber = 1;
  inline const ::std::string& notificationid() const;
  inline void set_notificationid(const ::std::string& value);
  inline void set_notificationid(const char* value);
  inline void set_notificationid(const char* value, size_t size);
  inline ::std::string* mutable_notificationid();
  inline ::std::string* release_notificationid();
  inline void set_allocated_notificationid(::std::string* notificationid);

  // repeated .com.mservice.momo.msg.Notification noti = 2;
  inline int noti_size() const;
  inline void clear_noti();
  static const int kNotiFieldNumber = 2;
  inline const ::com::mservice::momo::msg::Notification& noti(int index) const;
  inline ::com::mservice::momo::msg::Notification* mutable_noti(int index);
  inline ::com::mservice::momo::msg::Notification* add_noti();
  inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::Notification >&
      noti() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::Notification >*
      mutable_noti();

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.NotificationReceived)
 private:
  inline void set_has_notificationid();
  inline void clear_has_notificationid();

  ::std::string* notificationid_;
  ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::Notification > noti_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static NotificationReceived* default_instance_;
};
// -------------------------------------------------------------------

class GetNotification : public ::google::protobuf::MessageLite {
 public:
  GetNotification();
  virtual ~GetNotification();

  GetNotification(const GetNotification& from);

  inline GetNotification& operator=(const GetNotification& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetNotification& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetNotification* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetNotification* other);

  // implements Message ----------------------------------------------

  GetNotification* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetNotification& from);
  void MergeFrom(const GetNotification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string notiId = 1;
  inline bool has_notiid() const;
  inline void clear_notiid();
  static const int kNotiIdFieldNumber = 1;
  inline const ::std::string& notiid() const;
  inline void set_notiid(const ::std::string& value);
  inline void set_notiid(const char* value);
  inline void set_notiid(const char* value, size_t size);
  inline ::std::string* mutable_notiid();
  inline ::std::string* release_notiid();
  inline void set_allocated_notiid(::std::string* notiid);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.GetNotification)
 private:
  inline void set_has_notiid();
  inline void clear_has_notiid();

  ::std::string* notiid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static GetNotification* default_instance_;
};
// -------------------------------------------------------------------

class GetNotificationReply : public ::google::protobuf::MessageLite {
 public:
  GetNotificationReply();
  virtual ~GetNotificationReply();

  GetNotificationReply(const GetNotificationReply& from);

  inline GetNotificationReply& operator=(const GetNotificationReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetNotificationReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetNotificationReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetNotificationReply* other);

  // implements Message ----------------------------------------------

  GetNotificationReply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetNotificationReply& from);
  void MergeFrom(const GetNotificationReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .com.mservice.momo.msg.Notification noti = 1;
  inline bool has_noti() const;
  inline void clear_noti();
  static const int kNotiFieldNumber = 1;
  inline const ::com::mservice::momo::msg::Notification& noti() const;
  inline ::com::mservice::momo::msg::Notification* mutable_noti();
  inline ::com::mservice::momo::msg::Notification* release_noti();
  inline void set_allocated_noti(::com::mservice::momo::msg::Notification* noti);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.GetNotificationReply)
 private:
  inline void set_has_noti();
  inline void clear_has_noti();

  ::com::mservice::momo::msg::Notification* noti_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static GetNotificationReply* default_instance_;
};
// -------------------------------------------------------------------

class Avatar : public ::google::protobuf::MessageLite {
 public:
  Avatar();
  virtual ~Avatar();

  Avatar(const Avatar& from);

  inline Avatar& operator=(const Avatar& from) {
    CopyFrom(from);
    return *this;
  }

  static const Avatar& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Avatar* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Avatar* other);

  // implements Message ----------------------------------------------

  Avatar* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Avatar& from);
  void MergeFrom(const Avatar& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string byte_string = 1;
  inline bool has_byte_string() const;
  inline void clear_byte_string();
  static const int kByteStringFieldNumber = 1;
  inline const ::std::string& byte_string() const;
  inline void set_byte_string(const ::std::string& value);
  inline void set_byte_string(const char* value);
  inline void set_byte_string(const char* value, size_t size);
  inline ::std::string* mutable_byte_string();
  inline ::std::string* release_byte_string();
  inline void set_allocated_byte_string(::std::string* byte_string);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.Avatar)
 private:
  inline void set_has_byte_string();
  inline void clear_has_byte_string();

  ::std::string* byte_string_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static Avatar* default_instance_;
};
// -------------------------------------------------------------------

class AvatarReply : public ::google::protobuf::MessageLite {
 public:
  AvatarReply();
  virtual ~AvatarReply();

  AvatarReply(const AvatarReply& from);

  inline AvatarReply& operator=(const AvatarReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const AvatarReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AvatarReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AvatarReply* other);

  // implements Message ----------------------------------------------

  AvatarReply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AvatarReply& from);
  void MergeFrom(const AvatarReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline bool result() const;
  inline void set_result(bool value);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.AvatarReply)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  bool result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static AvatarReply* default_instance_;
};
// -------------------------------------------------------------------

class AvatarUploadReply : public ::google::protobuf::MessageLite {
 public:
  AvatarUploadReply();
  virtual ~AvatarUploadReply();

  AvatarUploadReply(const AvatarUploadReply& from);

  inline AvatarUploadReply& operator=(const AvatarUploadReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const AvatarUploadReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AvatarUploadReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AvatarUploadReply* other);

  // implements Message ----------------------------------------------

  AvatarUploadReply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AvatarUploadReply& from);
  void MergeFrom(const AvatarUploadReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string token = 1;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 1;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.AvatarUploadReply)
 private:
  inline void set_has_token();
  inline void clear_has_token();

  ::std::string* token_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static AvatarUploadReply* default_instance_;
};
// -------------------------------------------------------------------

class GetDynamicConfig : public ::google::protobuf::MessageLite {
 public:
  GetDynamicConfig();
  virtual ~GetDynamicConfig();

  GetDynamicConfig(const GetDynamicConfig& from);

  inline GetDynamicConfig& operator=(const GetDynamicConfig& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetDynamicConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetDynamicConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetDynamicConfig* other);

  // implements Message ----------------------------------------------

  GetDynamicConfig* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetDynamicConfig& from);
  void MergeFrom(const GetDynamicConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.GetDynamicConfig)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static GetDynamicConfig* default_instance_;
};
// -------------------------------------------------------------------

class GetDynamicConfigReply : public ::google::protobuf::MessageLite {
 public:
  GetDynamicConfigReply();
  virtual ~GetDynamicConfigReply();

  GetDynamicConfigReply(const GetDynamicConfigReply& from);

  inline GetDynamicConfigReply& operator=(const GetDynamicConfigReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetDynamicConfigReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetDynamicConfigReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetDynamicConfigReply* other);

  // implements Message ----------------------------------------------

  GetDynamicConfigReply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetDynamicConfigReply& from);
  void MergeFrom(const GetDynamicConfigReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.GetDynamicConfigReply)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();

  ::std::string* name_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static GetDynamicConfigReply* default_instance_;
};
// -------------------------------------------------------------------

class GetSmartLinkUrl : public ::google::protobuf::MessageLite {
 public:
  GetSmartLinkUrl();
  virtual ~GetSmartLinkUrl();

  GetSmartLinkUrl(const GetSmartLinkUrl& from);

  inline GetSmartLinkUrl& operator=(const GetSmartLinkUrl& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetSmartLinkUrl& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetSmartLinkUrl* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetSmartLinkUrl* other);

  // implements Message ----------------------------------------------

  GetSmartLinkUrl* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetSmartLinkUrl& from);
  void MergeFrom(const GetSmartLinkUrl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 amount = 1;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 1;
  inline ::google::protobuf::uint64 amount() const;
  inline void set_amount(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.GetSmartLinkUrl)
 private:
  inline void set_has_amount();
  inline void clear_has_amount();

  ::google::protobuf::uint64 amount_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static GetSmartLinkUrl* default_instance_;
};
// -------------------------------------------------------------------

class GetSmartLinkUrlReply : public ::google::protobuf::MessageLite {
 public:
  GetSmartLinkUrlReply();
  virtual ~GetSmartLinkUrlReply();

  GetSmartLinkUrlReply(const GetSmartLinkUrlReply& from);

  inline GetSmartLinkUrlReply& operator=(const GetSmartLinkUrlReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetSmartLinkUrlReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetSmartLinkUrlReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetSmartLinkUrlReply* other);

  // implements Message ----------------------------------------------

  GetSmartLinkUrlReply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetSmartLinkUrlReply& from);
  void MergeFrom(const GetSmartLinkUrlReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string url = 1;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 1;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.GetSmartLinkUrlReply)
 private:
  inline void set_has_url();
  inline void clear_has_url();

  ::std::string* url_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static GetSmartLinkUrlReply* default_instance_;
};
// -------------------------------------------------------------------

class StoreRateInfo : public ::google::protobuf::MessageLite {
 public:
  StoreRateInfo();
  virtual ~StoreRateInfo();

  StoreRateInfo(const StoreRateInfo& from);

  inline StoreRateInfo& operator=(const StoreRateInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const StoreRateInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StoreRateInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StoreRateInfo* other);

  // implements Message ----------------------------------------------

  StoreRateInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StoreRateInfo& from);
  void MergeFrom(const StoreRateInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 storeId = 1;
  inline bool has_storeid() const;
  inline void clear_storeid();
  static const int kStoreIdFieldNumber = 1;
  inline ::google::protobuf::int32 storeid() const;
  inline void set_storeid(::google::protobuf::int32 value);

  // required int32 s1 = 2;
  inline bool has_s1() const;
  inline void clear_s1();
  static const int kS1FieldNumber = 2;
  inline ::google::protobuf::int32 s1() const;
  inline void set_s1(::google::protobuf::int32 value);

  // required int32 s2 = 3;
  inline bool has_s2() const;
  inline void clear_s2();
  static const int kS2FieldNumber = 3;
  inline ::google::protobuf::int32 s2() const;
  inline void set_s2(::google::protobuf::int32 value);

  // required int32 s3 = 4;
  inline bool has_s3() const;
  inline void clear_s3();
  static const int kS3FieldNumber = 4;
  inline ::google::protobuf::int32 s3() const;
  inline void set_s3(::google::protobuf::int32 value);

  // required int32 s4 = 5;
  inline bool has_s4() const;
  inline void clear_s4();
  static const int kS4FieldNumber = 5;
  inline ::google::protobuf::int32 s4() const;
  inline void set_s4(::google::protobuf::int32 value);

  // required int32 s5 = 6;
  inline bool has_s5() const;
  inline void clear_s5();
  static const int kS5FieldNumber = 6;
  inline ::google::protobuf::int32 s5() const;
  inline void set_s5(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.StoreRateInfo)
 private:
  inline void set_has_storeid();
  inline void clear_has_storeid();
  inline void set_has_s1();
  inline void clear_has_s1();
  inline void set_has_s2();
  inline void clear_has_s2();
  inline void set_has_s3();
  inline void clear_has_s3();
  inline void set_has_s4();
  inline void clear_has_s4();
  inline void set_has_s5();
  inline void clear_has_s5();

  ::google::protobuf::int32 storeid_;
  ::google::protobuf::int32 s1_;
  ::google::protobuf::int32 s2_;
  ::google::protobuf::int32 s3_;
  ::google::protobuf::int32 s4_;
  ::google::protobuf::int32 s5_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static StoreRateInfo* default_instance_;
};
// -------------------------------------------------------------------

class GetStoreRate : public ::google::protobuf::MessageLite {
 public:
  GetStoreRate();
  virtual ~GetStoreRate();

  GetStoreRate(const GetStoreRate& from);

  inline GetStoreRate& operator=(const GetStoreRate& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetStoreRate& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetStoreRate* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetStoreRate* other);

  // implements Message ----------------------------------------------

  GetStoreRate* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetStoreRate& from);
  void MergeFrom(const GetStoreRate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 storeIds = 1;
  inline int storeids_size() const;
  inline void clear_storeids();
  static const int kStoreIdsFieldNumber = 1;
  inline ::google::protobuf::int32 storeids(int index) const;
  inline void set_storeids(int index, ::google::protobuf::int32 value);
  inline void add_storeids(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      storeids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_storeids();

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.GetStoreRate)
 private:

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > storeids_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static GetStoreRate* default_instance_;
};
// -------------------------------------------------------------------

class GetStoreRateReply : public ::google::protobuf::MessageLite {
 public:
  GetStoreRateReply();
  virtual ~GetStoreRateReply();

  GetStoreRateReply(const GetStoreRateReply& from);

  inline GetStoreRateReply& operator=(const GetStoreRateReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetStoreRateReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetStoreRateReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetStoreRateReply* other);

  // implements Message ----------------------------------------------

  GetStoreRateReply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetStoreRateReply& from);
  void MergeFrom(const GetStoreRateReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.mservice.momo.msg.StoreRateInfo rateInfos = 1;
  inline int rateinfos_size() const;
  inline void clear_rateinfos();
  static const int kRateInfosFieldNumber = 1;
  inline const ::com::mservice::momo::msg::StoreRateInfo& rateinfos(int index) const;
  inline ::com::mservice::momo::msg::StoreRateInfo* mutable_rateinfos(int index);
  inline ::com::mservice::momo::msg::StoreRateInfo* add_rateinfos();
  inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::StoreRateInfo >&
      rateinfos() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::StoreRateInfo >*
      mutable_rateinfos();

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.GetStoreRateReply)
 private:

  ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::StoreRateInfo > rateinfos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static GetStoreRateReply* default_instance_;
};
// -------------------------------------------------------------------

class StoreComment : public ::google::protobuf::MessageLite {
 public:
  StoreComment();
  virtual ~StoreComment();

  StoreComment(const StoreComment& from);

  inline StoreComment& operator=(const StoreComment& from) {
    CopyFrom(from);
    return *this;
  }

  static const StoreComment& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StoreComment* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StoreComment* other);

  // implements Message ----------------------------------------------

  StoreComment* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StoreComment& from);
  void MergeFrom(const StoreComment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef StoreComment_CommentStatus CommentStatus;
  static const CommentStatus STATUS_NEW = StoreComment_CommentStatus_STATUS_NEW;
  static const CommentStatus STATUS_ACCEPTED = StoreComment_CommentStatus_STATUS_ACCEPTED;
  static const CommentStatus STATUS_REJECTED = StoreComment_CommentStatus_STATUS_REJECTED;
  static inline bool CommentStatus_IsValid(int value) {
    return StoreComment_CommentStatus_IsValid(value);
  }
  static const CommentStatus CommentStatus_MIN =
    StoreComment_CommentStatus_CommentStatus_MIN;
  static const CommentStatus CommentStatus_MAX =
    StoreComment_CommentStatus_CommentStatus_MAX;
  static const int CommentStatus_ARRAYSIZE =
    StoreComment_CommentStatus_CommentStatus_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required string commentId = 1;
  inline bool has_commentid() const;
  inline void clear_commentid();
  static const int kCommentIdFieldNumber = 1;
  inline const ::std::string& commentid() const;
  inline void set_commentid(const ::std::string& value);
  inline void set_commentid(const char* value);
  inline void set_commentid(const char* value, size_t size);
  inline ::std::string* mutable_commentid();
  inline ::std::string* release_commentid();
  inline void set_allocated_commentid(::std::string* commentid);

  // required int32 storeId = 2;
  inline bool has_storeid() const;
  inline void clear_storeid();
  static const int kStoreIdFieldNumber = 2;
  inline ::google::protobuf::int32 storeid() const;
  inline void set_storeid(::google::protobuf::int32 value);

  // required int32 commenterPhone = 3;
  inline bool has_commenterphone() const;
  inline void clear_commenterphone();
  static const int kCommenterPhoneFieldNumber = 3;
  inline ::google::protobuf::int32 commenterphone() const;
  inline void set_commenterphone(::google::protobuf::int32 value);

  // required string commenterName = 4;
  inline bool has_commentername() const;
  inline void clear_commentername();
  static const int kCommenterNameFieldNumber = 4;
  inline const ::std::string& commentername() const;
  inline void set_commentername(const ::std::string& value);
  inline void set_commentername(const char* value);
  inline void set_commentername(const char* value, size_t size);
  inline ::std::string* mutable_commentername();
  inline ::std::string* release_commentername();
  inline void set_allocated_commentername(::std::string* commentername);

  // required string content = 5;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 5;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // required int64 date = 6;
  inline bool has_date() const;
  inline void clear_date();
  static const int kDateFieldNumber = 6;
  inline ::google::protobuf::int64 date() const;
  inline void set_date(::google::protobuf::int64 value);

  // required int32 rateStar = 7;
  inline bool has_ratestar() const;
  inline void clear_ratestar();
  static const int kRateStarFieldNumber = 7;
  inline ::google::protobuf::int32 ratestar() const;
  inline void set_ratestar(::google::protobuf::int32 value);

  // required int32 status = 8;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 8;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.StoreComment)
 private:
  inline void set_has_commentid();
  inline void clear_has_commentid();
  inline void set_has_storeid();
  inline void clear_has_storeid();
  inline void set_has_commenterphone();
  inline void clear_has_commenterphone();
  inline void set_has_commentername();
  inline void clear_has_commentername();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_date();
  inline void clear_has_date();
  inline void set_has_ratestar();
  inline void clear_has_ratestar();
  inline void set_has_status();
  inline void clear_has_status();

  ::std::string* commentid_;
  ::google::protobuf::int32 storeid_;
  ::google::protobuf::int32 commenterphone_;
  ::std::string* commentername_;
  ::std::string* content_;
  ::google::protobuf::int64 date_;
  ::google::protobuf::int32 ratestar_;
  ::google::protobuf::int32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static StoreComment* default_instance_;
};
// -------------------------------------------------------------------

class GetStoreCommentPage : public ::google::protobuf::MessageLite {
 public:
  GetStoreCommentPage();
  virtual ~GetStoreCommentPage();

  GetStoreCommentPage(const GetStoreCommentPage& from);

  inline GetStoreCommentPage& operator=(const GetStoreCommentPage& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetStoreCommentPage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetStoreCommentPage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetStoreCommentPage* other);

  // implements Message ----------------------------------------------

  GetStoreCommentPage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetStoreCommentPage& from);
  void MergeFrom(const GetStoreCommentPage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 storeId = 1;
  inline bool has_storeid() const;
  inline void clear_storeid();
  static const int kStoreIdFieldNumber = 1;
  inline ::google::protobuf::int32 storeid() const;
  inline void set_storeid(::google::protobuf::int32 value);

  // required int32 commenterPhone = 2;
  inline bool has_commenterphone() const;
  inline void clear_commenterphone();
  static const int kCommenterPhoneFieldNumber = 2;
  inline ::google::protobuf::int32 commenterphone() const;
  inline void set_commenterphone(::google::protobuf::int32 value);

  // required int64 lowestTime = 3;
  inline bool has_lowesttime() const;
  inline void clear_lowesttime();
  static const int kLowestTimeFieldNumber = 3;
  inline ::google::protobuf::int64 lowesttime() const;
  inline void set_lowesttime(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.GetStoreCommentPage)
 private:
  inline void set_has_storeid();
  inline void clear_has_storeid();
  inline void set_has_commenterphone();
  inline void clear_has_commenterphone();
  inline void set_has_lowesttime();
  inline void clear_has_lowesttime();

  ::google::protobuf::int32 storeid_;
  ::google::protobuf::int32 commenterphone_;
  ::google::protobuf::int64 lowesttime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static GetStoreCommentPage* default_instance_;
};
// -------------------------------------------------------------------

class GetStoreCommentPageReply : public ::google::protobuf::MessageLite {
 public:
  GetStoreCommentPageReply();
  virtual ~GetStoreCommentPageReply();

  GetStoreCommentPageReply(const GetStoreCommentPageReply& from);

  inline GetStoreCommentPageReply& operator=(const GetStoreCommentPageReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetStoreCommentPageReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetStoreCommentPageReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetStoreCommentPageReply* other);

  // implements Message ----------------------------------------------

  GetStoreCommentPageReply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetStoreCommentPageReply& from);
  void MergeFrom(const GetStoreCommentPageReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.mservice.momo.msg.StoreComment comments = 3;
  inline int comments_size() const;
  inline void clear_comments();
  static const int kCommentsFieldNumber = 3;
  inline const ::com::mservice::momo::msg::StoreComment& comments(int index) const;
  inline ::com::mservice::momo::msg::StoreComment* mutable_comments(int index);
  inline ::com::mservice::momo::msg::StoreComment* add_comments();
  inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::StoreComment >&
      comments() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::StoreComment >*
      mutable_comments();

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.GetStoreCommentPageReply)
 private:

  ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::StoreComment > comments_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static GetStoreCommentPageReply* default_instance_;
};
// -------------------------------------------------------------------

class StoreCommentCrud : public ::google::protobuf::MessageLite {
 public:
  StoreCommentCrud();
  virtual ~StoreCommentCrud();

  StoreCommentCrud(const StoreCommentCrud& from);

  inline StoreCommentCrud& operator=(const StoreCommentCrud& from) {
    CopyFrom(from);
    return *this;
  }

  static const StoreCommentCrud& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StoreCommentCrud* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StoreCommentCrud* other);

  // implements Message ----------------------------------------------

  StoreCommentCrud* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StoreCommentCrud& from);
  void MergeFrom(const StoreCommentCrud& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef StoreCommentCrud_CrudCmd CrudCmd;
  static const CrudCmd CMD_CREATE = StoreCommentCrud_CrudCmd_CMD_CREATE;
  static const CrudCmd CMD_READ = StoreCommentCrud_CrudCmd_CMD_READ;
  static const CrudCmd CMD_UPDATE = StoreCommentCrud_CrudCmd_CMD_UPDATE;
  static const CrudCmd CMD_DELETE = StoreCommentCrud_CrudCmd_CMD_DELETE;
  static inline bool CrudCmd_IsValid(int value) {
    return StoreCommentCrud_CrudCmd_IsValid(value);
  }
  static const CrudCmd CrudCmd_MIN =
    StoreCommentCrud_CrudCmd_CrudCmd_MIN;
  static const CrudCmd CrudCmd_MAX =
    StoreCommentCrud_CrudCmd_CrudCmd_MAX;
  static const int CrudCmd_ARRAYSIZE =
    StoreCommentCrud_CrudCmd_CrudCmd_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required int32 cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::google::protobuf::int32 cmd() const;
  inline void set_cmd(::google::protobuf::int32 value);

  // required .com.mservice.momo.msg.StoreComment comment = 2;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 2;
  inline const ::com::mservice::momo::msg::StoreComment& comment() const;
  inline ::com::mservice::momo::msg::StoreComment* mutable_comment();
  inline ::com::mservice::momo::msg::StoreComment* release_comment();
  inline void set_allocated_comment(::com::mservice::momo::msg::StoreComment* comment);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.StoreCommentCrud)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_comment();
  inline void clear_has_comment();

  ::com::mservice::momo::msg::StoreComment* comment_;
  ::google::protobuf::int32 cmd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static StoreCommentCrud* default_instance_;
};
// -------------------------------------------------------------------

class StoreCommentCrudReply : public ::google::protobuf::MessageLite {
 public:
  StoreCommentCrudReply();
  virtual ~StoreCommentCrudReply();

  StoreCommentCrudReply(const StoreCommentCrudReply& from);

  inline StoreCommentCrudReply& operator=(const StoreCommentCrudReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const StoreCommentCrudReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StoreCommentCrudReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StoreCommentCrudReply* other);

  // implements Message ----------------------------------------------

  StoreCommentCrudReply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StoreCommentCrudReply& from);
  void MergeFrom(const StoreCommentCrudReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline ::google::protobuf::int32 error() const;
  inline void set_error(::google::protobuf::int32 value);

  // required string desc = 2;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 2;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  inline void set_allocated_desc(::std::string* desc);

  // required string commentId = 3;
  inline bool has_commentid() const;
  inline void clear_commentid();
  static const int kCommentIdFieldNumber = 3;
  inline const ::std::string& commentid() const;
  inline void set_commentid(const ::std::string& value);
  inline void set_commentid(const char* value);
  inline void set_commentid(const char* value, size_t size);
  inline ::std::string* mutable_commentid();
  inline ::std::string* release_commentid();
  inline void set_allocated_commentid(::std::string* commentid);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.StoreCommentCrudReply)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_desc();
  inline void clear_has_desc();
  inline void set_has_commentid();
  inline void clear_has_commentid();

  ::std::string* desc_;
  ::std::string* commentid_;
  ::google::protobuf::int32 error_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static StoreCommentCrudReply* default_instance_;
};
// -------------------------------------------------------------------

class StoreWarningType : public ::google::protobuf::MessageLite {
 public:
  StoreWarningType();
  virtual ~StoreWarningType();

  StoreWarningType(const StoreWarningType& from);

  inline StoreWarningType& operator=(const StoreWarningType& from) {
    CopyFrom(from);
    return *this;
  }

  static const StoreWarningType& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StoreWarningType* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StoreWarningType* other);

  // implements Message ----------------------------------------------

  StoreWarningType* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StoreWarningType& from);
  void MergeFrom(const StoreWarningType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.StoreWarningType)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();

  ::std::string* name_;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static StoreWarningType* default_instance_;
};
// -------------------------------------------------------------------

class GetStoreWarningType : public ::google::protobuf::MessageLite {
 public:
  GetStoreWarningType();
  virtual ~GetStoreWarningType();

  GetStoreWarningType(const GetStoreWarningType& from);

  inline GetStoreWarningType& operator=(const GetStoreWarningType& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetStoreWarningType& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetStoreWarningType* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetStoreWarningType* other);

  // implements Message ----------------------------------------------

  GetStoreWarningType* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetStoreWarningType& from);
  void MergeFrom(const GetStoreWarningType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.GetStoreWarningType)
 private:


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static GetStoreWarningType* default_instance_;
};
// -------------------------------------------------------------------

class GetStoreWarningTypeReply : public ::google::protobuf::MessageLite {
 public:
  GetStoreWarningTypeReply();
  virtual ~GetStoreWarningTypeReply();

  GetStoreWarningTypeReply(const GetStoreWarningTypeReply& from);

  inline GetStoreWarningTypeReply& operator=(const GetStoreWarningTypeReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetStoreWarningTypeReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetStoreWarningTypeReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetStoreWarningTypeReply* other);

  // implements Message ----------------------------------------------

  GetStoreWarningTypeReply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetStoreWarningTypeReply& from);
  void MergeFrom(const GetStoreWarningTypeReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.mservice.momo.msg.StoreWarningType types = 1;
  inline int types_size() const;
  inline void clear_types();
  static const int kTypesFieldNumber = 1;
  inline const ::com::mservice::momo::msg::StoreWarningType& types(int index) const;
  inline ::com::mservice::momo::msg::StoreWarningType* mutable_types(int index);
  inline ::com::mservice::momo::msg::StoreWarningType* add_types();
  inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::StoreWarningType >&
      types() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::StoreWarningType >*
      mutable_types();

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.GetStoreWarningTypeReply)
 private:

  ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::StoreWarningType > types_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static GetStoreWarningTypeReply* default_instance_;
};
// -------------------------------------------------------------------

class WarnStore : public ::google::protobuf::MessageLite {
 public:
  WarnStore();
  virtual ~WarnStore();

  WarnStore(const WarnStore& from);

  inline WarnStore& operator=(const WarnStore& from) {
    CopyFrom(from);
    return *this;
  }

  static const WarnStore& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const WarnStore* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(WarnStore* other);

  // implements Message ----------------------------------------------

  WarnStore* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const WarnStore& from);
  void MergeFrom(const WarnStore& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 storeId = 1;
  inline bool has_storeid() const;
  inline void clear_storeid();
  static const int kStoreIdFieldNumber = 1;
  inline ::google::protobuf::int32 storeid() const;
  inline void set_storeid(::google::protobuf::int32 value);

  // required int32 warningType = 3;
  inline bool has_warningtype() const;
  inline void clear_warningtype();
  static const int kWarningTypeFieldNumber = 3;
  inline ::google::protobuf::int32 warningtype() const;
  inline void set_warningtype(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.WarnStore)
 private:
  inline void set_has_storeid();
  inline void clear_has_storeid();
  inline void set_has_warningtype();
  inline void clear_has_warningtype();

  ::google::protobuf::int32 storeid_;
  ::google::protobuf::int32 warningtype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static WarnStore* default_instance_;
};
// -------------------------------------------------------------------

class WarnStoreReply : public ::google::protobuf::MessageLite {
 public:
  WarnStoreReply();
  virtual ~WarnStoreReply();

  WarnStoreReply(const WarnStoreReply& from);

  inline WarnStoreReply& operator=(const WarnStoreReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const WarnStoreReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const WarnStoreReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(WarnStoreReply* other);

  // implements Message ----------------------------------------------

  WarnStoreReply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const WarnStoreReply& from);
  void MergeFrom(const WarnStoreReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline ::google::protobuf::int32 error() const;
  inline void set_error(::google::protobuf::int32 value);

  // required string desc = 2;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 2;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  inline void set_allocated_desc(::std::string* desc);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.WarnStoreReply)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_desc();
  inline void clear_has_desc();

  ::std::string* desc_;
  ::google::protobuf::int32 error_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static WarnStoreReply* default_instance_;
};
// -------------------------------------------------------------------

class GiftType : public ::google::protobuf::MessageLite {
 public:
  GiftType();
  virtual ~GiftType();

  GiftType(const GiftType& from);

  inline GiftType& operator=(const GiftType& from) {
    CopyFrom(from);
    return *this;
  }

  static const GiftType& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GiftType* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GiftType* other);

  // implements Message ----------------------------------------------

  GiftType* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GiftType& from);
  void MergeFrom(const GiftType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef GiftType_Status Status;
  static const Status ACTIVE = GiftType_Status_ACTIVE;
  static const Status INACTIVE = GiftType_Status_INACTIVE;
  static const Status DELETED = GiftType_Status_DELETED;
  static const Status TIMED = GiftType_Status_TIMED;
  static inline bool Status_IsValid(int value) {
    return GiftType_Status_IsValid(value);
  }
  static const Status Status_MIN =
    GiftType_Status_Status_MIN;
  static const Status Status_MAX =
    GiftType_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    GiftType_Status_Status_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string serviceId = 2;
  inline bool has_serviceid() const;
  inline void clear_serviceid();
  static const int kServiceIdFieldNumber = 2;
  inline const ::std::string& serviceid() const;
  inline void set_serviceid(const ::std::string& value);
  inline void set_serviceid(const char* value);
  inline void set_serviceid(const char* value, size_t size);
  inline ::std::string* mutable_serviceid();
  inline ::std::string* release_serviceid();
  inline void set_allocated_serviceid(::std::string* serviceid);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string desc = 4;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 4;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  inline void set_allocated_desc(::std::string* desc);

  // optional string icon = 5;
  inline bool has_icon() const;
  inline void clear_icon();
  static const int kIconFieldNumber = 5;
  inline const ::std::string& icon() const;
  inline void set_icon(const ::std::string& value);
  inline void set_icon(const char* value);
  inline void set_icon(const char* value, size_t size);
  inline ::std::string* mutable_icon();
  inline ::std::string* release_icon();
  inline void set_allocated_icon(::std::string* icon);

  // optional string image = 6;
  inline bool has_image() const;
  inline void clear_image();
  static const int kImageFieldNumber = 6;
  inline const ::std::string& image() const;
  inline void set_image(const ::std::string& value);
  inline void set_image(const char* value);
  inline void set_image(const char* value, size_t size);
  inline ::std::string* mutable_image();
  inline ::std::string* release_image();
  inline void set_allocated_image(::std::string* image);

  // optional bool transfer = 7;
  inline bool has_transfer() const;
  inline void clear_transfer();
  static const int kTransferFieldNumber = 7;
  inline bool transfer() const;
  inline void set_transfer(bool value);

  // optional uint32 status = 8;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 8;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // optional uint64 modifyDate = 9;
  inline bool has_modifydate() const;
  inline void clear_modifydate();
  static const int kModifyDateFieldNumber = 9;
  inline ::google::protobuf::uint64 modifydate() const;
  inline void set_modifydate(::google::protobuf::uint64 value);

  // optional bool isNew = 10;
  inline bool has_isnew() const;
  inline void clear_isnew();
  static const int kIsNewFieldNumber = 10;
  inline bool isnew() const;
  inline void set_isnew(bool value);

  // repeated int64 price = 11;
  inline int price_size() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 11;
  inline ::google::protobuf::int64 price(int index) const;
  inline void set_price(int index, ::google::protobuf::int64 value);
  inline void add_price(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      price() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_price();

  // optional string policy = 12;
  inline bool has_policy() const;
  inline void clear_policy();
  static const int kPolicyFieldNumber = 12;
  inline const ::std::string& policy() const;
  inline void set_policy(const ::std::string& value);
  inline void set_policy(const char* value);
  inline void set_policy(const char* value, size_t size);
  inline ::std::string* mutable_policy();
  inline ::std::string* release_policy();
  inline void set_allocated_policy(::std::string* policy);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.GiftType)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_serviceid();
  inline void clear_has_serviceid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_desc();
  inline void clear_has_desc();
  inline void set_has_icon();
  inline void clear_has_icon();
  inline void set_has_image();
  inline void clear_has_image();
  inline void set_has_transfer();
  inline void clear_has_transfer();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_modifydate();
  inline void clear_has_modifydate();
  inline void set_has_isnew();
  inline void clear_has_isnew();
  inline void set_has_policy();
  inline void clear_has_policy();

  ::std::string* id_;
  ::std::string* serviceid_;
  ::std::string* name_;
  ::std::string* desc_;
  ::std::string* icon_;
  ::std::string* image_;
  ::google::protobuf::uint32 status_;
  bool transfer_;
  bool isnew_;
  ::google::protobuf::uint64 modifydate_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > price_;
  ::std::string* policy_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static GiftType* default_instance_;
};
// -------------------------------------------------------------------

class Gift : public ::google::protobuf::MessageLite {
 public:
  Gift();
  virtual ~Gift();

  Gift(const Gift& from);

  inline Gift& operator=(const Gift& from) {
    CopyFrom(from);
    return *this;
  }

  static const Gift& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Gift* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Gift* other);

  // implements Message ----------------------------------------------

  Gift* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Gift& from);
  void MergeFrom(const Gift& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Gift_Status Status;
  static const Status NEW = Gift_Status_NEW;
  static const Status VIEWED = Gift_Status_VIEWED;
  static const Status USED = Gift_Status_USED;
  static const Status TIMED = Gift_Status_TIMED;
  static inline bool Status_IsValid(int value) {
    return Gift_Status_IsValid(value);
  }
  static const Status Status_MIN =
    Gift_Status_Status_MIN;
  static const Status Status_MAX =
    Gift_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    Gift_Status_Status_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string code = 2;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 2;
  inline const ::std::string& code() const;
  inline void set_code(const ::std::string& value);
  inline void set_code(const char* value);
  inline void set_code(const char* value, size_t size);
  inline ::std::string* mutable_code();
  inline ::std::string* release_code();
  inline void set_allocated_code(::std::string* code);

  // optional uint64 amount = 3;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 3;
  inline ::google::protobuf::uint64 amount() const;
  inline void set_amount(::google::protobuf::uint64 value);

  // optional string desc = 5;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 5;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  inline void set_allocated_desc(::std::string* desc);

  // optional string typeId = 6;
  inline bool has_typeid_() const;
  inline void clear_typeid_();
  static const int kTypeIdFieldNumber = 6;
  inline const ::std::string& typeid_() const;
  inline void set_typeid_(const ::std::string& value);
  inline void set_typeid_(const char* value);
  inline void set_typeid_(const char* value, size_t size);
  inline ::std::string* mutable_typeid_();
  inline ::std::string* release_typeid_();
  inline void set_allocated_typeid_(::std::string* typeid_);

  // optional uint64 startDate = 7;
  inline bool has_startdate() const;
  inline void clear_startdate();
  static const int kStartDateFieldNumber = 7;
  inline ::google::protobuf::uint64 startdate() const;
  inline void set_startdate(::google::protobuf::uint64 value);

  // optional uint64 endDate = 8;
  inline bool has_enddate() const;
  inline void clear_enddate();
  static const int kEndDateFieldNumber = 8;
  inline ::google::protobuf::uint64 enddate() const;
  inline void set_enddate(::google::protobuf::uint64 value);

  // optional uint64 modifyDate = 9;
  inline bool has_modifydate() const;
  inline void clear_modifydate();
  static const int kModifyDateFieldNumber = 9;
  inline ::google::protobuf::uint64 modifydate() const;
  inline void set_modifydate(::google::protobuf::uint64 value);

  // optional int32 status = 10;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 10;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // optional string extra = 11;
  inline bool has_extra() const;
  inline void clear_extra();
  static const int kExtraFieldNumber = 11;
  inline const ::std::string& extra() const;
  inline void set_extra(const ::std::string& value);
  inline void set_extra(const char* value);
  inline void set_extra(const char* value, size_t size);
  inline ::std::string* mutable_extra();
  inline ::std::string* release_extra();
  inline void set_allocated_extra(::std::string* extra);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.Gift)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_desc();
  inline void clear_has_desc();
  inline void set_has_typeid_();
  inline void clear_has_typeid_();
  inline void set_has_startdate();
  inline void clear_has_startdate();
  inline void set_has_enddate();
  inline void clear_has_enddate();
  inline void set_has_modifydate();
  inline void clear_has_modifydate();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_extra();
  inline void clear_has_extra();

  ::std::string* id_;
  ::std::string* code_;
  ::google::protobuf::uint64 amount_;
  ::std::string* desc_;
  ::std::string* typeid__;
  ::google::protobuf::uint64 startdate_;
  ::google::protobuf::uint64 enddate_;
  ::google::protobuf::uint64 modifydate_;
  ::std::string* extra_;
  ::google::protobuf::int32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static Gift* default_instance_;
};
// -------------------------------------------------------------------

class GiftClaim : public ::google::protobuf::MessageLite {
 public:
  GiftClaim();
  virtual ~GiftClaim();

  GiftClaim(const GiftClaim& from);

  inline GiftClaim& operator=(const GiftClaim& from) {
    CopyFrom(from);
    return *this;
  }

  static const GiftClaim& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GiftClaim* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GiftClaim* other);

  // implements Message ----------------------------------------------

  GiftClaim* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GiftClaim& from);
  void MergeFrom(const GiftClaim& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline const ::std::string& code() const;
  inline void set_code(const ::std::string& value);
  inline void set_code(const char* value);
  inline void set_code(const char* value, size_t size);
  inline ::std::string* mutable_code();
  inline ::std::string* release_code();
  inline void set_allocated_code(::std::string* code);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.GiftClaim)
 private:
  inline void set_has_code();
  inline void clear_has_code();

  ::std::string* code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static GiftClaim* default_instance_;
};
// -------------------------------------------------------------------

class GiftClaimReply : public ::google::protobuf::MessageLite {
 public:
  GiftClaimReply();
  virtual ~GiftClaimReply();

  GiftClaimReply(const GiftClaimReply& from);

  inline GiftClaimReply& operator=(const GiftClaimReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const GiftClaimReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GiftClaimReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GiftClaimReply* other);

  // implements Message ----------------------------------------------

  GiftClaimReply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GiftClaimReply& from);
  void MergeFrom(const GiftClaimReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline ::google::protobuf::int32 error() const;
  inline void set_error(::google::protobuf::int32 value);

  // optional int64 point = 2;
  inline bool has_point() const;
  inline void clear_point();
  static const int kPointFieldNumber = 2;
  inline ::google::protobuf::int64 point() const;
  inline void set_point(::google::protobuf::int64 value);

  // optional .com.mservice.momo.msg.Gift gift = 3;
  inline bool has_gift() const;
  inline void clear_gift();
  static const int kGiftFieldNumber = 3;
  inline const ::com::mservice::momo::msg::Gift& gift() const;
  inline ::com::mservice::momo::msg::Gift* mutable_gift();
  inline ::com::mservice::momo::msg::Gift* release_gift();
  inline void set_allocated_gift(::com::mservice::momo::msg::Gift* gift);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.GiftClaimReply)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_point();
  inline void clear_has_point();
  inline void set_has_gift();
  inline void clear_has_gift();

  ::google::protobuf::int64 point_;
  ::com::mservice::momo::msg::Gift* gift_;
  ::google::protobuf::int32 error_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static GiftClaimReply* default_instance_;
};
// -------------------------------------------------------------------

class UserSetting : public ::google::protobuf::MessageLite {
 public:
  UserSetting();
  virtual ~UserSetting();

  UserSetting(const UserSetting& from);

  inline UserSetting& operator=(const UserSetting& from) {
    CopyFrom(from);
    return *this;
  }

  static const UserSetting& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserSetting* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserSetting* other);

  // implements Message ----------------------------------------------

  UserSetting* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserSetting& from);
  void MergeFrom(const UserSetting& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool useMpoint = 1;
  inline bool has_usempoint() const;
  inline void clear_usempoint();
  static const int kUseMpointFieldNumber = 1;
  inline bool usempoint() const;
  inline void set_usempoint(bool value);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.UserSetting)
 private:
  inline void set_has_usempoint();
  inline void clear_has_usempoint();

  bool usempoint_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static UserSetting* default_instance_;
};
// -------------------------------------------------------------------

class GetGiftType : public ::google::protobuf::MessageLite {
 public:
  GetGiftType();
  virtual ~GetGiftType();

  GetGiftType(const GetGiftType& from);

  inline GetGiftType& operator=(const GetGiftType& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetGiftType& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetGiftType* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetGiftType* other);

  // implements Message ----------------------------------------------

  GetGiftType* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetGiftType& from);
  void MergeFrom(const GetGiftType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::uint64 time() const;
  inline void set_time(::google::protobuf::uint64 value);

  // optional string giftTypeId = 2;
  inline bool has_gifttypeid() const;
  inline void clear_gifttypeid();
  static const int kGiftTypeIdFieldNumber = 2;
  inline const ::std::string& gifttypeid() const;
  inline void set_gifttypeid(const ::std::string& value);
  inline void set_gifttypeid(const char* value);
  inline void set_gifttypeid(const char* value, size_t size);
  inline ::std::string* mutable_gifttypeid();
  inline ::std::string* release_gifttypeid();
  inline void set_allocated_gifttypeid(::std::string* gifttypeid);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.GetGiftType)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_gifttypeid();
  inline void clear_has_gifttypeid();

  ::google::protobuf::uint64 time_;
  ::std::string* gifttypeid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static GetGiftType* default_instance_;
};
// -------------------------------------------------------------------

class GetGiftTypeReply : public ::google::protobuf::MessageLite {
 public:
  GetGiftTypeReply();
  virtual ~GetGiftTypeReply();

  GetGiftTypeReply(const GetGiftTypeReply& from);

  inline GetGiftTypeReply& operator=(const GetGiftTypeReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetGiftTypeReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetGiftTypeReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetGiftTypeReply* other);

  // implements Message ----------------------------------------------

  GetGiftTypeReply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetGiftTypeReply& from);
  void MergeFrom(const GetGiftTypeReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.mservice.momo.msg.GiftType giftType = 1;
  inline int gifttype_size() const;
  inline void clear_gifttype();
  static const int kGiftTypeFieldNumber = 1;
  inline const ::com::mservice::momo::msg::GiftType& gifttype(int index) const;
  inline ::com::mservice::momo::msg::GiftType* mutable_gifttype(int index);
  inline ::com::mservice::momo::msg::GiftType* add_gifttype();
  inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::GiftType >&
      gifttype() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::GiftType >*
      mutable_gifttype();

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.GetGiftTypeReply)
 private:

  ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::GiftType > gifttype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static GetGiftTypeReply* default_instance_;
};
// -------------------------------------------------------------------

class GetGift : public ::google::protobuf::MessageLite {
 public:
  GetGift();
  virtual ~GetGift();

  GetGift(const GetGift& from);

  inline GetGift& operator=(const GetGift& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetGift& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetGift* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetGift* other);

  // implements Message ----------------------------------------------

  GetGift* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetGift& from);
  void MergeFrom(const GetGift& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string giftId = 1;
  inline bool has_giftid() const;
  inline void clear_giftid();
  static const int kGiftIdFieldNumber = 1;
  inline const ::std::string& giftid() const;
  inline void set_giftid(const ::std::string& value);
  inline void set_giftid(const char* value);
  inline void set_giftid(const char* value, size_t size);
  inline ::std::string* mutable_giftid();
  inline ::std::string* release_giftid();
  inline void set_allocated_giftid(::std::string* giftid);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.GetGift)
 private:
  inline void set_has_giftid();
  inline void clear_has_giftid();

  ::std::string* giftid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static GetGift* default_instance_;
};
// -------------------------------------------------------------------

class GetGiftReply : public ::google::protobuf::MessageLite {
 public:
  GetGiftReply();
  virtual ~GetGiftReply();

  GetGiftReply(const GetGiftReply& from);

  inline GetGiftReply& operator=(const GetGiftReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetGiftReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetGiftReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetGiftReply* other);

  // implements Message ----------------------------------------------

  GetGiftReply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetGiftReply& from);
  void MergeFrom(const GetGiftReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // repeated .com.mservice.momo.msg.Gift gift = 2;
  inline int gift_size() const;
  inline void clear_gift();
  static const int kGiftFieldNumber = 2;
  inline const ::com::mservice::momo::msg::Gift& gift(int index) const;
  inline ::com::mservice::momo::msg::Gift* mutable_gift(int index);
  inline ::com::mservice::momo::msg::Gift* add_gift();
  inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::Gift >&
      gift() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::Gift >*
      mutable_gift();

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.GetGiftReply)
 private:
  inline void set_has_index();
  inline void clear_has_index();

  ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::Gift > gift_;
  ::google::protobuf::int32 index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static GetGiftReply* default_instance_;
};
// -------------------------------------------------------------------

class SetGiftStatus : public ::google::protobuf::MessageLite {
 public:
  SetGiftStatus();
  virtual ~SetGiftStatus();

  SetGiftStatus(const SetGiftStatus& from);

  inline SetGiftStatus& operator=(const SetGiftStatus& from) {
    CopyFrom(from);
    return *this;
  }

  static const SetGiftStatus& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SetGiftStatus* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SetGiftStatus* other);

  // implements Message ----------------------------------------------

  SetGiftStatus* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SetGiftStatus& from);
  void MergeFrom(const SetGiftStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string giftId = 1;
  inline bool has_giftid() const;
  inline void clear_giftid();
  static const int kGiftIdFieldNumber = 1;
  inline const ::std::string& giftid() const;
  inline void set_giftid(const ::std::string& value);
  inline void set_giftid(const char* value);
  inline void set_giftid(const char* value, size_t size);
  inline ::std::string* mutable_giftid();
  inline ::std::string* release_giftid();
  inline void set_allocated_giftid(::std::string* giftid);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.SetGiftStatus)
 private:
  inline void set_has_giftid();
  inline void clear_has_giftid();

  ::std::string* giftid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static SetGiftStatus* default_instance_;
};
// -------------------------------------------------------------------

class SendMessage : public ::google::protobuf::MessageLite {
 public:
  SendMessage();
  virtual ~SendMessage();

  SendMessage(const SendMessage& from);

  inline SendMessage& operator=(const SendMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const SendMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SendMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SendMessage* other);

  // implements Message ----------------------------------------------

  SendMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SendMessage& from);
  void MergeFrom(const SendMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef SendMessage_Type Type;
  static const Type MONEY_THANKS = SendMessage_Type_MONEY_THANKS;
  static const Type GIFT_THANKS = SendMessage_Type_GIFT_THANKS;
  static inline bool Type_IsValid(int value) {
    return SendMessage_Type_IsValid(value);
  }
  static const Type Type_MIN =
    SendMessage_Type_Type_MIN;
  static const Type Type_MAX =
    SendMessage_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    SendMessage_Type_Type_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional int32 toPhone = 1;
  inline bool has_tophone() const;
  inline void clear_tophone();
  static const int kToPhoneFieldNumber = 1;
  inline ::google::protobuf::int32 tophone() const;
  inline void set_tophone(::google::protobuf::int32 value);

  // optional int64 tranId = 2;
  inline bool has_tranid() const;
  inline void clear_tranid();
  static const int kTranIdFieldNumber = 2;
  inline ::google::protobuf::int64 tranid() const;
  inline void set_tranid(::google::protobuf::int64 value);

  // optional string senderName = 3;
  inline bool has_sendername() const;
  inline void clear_sendername();
  static const int kSenderNameFieldNumber = 3;
  inline const ::std::string& sendername() const;
  inline void set_sendername(const ::std::string& value);
  inline void set_sendername(const char* value);
  inline void set_sendername(const char* value, size_t size);
  inline ::std::string* mutable_sendername();
  inline ::std::string* release_sendername();
  inline void set_allocated_sendername(::std::string* sendername);

  // optional string msg = 4;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 4;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  inline void set_allocated_msg(::std::string* msg);

  // optional int32 type = 5;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 5;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.SendMessage)
 private:
  inline void set_has_tophone();
  inline void clear_has_tophone();
  inline void set_has_tranid();
  inline void clear_has_tranid();
  inline void set_has_sendername();
  inline void clear_has_sendername();
  inline void set_has_msg();
  inline void clear_has_msg();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::int64 tranid_;
  ::std::string* sendername_;
  ::google::protobuf::int32 tophone_;
  ::google::protobuf::int32 type_;
  ::std::string* msg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static SendMessage* default_instance_;
};
// -------------------------------------------------------------------

class GiftRequest : public ::google::protobuf::MessageLite {
 public:
  GiftRequest();
  virtual ~GiftRequest();

  GiftRequest(const GiftRequest& from);

  inline GiftRequest& operator=(const GiftRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const GiftRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GiftRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GiftRequest* other);

  // implements Message ----------------------------------------------

  GiftRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GiftRequest& from);
  void MergeFrom(const GiftRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string giftId = 1;
  inline bool has_giftid() const;
  inline void clear_giftid();
  static const int kGiftIdFieldNumber = 1;
  inline const ::std::string& giftid() const;
  inline void set_giftid(const ::std::string& value);
  inline void set_giftid(const char* value);
  inline void set_giftid(const char* value, size_t size);
  inline ::std::string* mutable_giftid();
  inline ::std::string* release_giftid();
  inline void set_allocated_giftid(::std::string* giftid);

  // optional string serviceId = 2;
  inline bool has_serviceid() const;
  inline void clear_serviceid();
  static const int kServiceIdFieldNumber = 2;
  inline const ::std::string& serviceid() const;
  inline void set_serviceid(const ::std::string& value);
  inline void set_serviceid(const char* value);
  inline void set_serviceid(const char* value, size_t size);
  inline ::std::string* mutable_serviceid();
  inline ::std::string* release_serviceid();
  inline void set_allocated_serviceid(::std::string* serviceid);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.GiftRequest)
 private:
  inline void set_has_giftid();
  inline void clear_has_giftid();
  inline void set_has_serviceid();
  inline void clear_has_serviceid();

  ::std::string* giftid_;
  ::std::string* serviceid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static GiftRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetTranConfirmReply : public ::google::protobuf::MessageLite {
 public:
  GetTranConfirmReply();
  virtual ~GetTranConfirmReply();

  GetTranConfirmReply(const GetTranConfirmReply& from);

  inline GetTranConfirmReply& operator=(const GetTranConfirmReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetTranConfirmReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetTranConfirmReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetTranConfirmReply* other);

  // implements Message ----------------------------------------------

  GetTranConfirmReply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetTranConfirmReply& from);
  void MergeFrom(const GetTranConfirmReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 point = 3;
  inline bool has_point() const;
  inline void clear_point();
  static const int kPointFieldNumber = 3;
  inline ::google::protobuf::int64 point() const;
  inline void set_point(::google::protobuf::int64 value);

  // optional int64 momo = 4;
  inline bool has_momo() const;
  inline void clear_momo();
  static const int kMomoFieldNumber = 4;
  inline ::google::protobuf::int64 momo() const;
  inline void set_momo(::google::protobuf::int64 value);

  // optional int64 gift = 5;
  inline bool has_gift() const;
  inline void clear_gift();
  static const int kGiftFieldNumber = 5;
  inline ::google::protobuf::int64 gift() const;
  inline void set_gift(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.GetTranConfirmReply)
 private:
  inline void set_has_point();
  inline void clear_has_point();
  inline void set_has_momo();
  inline void clear_has_momo();
  inline void set_has_gift();
  inline void clear_has_gift();

  ::google::protobuf::int64 point_;
  ::google::protobuf::int64 momo_;
  ::google::protobuf::int64 gift_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static GetTranConfirmReply* default_instance_;
};
// -------------------------------------------------------------------

class InfoAlertType : public ::google::protobuf::MessageLite {
 public:
  InfoAlertType();
  virtual ~InfoAlertType();

  InfoAlertType(const InfoAlertType& from);

  inline InfoAlertType& operator=(const InfoAlertType& from) {
    CopyFrom(from);
    return *this;
  }

  static const InfoAlertType& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const InfoAlertType* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(InfoAlertType* other);

  // implements Message ----------------------------------------------

  InfoAlertType* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const InfoAlertType& from);
  void MergeFrom(const InfoAlertType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef InfoAlertType_Status Status;
  static const Status ACTIVE = InfoAlertType_Status_ACTIVE;
  static const Status INACTIVE = InfoAlertType_Status_INACTIVE;
  static const Status DELETED = InfoAlertType_Status_DELETED;
  static inline bool Status_IsValid(int value) {
    return InfoAlertType_Status_IsValid(value);
  }
  static const Status Status_MIN =
    InfoAlertType_Status_Status_MIN;
  static const Status Status_MAX =
    InfoAlertType_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    InfoAlertType_Status_Status_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string desc = 2;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 2;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  inline void set_allocated_desc(::std::string* desc);

  // optional uint32 status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // optional uint64 last_time = 4;
  inline bool has_last_time() const;
  inline void clear_last_time();
  static const int kLastTimeFieldNumber = 4;
  inline ::google::protobuf::uint64 last_time() const;
  inline void set_last_time(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.InfoAlertType)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_desc();
  inline void clear_has_desc();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_last_time();
  inline void clear_has_last_time();

  ::std::string* id_;
  ::std::string* desc_;
  ::google::protobuf::uint64 last_time_;
  ::google::protobuf::uint32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static InfoAlertType* default_instance_;
};
// -------------------------------------------------------------------

class GetAlertType : public ::google::protobuf::MessageLite {
 public:
  GetAlertType();
  virtual ~GetAlertType();

  GetAlertType(const GetAlertType& from);

  inline GetAlertType& operator=(const GetAlertType& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetAlertType& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetAlertType* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetAlertType* other);

  // implements Message ----------------------------------------------

  GetAlertType* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetAlertType& from);
  void MergeFrom(const GetAlertType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 last_time = 1;
  inline bool has_last_time() const;
  inline void clear_last_time();
  static const int kLastTimeFieldNumber = 1;
  inline ::google::protobuf::uint64 last_time() const;
  inline void set_last_time(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.GetAlertType)
 private:
  inline void set_has_last_time();
  inline void clear_has_last_time();

  ::google::protobuf::uint64 last_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static GetAlertType* default_instance_;
};
// -------------------------------------------------------------------

class GetAlertTypeReply : public ::google::protobuf::MessageLite {
 public:
  GetAlertTypeReply();
  virtual ~GetAlertTypeReply();

  GetAlertTypeReply(const GetAlertTypeReply& from);

  inline GetAlertTypeReply& operator=(const GetAlertTypeReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetAlertTypeReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetAlertTypeReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetAlertTypeReply* other);

  // implements Message ----------------------------------------------

  GetAlertTypeReply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetAlertTypeReply& from);
  void MergeFrom(const GetAlertTypeReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.mservice.momo.msg.InfoAlertType alert_types = 1;
  inline int alert_types_size() const;
  inline void clear_alert_types();
  static const int kAlertTypesFieldNumber = 1;
  inline const ::com::mservice::momo::msg::InfoAlertType& alert_types(int index) const;
  inline ::com::mservice::momo::msg::InfoAlertType* mutable_alert_types(int index);
  inline ::com::mservice::momo::msg::InfoAlertType* add_alert_types();
  inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::InfoAlertType >&
      alert_types() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::InfoAlertType >*
      mutable_alert_types();

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.GetAlertTypeReply)
 private:

  ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::InfoAlertType > alert_types_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static GetAlertTypeReply* default_instance_;
};
// -------------------------------------------------------------------

class InfoAlert : public ::google::protobuf::MessageLite {
 public:
  InfoAlert();
  virtual ~InfoAlert();

  InfoAlert(const InfoAlert& from);

  inline InfoAlert& operator=(const InfoAlert& from) {
    CopyFrom(from);
    return *this;
  }

  static const InfoAlert& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const InfoAlert* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(InfoAlert* other);

  // implements Message ----------------------------------------------

  InfoAlert* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const InfoAlert& from);
  void MergeFrom(const InfoAlert& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string alert_id = 1;
  inline bool has_alert_id() const;
  inline void clear_alert_id();
  static const int kAlertIdFieldNumber = 1;
  inline const ::std::string& alert_id() const;
  inline void set_alert_id(const ::std::string& value);
  inline void set_alert_id(const char* value);
  inline void set_alert_id(const char* value, size_t size);
  inline ::std::string* mutable_alert_id();
  inline ::std::string* release_alert_id();
  inline void set_allocated_alert_id(::std::string* alert_id);

  // optional uint32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional string desc = 3;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 3;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  inline void set_allocated_desc(::std::string* desc);

  // repeated string images = 4;
  inline int images_size() const;
  inline void clear_images();
  static const int kImagesFieldNumber = 4;
  inline const ::std::string& images(int index) const;
  inline ::std::string* mutable_images(int index);
  inline void set_images(int index, const ::std::string& value);
  inline void set_images(int index, const char* value);
  inline void set_images(int index, const char* value, size_t size);
  inline ::std::string* add_images();
  inline void add_images(const ::std::string& value);
  inline void add_images(const char* value);
  inline void add_images(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& images() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_images();

  // optional string os = 5;
  inline bool has_os() const;
  inline void clear_os();
  static const int kOsFieldNumber = 5;
  inline const ::std::string& os() const;
  inline void set_os(const ::std::string& value);
  inline void set_os(const char* value);
  inline void set_os(const char* value, size_t size);
  inline ::std::string* mutable_os();
  inline ::std::string* release_os();
  inline void set_allocated_os(::std::string* os);

  // @@protoc_insertion_point(class_scope:com.mservice.momo.msg.InfoAlert)
 private:
  inline void set_has_alert_id();
  inline void clear_has_alert_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_desc();
  inline void clear_has_desc();
  inline void set_has_os();
  inline void clear_has_os();

  ::std::string* alert_id_;
  ::std::string* desc_;
  ::google::protobuf::RepeatedPtrField< ::std::string> images_;
  ::std::string* os_;
  ::google::protobuf::uint32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MomoProto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MomoProto_2eproto();
  #endif
  friend void protobuf_AssignDesc_MomoProto_2eproto();
  friend void protobuf_ShutdownFile_MomoProto_2eproto();

  void InitAsDefaultInstance();
  static InfoAlert* default_instance_;
};
// ===================================================================


// ===================================================================

// TextValueMsg

// repeated .com.mservice.momo.msg.TextValue keys = 1;
inline int TextValueMsg::keys_size() const {
  return keys_.size();
}
inline void TextValueMsg::clear_keys() {
  keys_.Clear();
}
inline const ::com::mservice::momo::msg::TextValue& TextValueMsg::keys(int index) const {
  return keys_.Get(index);
}
inline ::com::mservice::momo::msg::TextValue* TextValueMsg::mutable_keys(int index) {
  return keys_.Mutable(index);
}
inline ::com::mservice::momo::msg::TextValue* TextValueMsg::add_keys() {
  return keys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::TextValue >&
TextValueMsg::keys() const {
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::TextValue >*
TextValueMsg::mutable_keys() {
  return &keys_;
}

// -------------------------------------------------------------------

// FormReply

// repeated .com.mservice.momo.msg.TextValue list_info = 1;
inline int FormReply::list_info_size() const {
  return list_info_.size();
}
inline void FormReply::clear_list_info() {
  list_info_.Clear();
}
inline const ::com::mservice::momo::msg::TextValue& FormReply::list_info(int index) const {
  return list_info_.Get(index);
}
inline ::com::mservice::momo::msg::TextValue* FormReply::mutable_list_info(int index) {
  return list_info_.Mutable(index);
}
inline ::com::mservice::momo::msg::TextValue* FormReply::add_list_info() {
  return list_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::TextValue >&
FormReply::list_info() const {
  return list_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::TextValue >*
FormReply::mutable_list_info() {
  return &list_info_;
}

// optional uint32 next = 2;
inline bool FormReply::has_next() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FormReply::set_has_next() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FormReply::clear_has_next() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FormReply::clear_next() {
  next_ = 0u;
  clear_has_next();
}
inline ::google::protobuf::uint32 FormReply::next() const {
  return next_;
}
inline void FormReply::set_next(::google::protobuf::uint32 value) {
  set_has_next();
  next_ = value;
}

// -------------------------------------------------------------------

// FormField

// repeated .com.mservice.momo.msg.FieldItem list_field_item = 1;
inline int FormField::list_field_item_size() const {
  return list_field_item_.size();
}
inline void FormField::clear_list_field_item() {
  list_field_item_.Clear();
}
inline const ::com::mservice::momo::msg::FieldItem& FormField::list_field_item(int index) const {
  return list_field_item_.Get(index);
}
inline ::com::mservice::momo::msg::FieldItem* FormField::mutable_list_field_item(int index) {
  return list_field_item_.Mutable(index);
}
inline ::com::mservice::momo::msg::FieldItem* FormField::add_list_field_item() {
  return list_field_item_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::FieldItem >&
FormField::list_field_item() const {
  return list_field_item_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::FieldItem >*
FormField::mutable_list_field_item() {
  return &list_field_item_;
}

// repeated .com.mservice.momo.msg.ValueForDropBox list_value = 2;
inline int FormField::list_value_size() const {
  return list_value_.size();
}
inline void FormField::clear_list_value() {
  list_value_.Clear();
}
inline const ::com::mservice::momo::msg::ValueForDropBox& FormField::list_value(int index) const {
  return list_value_.Get(index);
}
inline ::com::mservice::momo::msg::ValueForDropBox* FormField::mutable_list_value(int index) {
  return list_value_.Mutable(index);
}
inline ::com::mservice::momo::msg::ValueForDropBox* FormField::add_list_value() {
  return list_value_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::ValueForDropBox >&
FormField::list_value() const {
  return list_value_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::ValueForDropBox >*
FormField::mutable_list_value() {
  return &list_value_;
}

// -------------------------------------------------------------------

// ValueForDropBox

// optional string link_to_drop_key = 1;
inline bool ValueForDropBox::has_link_to_drop_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ValueForDropBox::set_has_link_to_drop_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ValueForDropBox::clear_has_link_to_drop_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ValueForDropBox::clear_link_to_drop_key() {
  if (link_to_drop_key_ != &::google::protobuf::internal::kEmptyString) {
    link_to_drop_key_->clear();
  }
  clear_has_link_to_drop_key();
}
inline const ::std::string& ValueForDropBox::link_to_drop_key() const {
  return *link_to_drop_key_;
}
inline void ValueForDropBox::set_link_to_drop_key(const ::std::string& value) {
  set_has_link_to_drop_key();
  if (link_to_drop_key_ == &::google::protobuf::internal::kEmptyString) {
    link_to_drop_key_ = new ::std::string;
  }
  link_to_drop_key_->assign(value);
}
inline void ValueForDropBox::set_link_to_drop_key(const char* value) {
  set_has_link_to_drop_key();
  if (link_to_drop_key_ == &::google::protobuf::internal::kEmptyString) {
    link_to_drop_key_ = new ::std::string;
  }
  link_to_drop_key_->assign(value);
}
inline void ValueForDropBox::set_link_to_drop_key(const char* value, size_t size) {
  set_has_link_to_drop_key();
  if (link_to_drop_key_ == &::google::protobuf::internal::kEmptyString) {
    link_to_drop_key_ = new ::std::string;
  }
  link_to_drop_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ValueForDropBox::mutable_link_to_drop_key() {
  set_has_link_to_drop_key();
  if (link_to_drop_key_ == &::google::protobuf::internal::kEmptyString) {
    link_to_drop_key_ = new ::std::string;
  }
  return link_to_drop_key_;
}
inline ::std::string* ValueForDropBox::release_link_to_drop_key() {
  clear_has_link_to_drop_key();
  if (link_to_drop_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = link_to_drop_key_;
    link_to_drop_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ValueForDropBox::set_allocated_link_to_drop_key(::std::string* link_to_drop_key) {
  if (link_to_drop_key_ != &::google::protobuf::internal::kEmptyString) {
    delete link_to_drop_key_;
  }
  if (link_to_drop_key) {
    set_has_link_to_drop_key();
    link_to_drop_key_ = link_to_drop_key;
  } else {
    clear_has_link_to_drop_key();
    link_to_drop_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .com.mservice.momo.msg.TextValue list_value = 2;
inline int ValueForDropBox::list_value_size() const {
  return list_value_.size();
}
inline void ValueForDropBox::clear_list_value() {
  list_value_.Clear();
}
inline const ::com::mservice::momo::msg::TextValue& ValueForDropBox::list_value(int index) const {
  return list_value_.Get(index);
}
inline ::com::mservice::momo::msg::TextValue* ValueForDropBox::mutable_list_value(int index) {
  return list_value_.Mutable(index);
}
inline ::com::mservice::momo::msg::TextValue* ValueForDropBox::add_list_value() {
  return list_value_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::TextValue >&
ValueForDropBox::list_value() const {
  return list_value_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::TextValue >*
ValueForDropBox::mutable_list_value() {
  return &list_value_;
}

// -------------------------------------------------------------------

// GetServiceByLastTime

// optional uint64 last_time = 1;
inline bool GetServiceByLastTime::has_last_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetServiceByLastTime::set_has_last_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetServiceByLastTime::clear_has_last_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetServiceByLastTime::clear_last_time() {
  last_time_ = GOOGLE_ULONGLONG(0);
  clear_has_last_time();
}
inline ::google::protobuf::uint64 GetServiceByLastTime::last_time() const {
  return last_time_;
}
inline void GetServiceByLastTime::set_last_time(::google::protobuf::uint64 value) {
  set_has_last_time();
  last_time_ = value;
}

// -------------------------------------------------------------------

// GetServiceByServiceId

// optional string service_id = 1;
inline bool GetServiceByServiceId::has_service_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetServiceByServiceId::set_has_service_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetServiceByServiceId::clear_has_service_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetServiceByServiceId::clear_service_id() {
  if (service_id_ != &::google::protobuf::internal::kEmptyString) {
    service_id_->clear();
  }
  clear_has_service_id();
}
inline const ::std::string& GetServiceByServiceId::service_id() const {
  return *service_id_;
}
inline void GetServiceByServiceId::set_service_id(const ::std::string& value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
}
inline void GetServiceByServiceId::set_service_id(const char* value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
}
inline void GetServiceByServiceId::set_service_id(const char* value, size_t size) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetServiceByServiceId::mutable_service_id() {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  return service_id_;
}
inline ::std::string* GetServiceByServiceId::release_service_id() {
  clear_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = service_id_;
    service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetServiceByServiceId::set_allocated_service_id(::std::string* service_id) {
  if (service_id_ != &::google::protobuf::internal::kEmptyString) {
    delete service_id_;
  }
  if (service_id) {
    set_has_service_id();
    service_id_ = service_id;
  } else {
    clear_has_service_id();
    service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// WholeSystemPaused

// optional string caption = 1;
inline bool WholeSystemPaused::has_caption() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WholeSystemPaused::set_has_caption() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WholeSystemPaused::clear_has_caption() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WholeSystemPaused::clear_caption() {
  if (caption_ != &::google::protobuf::internal::kEmptyString) {
    caption_->clear();
  }
  clear_has_caption();
}
inline const ::std::string& WholeSystemPaused::caption() const {
  return *caption_;
}
inline void WholeSystemPaused::set_caption(const ::std::string& value) {
  set_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    caption_ = new ::std::string;
  }
  caption_->assign(value);
}
inline void WholeSystemPaused::set_caption(const char* value) {
  set_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    caption_ = new ::std::string;
  }
  caption_->assign(value);
}
inline void WholeSystemPaused::set_caption(const char* value, size_t size) {
  set_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    caption_ = new ::std::string;
  }
  caption_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WholeSystemPaused::mutable_caption() {
  set_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    caption_ = new ::std::string;
  }
  return caption_;
}
inline ::std::string* WholeSystemPaused::release_caption() {
  clear_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = caption_;
    caption_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WholeSystemPaused::set_allocated_caption(::std::string* caption) {
  if (caption_ != &::google::protobuf::internal::kEmptyString) {
    delete caption_;
  }
  if (caption) {
    set_has_caption();
    caption_ = caption;
  } else {
    clear_has_caption();
    caption_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string body = 2;
inline bool WholeSystemPaused::has_body() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WholeSystemPaused::set_has_body() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WholeSystemPaused::clear_has_body() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WholeSystemPaused::clear_body() {
  if (body_ != &::google::protobuf::internal::kEmptyString) {
    body_->clear();
  }
  clear_has_body();
}
inline const ::std::string& WholeSystemPaused::body() const {
  return *body_;
}
inline void WholeSystemPaused::set_body(const ::std::string& value) {
  set_has_body();
  if (body_ == &::google::protobuf::internal::kEmptyString) {
    body_ = new ::std::string;
  }
  body_->assign(value);
}
inline void WholeSystemPaused::set_body(const char* value) {
  set_has_body();
  if (body_ == &::google::protobuf::internal::kEmptyString) {
    body_ = new ::std::string;
  }
  body_->assign(value);
}
inline void WholeSystemPaused::set_body(const char* value, size_t size) {
  set_has_body();
  if (body_ == &::google::protobuf::internal::kEmptyString) {
    body_ = new ::std::string;
  }
  body_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WholeSystemPaused::mutable_body() {
  set_has_body();
  if (body_ == &::google::protobuf::internal::kEmptyString) {
    body_ = new ::std::string;
  }
  return body_;
}
inline ::std::string* WholeSystemPaused::release_body() {
  clear_has_body();
  if (body_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = body_;
    body_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WholeSystemPaused::set_allocated_body(::std::string* body) {
  if (body_ != &::google::protobuf::internal::kEmptyString) {
    delete body_;
  }
  if (body) {
    set_has_body();
    body_ = body;
  } else {
    clear_has_body();
    body_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GetServiceLayout

// optional string service_id = 1;
inline bool GetServiceLayout::has_service_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetServiceLayout::set_has_service_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetServiceLayout::clear_has_service_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetServiceLayout::clear_service_id() {
  if (service_id_ != &::google::protobuf::internal::kEmptyString) {
    service_id_->clear();
  }
  clear_has_service_id();
}
inline const ::std::string& GetServiceLayout::service_id() const {
  return *service_id_;
}
inline void GetServiceLayout::set_service_id(const ::std::string& value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
}
inline void GetServiceLayout::set_service_id(const char* value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
}
inline void GetServiceLayout::set_service_id(const char* value, size_t size) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetServiceLayout::mutable_service_id() {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  return service_id_;
}
inline ::std::string* GetServiceLayout::release_service_id() {
  clear_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = service_id_;
    service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetServiceLayout::set_allocated_service_id(::std::string* service_id) {
  if (service_id_ != &::google::protobuf::internal::kEmptyString) {
    delete service_id_;
  }
  if (service_id) {
    set_has_service_id();
    service_id_ = service_id;
  } else {
    clear_has_service_id();
    service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string bill_id = 2;
inline bool GetServiceLayout::has_bill_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetServiceLayout::set_has_bill_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetServiceLayout::clear_has_bill_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetServiceLayout::clear_bill_id() {
  if (bill_id_ != &::google::protobuf::internal::kEmptyString) {
    bill_id_->clear();
  }
  clear_has_bill_id();
}
inline const ::std::string& GetServiceLayout::bill_id() const {
  return *bill_id_;
}
inline void GetServiceLayout::set_bill_id(const ::std::string& value) {
  set_has_bill_id();
  if (bill_id_ == &::google::protobuf::internal::kEmptyString) {
    bill_id_ = new ::std::string;
  }
  bill_id_->assign(value);
}
inline void GetServiceLayout::set_bill_id(const char* value) {
  set_has_bill_id();
  if (bill_id_ == &::google::protobuf::internal::kEmptyString) {
    bill_id_ = new ::std::string;
  }
  bill_id_->assign(value);
}
inline void GetServiceLayout::set_bill_id(const char* value, size_t size) {
  set_has_bill_id();
  if (bill_id_ == &::google::protobuf::internal::kEmptyString) {
    bill_id_ = new ::std::string;
  }
  bill_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetServiceLayout::mutable_bill_id() {
  set_has_bill_id();
  if (bill_id_ == &::google::protobuf::internal::kEmptyString) {
    bill_id_ = new ::std::string;
  }
  return bill_id_;
}
inline ::std::string* GetServiceLayout::release_bill_id() {
  clear_has_bill_id();
  if (bill_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bill_id_;
    bill_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetServiceLayout::set_allocated_bill_id(::std::string* bill_id) {
  if (bill_id_ != &::google::protobuf::internal::kEmptyString) {
    delete bill_id_;
  }
  if (bill_id) {
    set_has_bill_id();
    bill_id_ = bill_id;
  } else {
    clear_has_bill_id();
    bill_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool has_check_bill = 3;
inline bool GetServiceLayout::has_has_check_bill() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetServiceLayout::set_has_has_check_bill() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetServiceLayout::clear_has_has_check_bill() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetServiceLayout::clear_has_check_bill() {
  has_check_bill_ = false;
  clear_has_has_check_bill();
}
inline bool GetServiceLayout::has_check_bill() const {
  return has_check_bill_;
}
inline void GetServiceLayout::set_has_check_bill(bool value) {
  set_has_has_check_bill();
  has_check_bill_ = value;
}

// optional string service_type = 4;
inline bool GetServiceLayout::has_service_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetServiceLayout::set_has_service_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetServiceLayout::clear_has_service_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetServiceLayout::clear_service_type() {
  if (service_type_ != &::google::protobuf::internal::kEmptyString) {
    service_type_->clear();
  }
  clear_has_service_type();
}
inline const ::std::string& GetServiceLayout::service_type() const {
  return *service_type_;
}
inline void GetServiceLayout::set_service_type(const ::std::string& value) {
  set_has_service_type();
  if (service_type_ == &::google::protobuf::internal::kEmptyString) {
    service_type_ = new ::std::string;
  }
  service_type_->assign(value);
}
inline void GetServiceLayout::set_service_type(const char* value) {
  set_has_service_type();
  if (service_type_ == &::google::protobuf::internal::kEmptyString) {
    service_type_ = new ::std::string;
  }
  service_type_->assign(value);
}
inline void GetServiceLayout::set_service_type(const char* value, size_t size) {
  set_has_service_type();
  if (service_type_ == &::google::protobuf::internal::kEmptyString) {
    service_type_ = new ::std::string;
  }
  service_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetServiceLayout::mutable_service_type() {
  set_has_service_type();
  if (service_type_ == &::google::protobuf::internal::kEmptyString) {
    service_type_ = new ::std::string;
  }
  return service_type_;
}
inline ::std::string* GetServiceLayout::release_service_type() {
  clear_has_service_type();
  if (service_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = service_type_;
    service_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetServiceLayout::set_allocated_service_type(::std::string* service_type) {
  if (service_type_ != &::google::protobuf::internal::kEmptyString) {
    delete service_type_;
  }
  if (service_type) {
    set_has_service_type();
    service_type_ = service_type;
  } else {
    clear_has_service_type();
    service_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool is_promo = 5;
inline bool GetServiceLayout::has_is_promo() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetServiceLayout::set_has_is_promo() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetServiceLayout::clear_has_is_promo() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetServiceLayout::clear_is_promo() {
  is_promo_ = false;
  clear_has_is_promo();
}
inline bool GetServiceLayout::is_promo() const {
  return is_promo_;
}
inline void GetServiceLayout::set_is_promo(bool value) {
  set_has_is_promo();
  is_promo_ = value;
}

// -------------------------------------------------------------------

// Invitee

// optional string name = 1;
inline bool Invitee::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Invitee::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Invitee::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Invitee::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Invitee::name() const {
  return *name_;
}
inline void Invitee::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Invitee::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Invitee::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Invitee::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Invitee::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Invitee::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string phone = 2;
inline bool Invitee::has_phone() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Invitee::set_has_phone() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Invitee::clear_has_phone() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Invitee::clear_phone() {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    phone_->clear();
  }
  clear_has_phone();
}
inline const ::std::string& Invitee::phone() const {
  return *phone_;
}
inline void Invitee::set_phone(const ::std::string& value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void Invitee::set_phone(const char* value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void Invitee::set_phone(const char* value, size_t size) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Invitee::mutable_phone() {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  return phone_;
}
inline ::std::string* Invitee::release_phone() {
  clear_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phone_;
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Invitee::set_allocated_phone(::std::string* phone) {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    delete phone_;
  }
  if (phone) {
    set_has_phone();
    phone_ = phone;
  } else {
    clear_has_phone();
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 time = 3;
inline bool Invitee::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Invitee::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Invitee::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Invitee::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::uint64 Invitee::time() const {
  return time_;
}
inline void Invitee::set_time(::google::protobuf::uint64 value) {
  set_has_time();
  time_ = value;
}

// -------------------------------------------------------------------

// InviteStatisticReply

// repeated .com.mservice.momo.msg.Invitee invitee_list = 1;
inline int InviteStatisticReply::invitee_list_size() const {
  return invitee_list_.size();
}
inline void InviteStatisticReply::clear_invitee_list() {
  invitee_list_.Clear();
}
inline const ::com::mservice::momo::msg::Invitee& InviteStatisticReply::invitee_list(int index) const {
  return invitee_list_.Get(index);
}
inline ::com::mservice::momo::msg::Invitee* InviteStatisticReply::mutable_invitee_list(int index) {
  return invitee_list_.Mutable(index);
}
inline ::com::mservice::momo::msg::Invitee* InviteStatisticReply::add_invitee_list() {
  return invitee_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::Invitee >&
InviteStatisticReply::invitee_list() const {
  return invitee_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::Invitee >*
InviteStatisticReply::mutable_invitee_list() {
  return &invitee_list_;
}

// -------------------------------------------------------------------

// TextValue

// optional string text = 1;
inline bool TextValue::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TextValue::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TextValue::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TextValue::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& TextValue::text() const {
  return *text_;
}
inline void TextValue::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void TextValue::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void TextValue::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TextValue::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* TextValue::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TextValue::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string value = 2;
inline bool TextValue::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TextValue::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TextValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TextValue::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& TextValue::value() const {
  return *value_;
}
inline void TextValue::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void TextValue::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void TextValue::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TextValue::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* TextValue::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TextValue::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string id = 3;
inline bool TextValue::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TextValue::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TextValue::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TextValue::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& TextValue::id() const {
  return *id_;
}
inline void TextValue::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void TextValue::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void TextValue::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TextValue::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* TextValue::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TextValue::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Service

// optional string service_type = 1;
inline bool Service::has_service_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Service::set_has_service_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Service::clear_has_service_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Service::clear_service_type() {
  if (service_type_ != &::google::protobuf::internal::kEmptyString) {
    service_type_->clear();
  }
  clear_has_service_type();
}
inline const ::std::string& Service::service_type() const {
  return *service_type_;
}
inline void Service::set_service_type(const ::std::string& value) {
  set_has_service_type();
  if (service_type_ == &::google::protobuf::internal::kEmptyString) {
    service_type_ = new ::std::string;
  }
  service_type_->assign(value);
}
inline void Service::set_service_type(const char* value) {
  set_has_service_type();
  if (service_type_ == &::google::protobuf::internal::kEmptyString) {
    service_type_ = new ::std::string;
  }
  service_type_->assign(value);
}
inline void Service::set_service_type(const char* value, size_t size) {
  set_has_service_type();
  if (service_type_ == &::google::protobuf::internal::kEmptyString) {
    service_type_ = new ::std::string;
  }
  service_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Service::mutable_service_type() {
  set_has_service_type();
  if (service_type_ == &::google::protobuf::internal::kEmptyString) {
    service_type_ = new ::std::string;
  }
  return service_type_;
}
inline ::std::string* Service::release_service_type() {
  clear_has_service_type();
  if (service_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = service_type_;
    service_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Service::set_allocated_service_type(::std::string* service_type) {
  if (service_type_ != &::google::protobuf::internal::kEmptyString) {
    delete service_type_;
  }
  if (service_type) {
    set_has_service_type();
    service_type_ = service_type;
  } else {
    clear_has_service_type();
    service_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ServiceItem

// optional string service_type = 1;
inline bool ServiceItem::has_service_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServiceItem::set_has_service_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServiceItem::clear_has_service_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServiceItem::clear_service_type() {
  if (service_type_ != &::google::protobuf::internal::kEmptyString) {
    service_type_->clear();
  }
  clear_has_service_type();
}
inline const ::std::string& ServiceItem::service_type() const {
  return *service_type_;
}
inline void ServiceItem::set_service_type(const ::std::string& value) {
  set_has_service_type();
  if (service_type_ == &::google::protobuf::internal::kEmptyString) {
    service_type_ = new ::std::string;
  }
  service_type_->assign(value);
}
inline void ServiceItem::set_service_type(const char* value) {
  set_has_service_type();
  if (service_type_ == &::google::protobuf::internal::kEmptyString) {
    service_type_ = new ::std::string;
  }
  service_type_->assign(value);
}
inline void ServiceItem::set_service_type(const char* value, size_t size) {
  set_has_service_type();
  if (service_type_ == &::google::protobuf::internal::kEmptyString) {
    service_type_ = new ::std::string;
  }
  service_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceItem::mutable_service_type() {
  set_has_service_type();
  if (service_type_ == &::google::protobuf::internal::kEmptyString) {
    service_type_ = new ::std::string;
  }
  return service_type_;
}
inline ::std::string* ServiceItem::release_service_type() {
  clear_has_service_type();
  if (service_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = service_type_;
    service_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServiceItem::set_allocated_service_type(::std::string* service_type) {
  if (service_type_ != &::google::protobuf::internal::kEmptyString) {
    delete service_type_;
  }
  if (service_type) {
    set_has_service_type();
    service_type_ = service_type;
  } else {
    clear_has_service_type();
    service_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string partner_code = 2;
inline bool ServiceItem::has_partner_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServiceItem::set_has_partner_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServiceItem::clear_has_partner_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServiceItem::clear_partner_code() {
  if (partner_code_ != &::google::protobuf::internal::kEmptyString) {
    partner_code_->clear();
  }
  clear_has_partner_code();
}
inline const ::std::string& ServiceItem::partner_code() const {
  return *partner_code_;
}
inline void ServiceItem::set_partner_code(const ::std::string& value) {
  set_has_partner_code();
  if (partner_code_ == &::google::protobuf::internal::kEmptyString) {
    partner_code_ = new ::std::string;
  }
  partner_code_->assign(value);
}
inline void ServiceItem::set_partner_code(const char* value) {
  set_has_partner_code();
  if (partner_code_ == &::google::protobuf::internal::kEmptyString) {
    partner_code_ = new ::std::string;
  }
  partner_code_->assign(value);
}
inline void ServiceItem::set_partner_code(const char* value, size_t size) {
  set_has_partner_code();
  if (partner_code_ == &::google::protobuf::internal::kEmptyString) {
    partner_code_ = new ::std::string;
  }
  partner_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceItem::mutable_partner_code() {
  set_has_partner_code();
  if (partner_code_ == &::google::protobuf::internal::kEmptyString) {
    partner_code_ = new ::std::string;
  }
  return partner_code_;
}
inline ::std::string* ServiceItem::release_partner_code() {
  clear_has_partner_code();
  if (partner_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = partner_code_;
    partner_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServiceItem::set_allocated_partner_code(::std::string* partner_code) {
  if (partner_code_ != &::google::protobuf::internal::kEmptyString) {
    delete partner_code_;
  }
  if (partner_code) {
    set_has_partner_code();
    partner_code_ = partner_code;
  } else {
    clear_has_partner_code();
    partner_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string service_id = 3;
inline bool ServiceItem::has_service_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServiceItem::set_has_service_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServiceItem::clear_has_service_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServiceItem::clear_service_id() {
  if (service_id_ != &::google::protobuf::internal::kEmptyString) {
    service_id_->clear();
  }
  clear_has_service_id();
}
inline const ::std::string& ServiceItem::service_id() const {
  return *service_id_;
}
inline void ServiceItem::set_service_id(const ::std::string& value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
}
inline void ServiceItem::set_service_id(const char* value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
}
inline void ServiceItem::set_service_id(const char* value, size_t size) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceItem::mutable_service_id() {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  return service_id_;
}
inline ::std::string* ServiceItem::release_service_id() {
  clear_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = service_id_;
    service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServiceItem::set_allocated_service_id(::std::string* service_id) {
  if (service_id_ != &::google::protobuf::internal::kEmptyString) {
    delete service_id_;
  }
  if (service_id) {
    set_has_service_id();
    service_id_ = service_id;
  } else {
    clear_has_service_id();
    service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string service_name = 4;
inline bool ServiceItem::has_service_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServiceItem::set_has_service_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServiceItem::clear_has_service_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServiceItem::clear_service_name() {
  if (service_name_ != &::google::protobuf::internal::kEmptyString) {
    service_name_->clear();
  }
  clear_has_service_name();
}
inline const ::std::string& ServiceItem::service_name() const {
  return *service_name_;
}
inline void ServiceItem::set_service_name(const ::std::string& value) {
  set_has_service_name();
  if (service_name_ == &::google::protobuf::internal::kEmptyString) {
    service_name_ = new ::std::string;
  }
  service_name_->assign(value);
}
inline void ServiceItem::set_service_name(const char* value) {
  set_has_service_name();
  if (service_name_ == &::google::protobuf::internal::kEmptyString) {
    service_name_ = new ::std::string;
  }
  service_name_->assign(value);
}
inline void ServiceItem::set_service_name(const char* value, size_t size) {
  set_has_service_name();
  if (service_name_ == &::google::protobuf::internal::kEmptyString) {
    service_name_ = new ::std::string;
  }
  service_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceItem::mutable_service_name() {
  set_has_service_name();
  if (service_name_ == &::google::protobuf::internal::kEmptyString) {
    service_name_ = new ::std::string;
  }
  return service_name_;
}
inline ::std::string* ServiceItem::release_service_name() {
  clear_has_service_name();
  if (service_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = service_name_;
    service_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServiceItem::set_allocated_service_name(::std::string* service_name) {
  if (service_name_ != &::google::protobuf::internal::kEmptyString) {
    delete service_name_;
  }
  if (service_name) {
    set_has_service_name();
    service_name_ = service_name;
  } else {
    clear_has_service_name();
    service_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string partner_site = 5;
inline bool ServiceItem::has_partner_site() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ServiceItem::set_has_partner_site() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ServiceItem::clear_has_partner_site() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ServiceItem::clear_partner_site() {
  if (partner_site_ != &::google::protobuf::internal::kEmptyString) {
    partner_site_->clear();
  }
  clear_has_partner_site();
}
inline const ::std::string& ServiceItem::partner_site() const {
  return *partner_site_;
}
inline void ServiceItem::set_partner_site(const ::std::string& value) {
  set_has_partner_site();
  if (partner_site_ == &::google::protobuf::internal::kEmptyString) {
    partner_site_ = new ::std::string;
  }
  partner_site_->assign(value);
}
inline void ServiceItem::set_partner_site(const char* value) {
  set_has_partner_site();
  if (partner_site_ == &::google::protobuf::internal::kEmptyString) {
    partner_site_ = new ::std::string;
  }
  partner_site_->assign(value);
}
inline void ServiceItem::set_partner_site(const char* value, size_t size) {
  set_has_partner_site();
  if (partner_site_ == &::google::protobuf::internal::kEmptyString) {
    partner_site_ = new ::std::string;
  }
  partner_site_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceItem::mutable_partner_site() {
  set_has_partner_site();
  if (partner_site_ == &::google::protobuf::internal::kEmptyString) {
    partner_site_ = new ::std::string;
  }
  return partner_site_;
}
inline ::std::string* ServiceItem::release_partner_site() {
  clear_has_partner_site();
  if (partner_site_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = partner_site_;
    partner_site_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServiceItem::set_allocated_partner_site(::std::string* partner_site) {
  if (partner_site_ != &::google::protobuf::internal::kEmptyString) {
    delete partner_site_;
  }
  if (partner_site) {
    set_has_partner_site();
    partner_site_ = partner_site;
  } else {
    clear_has_partner_site();
    partner_site_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string icon_url = 6;
inline bool ServiceItem::has_icon_url() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ServiceItem::set_has_icon_url() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ServiceItem::clear_has_icon_url() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ServiceItem::clear_icon_url() {
  if (icon_url_ != &::google::protobuf::internal::kEmptyString) {
    icon_url_->clear();
  }
  clear_has_icon_url();
}
inline const ::std::string& ServiceItem::icon_url() const {
  return *icon_url_;
}
inline void ServiceItem::set_icon_url(const ::std::string& value) {
  set_has_icon_url();
  if (icon_url_ == &::google::protobuf::internal::kEmptyString) {
    icon_url_ = new ::std::string;
  }
  icon_url_->assign(value);
}
inline void ServiceItem::set_icon_url(const char* value) {
  set_has_icon_url();
  if (icon_url_ == &::google::protobuf::internal::kEmptyString) {
    icon_url_ = new ::std::string;
  }
  icon_url_->assign(value);
}
inline void ServiceItem::set_icon_url(const char* value, size_t size) {
  set_has_icon_url();
  if (icon_url_ == &::google::protobuf::internal::kEmptyString) {
    icon_url_ = new ::std::string;
  }
  icon_url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceItem::mutable_icon_url() {
  set_has_icon_url();
  if (icon_url_ == &::google::protobuf::internal::kEmptyString) {
    icon_url_ = new ::std::string;
  }
  return icon_url_;
}
inline ::std::string* ServiceItem::release_icon_url() {
  clear_has_icon_url();
  if (icon_url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = icon_url_;
    icon_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServiceItem::set_allocated_icon_url(::std::string* icon_url) {
  if (icon_url_ != &::google::protobuf::internal::kEmptyString) {
    delete icon_url_;
  }
  if (icon_url) {
    set_has_icon_url();
    icon_url_ = icon_url;
  } else {
    clear_has_icon_url();
    icon_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 status = 7;
inline bool ServiceItem::has_status() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ServiceItem::set_has_status() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ServiceItem::clear_has_status() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ServiceItem::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 ServiceItem::status() const {
  return status_;
}
inline void ServiceItem::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
}

// optional string text_popup = 8;
inline bool ServiceItem::has_text_popup() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ServiceItem::set_has_text_popup() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ServiceItem::clear_has_text_popup() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ServiceItem::clear_text_popup() {
  if (text_popup_ != &::google::protobuf::internal::kEmptyString) {
    text_popup_->clear();
  }
  clear_has_text_popup();
}
inline const ::std::string& ServiceItem::text_popup() const {
  return *text_popup_;
}
inline void ServiceItem::set_text_popup(const ::std::string& value) {
  set_has_text_popup();
  if (text_popup_ == &::google::protobuf::internal::kEmptyString) {
    text_popup_ = new ::std::string;
  }
  text_popup_->assign(value);
}
inline void ServiceItem::set_text_popup(const char* value) {
  set_has_text_popup();
  if (text_popup_ == &::google::protobuf::internal::kEmptyString) {
    text_popup_ = new ::std::string;
  }
  text_popup_->assign(value);
}
inline void ServiceItem::set_text_popup(const char* value, size_t size) {
  set_has_text_popup();
  if (text_popup_ == &::google::protobuf::internal::kEmptyString) {
    text_popup_ = new ::std::string;
  }
  text_popup_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceItem::mutable_text_popup() {
  set_has_text_popup();
  if (text_popup_ == &::google::protobuf::internal::kEmptyString) {
    text_popup_ = new ::std::string;
  }
  return text_popup_;
}
inline ::std::string* ServiceItem::release_text_popup() {
  clear_has_text_popup();
  if (text_popup_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_popup_;
    text_popup_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServiceItem::set_allocated_text_popup(::std::string* text_popup) {
  if (text_popup_ != &::google::protobuf::internal::kEmptyString) {
    delete text_popup_;
  }
  if (text_popup) {
    set_has_text_popup();
    text_popup_ = text_popup;
  } else {
    clear_has_text_popup();
    text_popup_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool has_check_debit = 9;
inline bool ServiceItem::has_has_check_debit() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ServiceItem::set_has_has_check_debit() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ServiceItem::clear_has_has_check_debit() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ServiceItem::clear_has_check_debit() {
  has_check_debit_ = false;
  clear_has_has_check_debit();
}
inline bool ServiceItem::has_check_debit() const {
  return has_check_debit_;
}
inline void ServiceItem::set_has_check_debit(bool value) {
  set_has_has_check_debit();
  has_check_debit_ = value;
}

// optional string title_dialog = 10;
inline bool ServiceItem::has_title_dialog() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ServiceItem::set_has_title_dialog() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ServiceItem::clear_has_title_dialog() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ServiceItem::clear_title_dialog() {
  if (title_dialog_ != &::google::protobuf::internal::kEmptyString) {
    title_dialog_->clear();
  }
  clear_has_title_dialog();
}
inline const ::std::string& ServiceItem::title_dialog() const {
  return *title_dialog_;
}
inline void ServiceItem::set_title_dialog(const ::std::string& value) {
  set_has_title_dialog();
  if (title_dialog_ == &::google::protobuf::internal::kEmptyString) {
    title_dialog_ = new ::std::string;
  }
  title_dialog_->assign(value);
}
inline void ServiceItem::set_title_dialog(const char* value) {
  set_has_title_dialog();
  if (title_dialog_ == &::google::protobuf::internal::kEmptyString) {
    title_dialog_ = new ::std::string;
  }
  title_dialog_->assign(value);
}
inline void ServiceItem::set_title_dialog(const char* value, size_t size) {
  set_has_title_dialog();
  if (title_dialog_ == &::google::protobuf::internal::kEmptyString) {
    title_dialog_ = new ::std::string;
  }
  title_dialog_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceItem::mutable_title_dialog() {
  set_has_title_dialog();
  if (title_dialog_ == &::google::protobuf::internal::kEmptyString) {
    title_dialog_ = new ::std::string;
  }
  return title_dialog_;
}
inline ::std::string* ServiceItem::release_title_dialog() {
  clear_has_title_dialog();
  if (title_dialog_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = title_dialog_;
    title_dialog_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServiceItem::set_allocated_title_dialog(::std::string* title_dialog) {
  if (title_dialog_ != &::google::protobuf::internal::kEmptyString) {
    delete title_dialog_;
  }
  if (title_dialog) {
    set_has_title_dialog();
    title_dialog_ = title_dialog;
  } else {
    clear_has_title_dialog();
    title_dialog_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 last_update = 11;
inline bool ServiceItem::has_last_update() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ServiceItem::set_has_last_update() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ServiceItem::clear_has_last_update() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ServiceItem::clear_last_update() {
  last_update_ = GOOGLE_ULONGLONG(0);
  clear_has_last_update();
}
inline ::google::protobuf::uint64 ServiceItem::last_update() const {
  return last_update_;
}
inline void ServiceItem::set_last_update(::google::protobuf::uint64 value) {
  set_has_last_update();
  last_update_ = value;
}

// optional string billid_type = 12;
inline bool ServiceItem::has_billid_type() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ServiceItem::set_has_billid_type() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ServiceItem::clear_has_billid_type() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ServiceItem::clear_billid_type() {
  if (billid_type_ != &::google::protobuf::internal::kEmptyString) {
    billid_type_->clear();
  }
  clear_has_billid_type();
}
inline const ::std::string& ServiceItem::billid_type() const {
  return *billid_type_;
}
inline void ServiceItem::set_billid_type(const ::std::string& value) {
  set_has_billid_type();
  if (billid_type_ == &::google::protobuf::internal::kEmptyString) {
    billid_type_ = new ::std::string;
  }
  billid_type_->assign(value);
}
inline void ServiceItem::set_billid_type(const char* value) {
  set_has_billid_type();
  if (billid_type_ == &::google::protobuf::internal::kEmptyString) {
    billid_type_ = new ::std::string;
  }
  billid_type_->assign(value);
}
inline void ServiceItem::set_billid_type(const char* value, size_t size) {
  set_has_billid_type();
  if (billid_type_ == &::google::protobuf::internal::kEmptyString) {
    billid_type_ = new ::std::string;
  }
  billid_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceItem::mutable_billid_type() {
  set_has_billid_type();
  if (billid_type_ == &::google::protobuf::internal::kEmptyString) {
    billid_type_ = new ::std::string;
  }
  return billid_type_;
}
inline ::std::string* ServiceItem::release_billid_type() {
  clear_has_billid_type();
  if (billid_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = billid_type_;
    billid_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServiceItem::set_allocated_billid_type(::std::string* billid_type) {
  if (billid_type_ != &::google::protobuf::internal::kEmptyString) {
    delete billid_type_;
  }
  if (billid_type) {
    set_has_billid_type();
    billid_type_ = billid_type;
  } else {
    clear_has_billid_type();
    billid_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool is_promo = 13;
inline bool ServiceItem::has_is_promo() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ServiceItem::set_has_is_promo() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ServiceItem::clear_has_is_promo() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ServiceItem::clear_is_promo() {
  is_promo_ = false;
  clear_has_is_promo();
}
inline bool ServiceItem::is_promo() const {
  return is_promo_;
}
inline void ServiceItem::set_is_promo(bool value) {
  set_has_is_promo();
  is_promo_ = value;
}

// optional uint32 total_form = 14;
inline bool ServiceItem::has_total_form() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ServiceItem::set_has_total_form() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ServiceItem::clear_has_total_form() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ServiceItem::clear_total_form() {
  total_form_ = 0u;
  clear_has_total_form();
}
inline ::google::protobuf::uint32 ServiceItem::total_form() const {
  return total_form_;
}
inline void ServiceItem::set_total_form(::google::protobuf::uint32 value) {
  set_has_total_form();
  total_form_ = value;
}

// optional uint32 star = 15;
inline bool ServiceItem::has_star() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ServiceItem::set_has_star() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ServiceItem::clear_has_star() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ServiceItem::clear_star() {
  star_ = 0u;
  clear_has_star();
}
inline ::google::protobuf::uint32 ServiceItem::star() const {
  return star_;
}
inline void ServiceItem::set_star(::google::protobuf::uint32 value) {
  set_has_star();
  star_ = value;
}

// optional string category_name = 16;
inline bool ServiceItem::has_category_name() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ServiceItem::set_has_category_name() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ServiceItem::clear_has_category_name() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ServiceItem::clear_category_name() {
  if (category_name_ != &::google::protobuf::internal::kEmptyString) {
    category_name_->clear();
  }
  clear_has_category_name();
}
inline const ::std::string& ServiceItem::category_name() const {
  return *category_name_;
}
inline void ServiceItem::set_category_name(const ::std::string& value) {
  set_has_category_name();
  if (category_name_ == &::google::protobuf::internal::kEmptyString) {
    category_name_ = new ::std::string;
  }
  category_name_->assign(value);
}
inline void ServiceItem::set_category_name(const char* value) {
  set_has_category_name();
  if (category_name_ == &::google::protobuf::internal::kEmptyString) {
    category_name_ = new ::std::string;
  }
  category_name_->assign(value);
}
inline void ServiceItem::set_category_name(const char* value, size_t size) {
  set_has_category_name();
  if (category_name_ == &::google::protobuf::internal::kEmptyString) {
    category_name_ = new ::std::string;
  }
  category_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceItem::mutable_category_name() {
  set_has_category_name();
  if (category_name_ == &::google::protobuf::internal::kEmptyString) {
    category_name_ = new ::std::string;
  }
  return category_name_;
}
inline ::std::string* ServiceItem::release_category_name() {
  clear_has_category_name();
  if (category_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = category_name_;
    category_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServiceItem::set_allocated_category_name(::std::string* category_name) {
  if (category_name_ != &::google::protobuf::internal::kEmptyString) {
    delete category_name_;
  }
  if (category_name) {
    set_has_category_name();
    category_name_ = category_name;
  } else {
    clear_has_category_name();
    category_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string category_id = 17;
inline bool ServiceItem::has_category_id() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ServiceItem::set_has_category_id() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ServiceItem::clear_has_category_id() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ServiceItem::clear_category_id() {
  if (category_id_ != &::google::protobuf::internal::kEmptyString) {
    category_id_->clear();
  }
  clear_has_category_id();
}
inline const ::std::string& ServiceItem::category_id() const {
  return *category_id_;
}
inline void ServiceItem::set_category_id(const ::std::string& value) {
  set_has_category_id();
  if (category_id_ == &::google::protobuf::internal::kEmptyString) {
    category_id_ = new ::std::string;
  }
  category_id_->assign(value);
}
inline void ServiceItem::set_category_id(const char* value) {
  set_has_category_id();
  if (category_id_ == &::google::protobuf::internal::kEmptyString) {
    category_id_ = new ::std::string;
  }
  category_id_->assign(value);
}
inline void ServiceItem::set_category_id(const char* value, size_t size) {
  set_has_category_id();
  if (category_id_ == &::google::protobuf::internal::kEmptyString) {
    category_id_ = new ::std::string;
  }
  category_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceItem::mutable_category_id() {
  set_has_category_id();
  if (category_id_ == &::google::protobuf::internal::kEmptyString) {
    category_id_ = new ::std::string;
  }
  return category_id_;
}
inline ::std::string* ServiceItem::release_category_id() {
  clear_has_category_id();
  if (category_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = category_id_;
    category_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServiceItem::set_allocated_category_id(::std::string* category_id) {
  if (category_id_ != &::google::protobuf::internal::kEmptyString) {
    delete category_id_;
  }
  if (category_id) {
    set_has_category_id();
    category_id_ = category_id;
  } else {
    clear_has_category_id();
    category_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string web_payment_url = 18;
inline bool ServiceItem::has_web_payment_url() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ServiceItem::set_has_web_payment_url() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ServiceItem::clear_has_web_payment_url() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ServiceItem::clear_web_payment_url() {
  if (web_payment_url_ != &::google::protobuf::internal::kEmptyString) {
    web_payment_url_->clear();
  }
  clear_has_web_payment_url();
}
inline const ::std::string& ServiceItem::web_payment_url() const {
  return *web_payment_url_;
}
inline void ServiceItem::set_web_payment_url(const ::std::string& value) {
  set_has_web_payment_url();
  if (web_payment_url_ == &::google::protobuf::internal::kEmptyString) {
    web_payment_url_ = new ::std::string;
  }
  web_payment_url_->assign(value);
}
inline void ServiceItem::set_web_payment_url(const char* value) {
  set_has_web_payment_url();
  if (web_payment_url_ == &::google::protobuf::internal::kEmptyString) {
    web_payment_url_ = new ::std::string;
  }
  web_payment_url_->assign(value);
}
inline void ServiceItem::set_web_payment_url(const char* value, size_t size) {
  set_has_web_payment_url();
  if (web_payment_url_ == &::google::protobuf::internal::kEmptyString) {
    web_payment_url_ = new ::std::string;
  }
  web_payment_url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceItem::mutable_web_payment_url() {
  set_has_web_payment_url();
  if (web_payment_url_ == &::google::protobuf::internal::kEmptyString) {
    web_payment_url_ = new ::std::string;
  }
  return web_payment_url_;
}
inline ::std::string* ServiceItem::release_web_payment_url() {
  clear_has_web_payment_url();
  if (web_payment_url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = web_payment_url_;
    web_payment_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServiceItem::set_allocated_web_payment_url(::std::string* web_payment_url) {
  if (web_payment_url_ != &::google::protobuf::internal::kEmptyString) {
    delete web_payment_url_;
  }
  if (web_payment_url) {
    set_has_web_payment_url();
    web_payment_url_ = web_payment_url;
  } else {
    clear_has_web_payment_url();
    web_payment_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string secret_key = 19;
inline bool ServiceItem::has_secret_key() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void ServiceItem::set_has_secret_key() {
  _has_bits_[0] |= 0x00040000u;
}
inline void ServiceItem::clear_has_secret_key() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void ServiceItem::clear_secret_key() {
  if (secret_key_ != &::google::protobuf::internal::kEmptyString) {
    secret_key_->clear();
  }
  clear_has_secret_key();
}
inline const ::std::string& ServiceItem::secret_key() const {
  return *secret_key_;
}
inline void ServiceItem::set_secret_key(const ::std::string& value) {
  set_has_secret_key();
  if (secret_key_ == &::google::protobuf::internal::kEmptyString) {
    secret_key_ = new ::std::string;
  }
  secret_key_->assign(value);
}
inline void ServiceItem::set_secret_key(const char* value) {
  set_has_secret_key();
  if (secret_key_ == &::google::protobuf::internal::kEmptyString) {
    secret_key_ = new ::std::string;
  }
  secret_key_->assign(value);
}
inline void ServiceItem::set_secret_key(const char* value, size_t size) {
  set_has_secret_key();
  if (secret_key_ == &::google::protobuf::internal::kEmptyString) {
    secret_key_ = new ::std::string;
  }
  secret_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceItem::mutable_secret_key() {
  set_has_secret_key();
  if (secret_key_ == &::google::protobuf::internal::kEmptyString) {
    secret_key_ = new ::std::string;
  }
  return secret_key_;
}
inline ::std::string* ServiceItem::release_secret_key() {
  clear_has_secret_key();
  if (secret_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = secret_key_;
    secret_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServiceItem::set_allocated_secret_key(::std::string* secret_key) {
  if (secret_key_ != &::google::protobuf::internal::kEmptyString) {
    delete secret_key_;
  }
  if (secret_key) {
    set_has_secret_key();
    secret_key_ = secret_key;
  } else {
    clear_has_secret_key();
    secret_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 order = 20;
inline bool ServiceItem::has_order() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void ServiceItem::set_has_order() {
  _has_bits_[0] |= 0x00080000u;
}
inline void ServiceItem::clear_has_order() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void ServiceItem::clear_order() {
  order_ = 0u;
  clear_has_order();
}
inline ::google::protobuf::uint32 ServiceItem::order() const {
  return order_;
}
inline void ServiceItem::set_order(::google::protobuf::uint32 value) {
  set_has_order();
  order_ = value;
}

// optional string billpay_extra = 21;
inline bool ServiceItem::has_billpay_extra() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void ServiceItem::set_has_billpay_extra() {
  _has_bits_[0] |= 0x00100000u;
}
inline void ServiceItem::clear_has_billpay_extra() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void ServiceItem::clear_billpay_extra() {
  if (billpay_extra_ != &::google::protobuf::internal::kEmptyString) {
    billpay_extra_->clear();
  }
  clear_has_billpay_extra();
}
inline const ::std::string& ServiceItem::billpay_extra() const {
  return *billpay_extra_;
}
inline void ServiceItem::set_billpay_extra(const ::std::string& value) {
  set_has_billpay_extra();
  if (billpay_extra_ == &::google::protobuf::internal::kEmptyString) {
    billpay_extra_ = new ::std::string;
  }
  billpay_extra_->assign(value);
}
inline void ServiceItem::set_billpay_extra(const char* value) {
  set_has_billpay_extra();
  if (billpay_extra_ == &::google::protobuf::internal::kEmptyString) {
    billpay_extra_ = new ::std::string;
  }
  billpay_extra_->assign(value);
}
inline void ServiceItem::set_billpay_extra(const char* value, size_t size) {
  set_has_billpay_extra();
  if (billpay_extra_ == &::google::protobuf::internal::kEmptyString) {
    billpay_extra_ = new ::std::string;
  }
  billpay_extra_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceItem::mutable_billpay_extra() {
  set_has_billpay_extra();
  if (billpay_extra_ == &::google::protobuf::internal::kEmptyString) {
    billpay_extra_ = new ::std::string;
  }
  return billpay_extra_;
}
inline ::std::string* ServiceItem::release_billpay_extra() {
  clear_has_billpay_extra();
  if (billpay_extra_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = billpay_extra_;
    billpay_extra_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServiceItem::set_allocated_billpay_extra(::std::string* billpay_extra) {
  if (billpay_extra_ != &::google::protobuf::internal::kEmptyString) {
    delete billpay_extra_;
  }
  if (billpay_extra) {
    set_has_billpay_extra();
    billpay_extra_ = billpay_extra;
  } else {
    clear_has_billpay_extra();
    billpay_extra_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ServiceReply

// repeated .com.mservice.momo.msg.ServiceItem service_list = 1;
inline int ServiceReply::service_list_size() const {
  return service_list_.size();
}
inline void ServiceReply::clear_service_list() {
  service_list_.Clear();
}
inline const ::com::mservice::momo::msg::ServiceItem& ServiceReply::service_list(int index) const {
  return service_list_.Get(index);
}
inline ::com::mservice::momo::msg::ServiceItem* ServiceReply::mutable_service_list(int index) {
  return service_list_.Mutable(index);
}
inline ::com::mservice::momo::msg::ServiceItem* ServiceReply::add_service_list() {
  return service_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::ServiceItem >&
ServiceReply::service_list() const {
  return service_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::ServiceItem >*
ServiceReply::mutable_service_list() {
  return &service_list_;
}

// -------------------------------------------------------------------

// FieldItem

// optional string field_label = 1;
inline bool FieldItem::has_field_label() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FieldItem::set_has_field_label() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FieldItem::clear_has_field_label() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FieldItem::clear_field_label() {
  if (field_label_ != &::google::protobuf::internal::kEmptyString) {
    field_label_->clear();
  }
  clear_has_field_label();
}
inline const ::std::string& FieldItem::field_label() const {
  return *field_label_;
}
inline void FieldItem::set_field_label(const ::std::string& value) {
  set_has_field_label();
  if (field_label_ == &::google::protobuf::internal::kEmptyString) {
    field_label_ = new ::std::string;
  }
  field_label_->assign(value);
}
inline void FieldItem::set_field_label(const char* value) {
  set_has_field_label();
  if (field_label_ == &::google::protobuf::internal::kEmptyString) {
    field_label_ = new ::std::string;
  }
  field_label_->assign(value);
}
inline void FieldItem::set_field_label(const char* value, size_t size) {
  set_has_field_label();
  if (field_label_ == &::google::protobuf::internal::kEmptyString) {
    field_label_ = new ::std::string;
  }
  field_label_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FieldItem::mutable_field_label() {
  set_has_field_label();
  if (field_label_ == &::google::protobuf::internal::kEmptyString) {
    field_label_ = new ::std::string;
  }
  return field_label_;
}
inline ::std::string* FieldItem::release_field_label() {
  clear_has_field_label();
  if (field_label_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = field_label_;
    field_label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FieldItem::set_allocated_field_label(::std::string* field_label) {
  if (field_label_ != &::google::protobuf::internal::kEmptyString) {
    delete field_label_;
  }
  if (field_label) {
    set_has_field_label();
    field_label_ = field_label;
  } else {
    clear_has_field_label();
    field_label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string field_type = 2;
inline bool FieldItem::has_field_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FieldItem::set_has_field_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FieldItem::clear_has_field_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FieldItem::clear_field_type() {
  if (field_type_ != &::google::protobuf::internal::kEmptyString) {
    field_type_->clear();
  }
  clear_has_field_type();
}
inline const ::std::string& FieldItem::field_type() const {
  return *field_type_;
}
inline void FieldItem::set_field_type(const ::std::string& value) {
  set_has_field_type();
  if (field_type_ == &::google::protobuf::internal::kEmptyString) {
    field_type_ = new ::std::string;
  }
  field_type_->assign(value);
}
inline void FieldItem::set_field_type(const char* value) {
  set_has_field_type();
  if (field_type_ == &::google::protobuf::internal::kEmptyString) {
    field_type_ = new ::std::string;
  }
  field_type_->assign(value);
}
inline void FieldItem::set_field_type(const char* value, size_t size) {
  set_has_field_type();
  if (field_type_ == &::google::protobuf::internal::kEmptyString) {
    field_type_ = new ::std::string;
  }
  field_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FieldItem::mutable_field_type() {
  set_has_field_type();
  if (field_type_ == &::google::protobuf::internal::kEmptyString) {
    field_type_ = new ::std::string;
  }
  return field_type_;
}
inline ::std::string* FieldItem::release_field_type() {
  clear_has_field_type();
  if (field_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = field_type_;
    field_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FieldItem::set_allocated_field_type(::std::string* field_type) {
  if (field_type_ != &::google::protobuf::internal::kEmptyString) {
    delete field_type_;
  }
  if (field_type) {
    set_has_field_type();
    field_type_ = field_type;
  } else {
    clear_has_field_type();
    field_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool is_amount = 3;
inline bool FieldItem::has_is_amount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FieldItem::set_has_is_amount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FieldItem::clear_has_is_amount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FieldItem::clear_is_amount() {
  is_amount_ = false;
  clear_has_is_amount();
}
inline bool FieldItem::is_amount() const {
  return is_amount_;
}
inline void FieldItem::set_is_amount(bool value) {
  set_has_is_amount();
  is_amount_ = value;
}

// optional bool is_bill_id = 4;
inline bool FieldItem::has_is_bill_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FieldItem::set_has_is_bill_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FieldItem::clear_has_is_bill_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FieldItem::clear_is_bill_id() {
  is_bill_id_ = false;
  clear_has_is_bill_id();
}
inline bool FieldItem::is_bill_id() const {
  return is_bill_id_;
}
inline void FieldItem::set_is_bill_id(bool value) {
  set_has_is_bill_id();
  is_bill_id_ = value;
}

// optional string key = 5;
inline bool FieldItem::has_key() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FieldItem::set_has_key() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FieldItem::clear_has_key() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FieldItem::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& FieldItem::key() const {
  return *key_;
}
inline void FieldItem::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void FieldItem::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void FieldItem::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FieldItem::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* FieldItem::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FieldItem::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 require = 6;
inline bool FieldItem::has_require() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FieldItem::set_has_require() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FieldItem::clear_has_require() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FieldItem::clear_require() {
  require_ = 0u;
  clear_has_require();
}
inline ::google::protobuf::uint32 FieldItem::require() const {
  return require_;
}
inline void FieldItem::set_require(::google::protobuf::uint32 value) {
  set_has_require();
  require_ = value;
}

// optional uint32 has_child = 7;
inline bool FieldItem::has_has_child() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FieldItem::set_has_has_child() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FieldItem::clear_has_has_child() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FieldItem::clear_has_child() {
  has_child_ = 0u;
  clear_has_has_child();
}
inline ::google::protobuf::uint32 FieldItem::has_child() const {
  return has_child_;
}
inline void FieldItem::set_has_child(::google::protobuf::uint32 value) {
  set_has_has_child();
  has_child_ = value;
}

// optional uint32 line = 8;
inline bool FieldItem::has_line() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FieldItem::set_has_line() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FieldItem::clear_has_line() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FieldItem::clear_line() {
  line_ = 0u;
  clear_has_line();
}
inline ::google::protobuf::uint32 FieldItem::line() const {
  return line_;
}
inline void FieldItem::set_line(::google::protobuf::uint32 value) {
  set_has_line();
  line_ = value;
}

// optional bool readonly = 9;
inline bool FieldItem::has_readonly() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void FieldItem::set_has_readonly() {
  _has_bits_[0] |= 0x00000100u;
}
inline void FieldItem::clear_has_readonly() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void FieldItem::clear_readonly() {
  readonly_ = false;
  clear_has_readonly();
}
inline bool FieldItem::readonly() const {
  return readonly_;
}
inline void FieldItem::set_readonly(bool value) {
  set_has_readonly();
  readonly_ = value;
}

// optional string value = 10;
inline bool FieldItem::has_value() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void FieldItem::set_has_value() {
  _has_bits_[0] |= 0x00000200u;
}
inline void FieldItem::clear_has_value() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void FieldItem::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& FieldItem::value() const {
  return *value_;
}
inline void FieldItem::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void FieldItem::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void FieldItem::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FieldItem::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* FieldItem::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FieldItem::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ExtraInfo

// optional string bill_detail_id = 1;
inline bool ExtraInfo::has_bill_detail_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExtraInfo::set_has_bill_detail_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExtraInfo::clear_has_bill_detail_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExtraInfo::clear_bill_detail_id() {
  if (bill_detail_id_ != &::google::protobuf::internal::kEmptyString) {
    bill_detail_id_->clear();
  }
  clear_has_bill_detail_id();
}
inline const ::std::string& ExtraInfo::bill_detail_id() const {
  return *bill_detail_id_;
}
inline void ExtraInfo::set_bill_detail_id(const ::std::string& value) {
  set_has_bill_detail_id();
  if (bill_detail_id_ == &::google::protobuf::internal::kEmptyString) {
    bill_detail_id_ = new ::std::string;
  }
  bill_detail_id_->assign(value);
}
inline void ExtraInfo::set_bill_detail_id(const char* value) {
  set_has_bill_detail_id();
  if (bill_detail_id_ == &::google::protobuf::internal::kEmptyString) {
    bill_detail_id_ = new ::std::string;
  }
  bill_detail_id_->assign(value);
}
inline void ExtraInfo::set_bill_detail_id(const char* value, size_t size) {
  set_has_bill_detail_id();
  if (bill_detail_id_ == &::google::protobuf::internal::kEmptyString) {
    bill_detail_id_ = new ::std::string;
  }
  bill_detail_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExtraInfo::mutable_bill_detail_id() {
  set_has_bill_detail_id();
  if (bill_detail_id_ == &::google::protobuf::internal::kEmptyString) {
    bill_detail_id_ = new ::std::string;
  }
  return bill_detail_id_;
}
inline ::std::string* ExtraInfo::release_bill_detail_id() {
  clear_has_bill_detail_id();
  if (bill_detail_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bill_detail_id_;
    bill_detail_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExtraInfo::set_allocated_bill_detail_id(::std::string* bill_detail_id) {
  if (bill_detail_id_ != &::google::protobuf::internal::kEmptyString) {
    delete bill_detail_id_;
  }
  if (bill_detail_id) {
    set_has_bill_detail_id();
    bill_detail_id_ = bill_detail_id;
  } else {
    clear_has_bill_detail_id();
    bill_detail_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string amount = 2;
inline bool ExtraInfo::has_amount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExtraInfo::set_has_amount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExtraInfo::clear_has_amount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExtraInfo::clear_amount() {
  if (amount_ != &::google::protobuf::internal::kEmptyString) {
    amount_->clear();
  }
  clear_has_amount();
}
inline const ::std::string& ExtraInfo::amount() const {
  return *amount_;
}
inline void ExtraInfo::set_amount(const ::std::string& value) {
  set_has_amount();
  if (amount_ == &::google::protobuf::internal::kEmptyString) {
    amount_ = new ::std::string;
  }
  amount_->assign(value);
}
inline void ExtraInfo::set_amount(const char* value) {
  set_has_amount();
  if (amount_ == &::google::protobuf::internal::kEmptyString) {
    amount_ = new ::std::string;
  }
  amount_->assign(value);
}
inline void ExtraInfo::set_amount(const char* value, size_t size) {
  set_has_amount();
  if (amount_ == &::google::protobuf::internal::kEmptyString) {
    amount_ = new ::std::string;
  }
  amount_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExtraInfo::mutable_amount() {
  set_has_amount();
  if (amount_ == &::google::protobuf::internal::kEmptyString) {
    amount_ = new ::std::string;
  }
  return amount_;
}
inline ::std::string* ExtraInfo::release_amount() {
  clear_has_amount();
  if (amount_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = amount_;
    amount_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExtraInfo::set_allocated_amount(::std::string* amount) {
  if (amount_ != &::google::protobuf::internal::kEmptyString) {
    delete amount_;
  }
  if (amount) {
    set_has_amount();
    amount_ = amount;
  } else {
    clear_has_amount();
    amount_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string from_date = 3;
inline bool ExtraInfo::has_from_date() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExtraInfo::set_has_from_date() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExtraInfo::clear_has_from_date() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExtraInfo::clear_from_date() {
  if (from_date_ != &::google::protobuf::internal::kEmptyString) {
    from_date_->clear();
  }
  clear_has_from_date();
}
inline const ::std::string& ExtraInfo::from_date() const {
  return *from_date_;
}
inline void ExtraInfo::set_from_date(const ::std::string& value) {
  set_has_from_date();
  if (from_date_ == &::google::protobuf::internal::kEmptyString) {
    from_date_ = new ::std::string;
  }
  from_date_->assign(value);
}
inline void ExtraInfo::set_from_date(const char* value) {
  set_has_from_date();
  if (from_date_ == &::google::protobuf::internal::kEmptyString) {
    from_date_ = new ::std::string;
  }
  from_date_->assign(value);
}
inline void ExtraInfo::set_from_date(const char* value, size_t size) {
  set_has_from_date();
  if (from_date_ == &::google::protobuf::internal::kEmptyString) {
    from_date_ = new ::std::string;
  }
  from_date_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExtraInfo::mutable_from_date() {
  set_has_from_date();
  if (from_date_ == &::google::protobuf::internal::kEmptyString) {
    from_date_ = new ::std::string;
  }
  return from_date_;
}
inline ::std::string* ExtraInfo::release_from_date() {
  clear_has_from_date();
  if (from_date_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = from_date_;
    from_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExtraInfo::set_allocated_from_date(::std::string* from_date) {
  if (from_date_ != &::google::protobuf::internal::kEmptyString) {
    delete from_date_;
  }
  if (from_date) {
    set_has_from_date();
    from_date_ = from_date;
  } else {
    clear_has_from_date();
    from_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string to_date = 4;
inline bool ExtraInfo::has_to_date() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ExtraInfo::set_has_to_date() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ExtraInfo::clear_has_to_date() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ExtraInfo::clear_to_date() {
  if (to_date_ != &::google::protobuf::internal::kEmptyString) {
    to_date_->clear();
  }
  clear_has_to_date();
}
inline const ::std::string& ExtraInfo::to_date() const {
  return *to_date_;
}
inline void ExtraInfo::set_to_date(const ::std::string& value) {
  set_has_to_date();
  if (to_date_ == &::google::protobuf::internal::kEmptyString) {
    to_date_ = new ::std::string;
  }
  to_date_->assign(value);
}
inline void ExtraInfo::set_to_date(const char* value) {
  set_has_to_date();
  if (to_date_ == &::google::protobuf::internal::kEmptyString) {
    to_date_ = new ::std::string;
  }
  to_date_->assign(value);
}
inline void ExtraInfo::set_to_date(const char* value, size_t size) {
  set_has_to_date();
  if (to_date_ == &::google::protobuf::internal::kEmptyString) {
    to_date_ = new ::std::string;
  }
  to_date_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExtraInfo::mutable_to_date() {
  set_has_to_date();
  if (to_date_ == &::google::protobuf::internal::kEmptyString) {
    to_date_ = new ::std::string;
  }
  return to_date_;
}
inline ::std::string* ExtraInfo::release_to_date() {
  clear_has_to_date();
  if (to_date_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = to_date_;
    to_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExtraInfo::set_allocated_to_date(::std::string* to_date) {
  if (to_date_ != &::google::protobuf::internal::kEmptyString) {
    delete to_date_;
  }
  if (to_date) {
    set_has_to_date();
    to_date_ = to_date;
  } else {
    clear_has_to_date();
    to_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GetServiceLayoutReply

// optional uint64 total_amount = 1;
inline bool GetServiceLayoutReply::has_total_amount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetServiceLayoutReply::set_has_total_amount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetServiceLayoutReply::clear_has_total_amount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetServiceLayoutReply::clear_total_amount() {
  total_amount_ = GOOGLE_ULONGLONG(0);
  clear_has_total_amount();
}
inline ::google::protobuf::uint64 GetServiceLayoutReply::total_amount() const {
  return total_amount_;
}
inline void GetServiceLayoutReply::set_total_amount(::google::protobuf::uint64 value) {
  set_has_total_amount();
  total_amount_ = value;
}

// repeated .com.mservice.momo.msg.FieldItem list_field = 2;
inline int GetServiceLayoutReply::list_field_size() const {
  return list_field_.size();
}
inline void GetServiceLayoutReply::clear_list_field() {
  list_field_.Clear();
}
inline const ::com::mservice::momo::msg::FieldItem& GetServiceLayoutReply::list_field(int index) const {
  return list_field_.Get(index);
}
inline ::com::mservice::momo::msg::FieldItem* GetServiceLayoutReply::mutable_list_field(int index) {
  return list_field_.Mutable(index);
}
inline ::com::mservice::momo::msg::FieldItem* GetServiceLayoutReply::add_list_field() {
  return list_field_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::FieldItem >&
GetServiceLayoutReply::list_field() const {
  return list_field_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::FieldItem >*
GetServiceLayoutReply::mutable_list_field() {
  return &list_field_;
}

// repeated .com.mservice.momo.msg.TextValue array_price = 3;
inline int GetServiceLayoutReply::array_price_size() const {
  return array_price_.size();
}
inline void GetServiceLayoutReply::clear_array_price() {
  array_price_.Clear();
}
inline const ::com::mservice::momo::msg::TextValue& GetServiceLayoutReply::array_price(int index) const {
  return array_price_.Get(index);
}
inline ::com::mservice::momo::msg::TextValue* GetServiceLayoutReply::mutable_array_price(int index) {
  return array_price_.Mutable(index);
}
inline ::com::mservice::momo::msg::TextValue* GetServiceLayoutReply::add_array_price() {
  return array_price_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::TextValue >&
GetServiceLayoutReply::array_price() const {
  return array_price_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::TextValue >*
GetServiceLayoutReply::mutable_array_price() {
  return &array_price_;
}

// repeated .com.mservice.momo.msg.TextValue customer_info = 4;
inline int GetServiceLayoutReply::customer_info_size() const {
  return customer_info_.size();
}
inline void GetServiceLayoutReply::clear_customer_info() {
  customer_info_.Clear();
}
inline const ::com::mservice::momo::msg::TextValue& GetServiceLayoutReply::customer_info(int index) const {
  return customer_info_.Get(index);
}
inline ::com::mservice::momo::msg::TextValue* GetServiceLayoutReply::mutable_customer_info(int index) {
  return customer_info_.Mutable(index);
}
inline ::com::mservice::momo::msg::TextValue* GetServiceLayoutReply::add_customer_info() {
  return customer_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::TextValue >&
GetServiceLayoutReply::customer_info() const {
  return customer_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::TextValue >*
GetServiceLayoutReply::mutable_customer_info() {
  return &customer_info_;
}

// repeated .com.mservice.momo.msg.ExtraInfo extra_info = 5;
inline int GetServiceLayoutReply::extra_info_size() const {
  return extra_info_.size();
}
inline void GetServiceLayoutReply::clear_extra_info() {
  extra_info_.Clear();
}
inline const ::com::mservice::momo::msg::ExtraInfo& GetServiceLayoutReply::extra_info(int index) const {
  return extra_info_.Get(index);
}
inline ::com::mservice::momo::msg::ExtraInfo* GetServiceLayoutReply::mutable_extra_info(int index) {
  return extra_info_.Mutable(index);
}
inline ::com::mservice::momo::msg::ExtraInfo* GetServiceLayoutReply::add_extra_info() {
  return extra_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::ExtraInfo >&
GetServiceLayoutReply::extra_info() const {
  return extra_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::ExtraInfo >*
GetServiceLayoutReply::mutable_extra_info() {
  return &extra_info_;
}

// -------------------------------------------------------------------

// Promotion

// optional string id = 1;
inline bool Promotion::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Promotion::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Promotion::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Promotion::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Promotion::id() const {
  return *id_;
}
inline void Promotion::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Promotion::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Promotion::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Promotion::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* Promotion::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Promotion::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 from_date = 2;
inline bool Promotion::has_from_date() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Promotion::set_has_from_date() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Promotion::clear_has_from_date() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Promotion::clear_from_date() {
  from_date_ = GOOGLE_ULONGLONG(0);
  clear_has_from_date();
}
inline ::google::protobuf::uint64 Promotion::from_date() const {
  return from_date_;
}
inline void Promotion::set_from_date(::google::protobuf::uint64 value) {
  set_has_from_date();
  from_date_ = value;
}

// optional uint64 to_date = 3;
inline bool Promotion::has_to_date() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Promotion::set_has_to_date() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Promotion::clear_has_to_date() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Promotion::clear_to_date() {
  to_date_ = GOOGLE_ULONGLONG(0);
  clear_has_to_date();
}
inline ::google::protobuf::uint64 Promotion::to_date() const {
  return to_date_;
}
inline void Promotion::set_to_date(::google::protobuf::uint64 value) {
  set_has_to_date();
  to_date_ = value;
}

// optional bool is_active = 4;
inline bool Promotion::has_is_active() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Promotion::set_has_is_active() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Promotion::clear_has_is_active() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Promotion::clear_is_active() {
  is_active_ = false;
  clear_has_is_active();
}
inline bool Promotion::is_active() const {
  return is_active_;
}
inline void Promotion::set_is_active(bool value) {
  set_has_is_active();
  is_active_ = value;
}

// optional string promotion_name = 6;
inline bool Promotion::has_promotion_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Promotion::set_has_promotion_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Promotion::clear_has_promotion_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Promotion::clear_promotion_name() {
  if (promotion_name_ != &::google::protobuf::internal::kEmptyString) {
    promotion_name_->clear();
  }
  clear_has_promotion_name();
}
inline const ::std::string& Promotion::promotion_name() const {
  return *promotion_name_;
}
inline void Promotion::set_promotion_name(const ::std::string& value) {
  set_has_promotion_name();
  if (promotion_name_ == &::google::protobuf::internal::kEmptyString) {
    promotion_name_ = new ::std::string;
  }
  promotion_name_->assign(value);
}
inline void Promotion::set_promotion_name(const char* value) {
  set_has_promotion_name();
  if (promotion_name_ == &::google::protobuf::internal::kEmptyString) {
    promotion_name_ = new ::std::string;
  }
  promotion_name_->assign(value);
}
inline void Promotion::set_promotion_name(const char* value, size_t size) {
  set_has_promotion_name();
  if (promotion_name_ == &::google::protobuf::internal::kEmptyString) {
    promotion_name_ = new ::std::string;
  }
  promotion_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Promotion::mutable_promotion_name() {
  set_has_promotion_name();
  if (promotion_name_ == &::google::protobuf::internal::kEmptyString) {
    promotion_name_ = new ::std::string;
  }
  return promotion_name_;
}
inline ::std::string* Promotion::release_promotion_name() {
  clear_has_promotion_name();
  if (promotion_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = promotion_name_;
    promotion_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Promotion::set_allocated_promotion_name(::std::string* promotion_name) {
  if (promotion_name_ != &::google::protobuf::internal::kEmptyString) {
    delete promotion_name_;
  }
  if (promotion_name) {
    set_has_promotion_name();
    promotion_name_ = promotion_name;
  } else {
    clear_has_promotion_name();
    promotion_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GetPromotionReply

// repeated .com.mservice.momo.msg.Promotion promotion_list = 1;
inline int GetPromotionReply::promotion_list_size() const {
  return promotion_list_.size();
}
inline void GetPromotionReply::clear_promotion_list() {
  promotion_list_.Clear();
}
inline const ::com::mservice::momo::msg::Promotion& GetPromotionReply::promotion_list(int index) const {
  return promotion_list_.Get(index);
}
inline ::com::mservice::momo::msg::Promotion* GetPromotionReply::mutable_promotion_list(int index) {
  return promotion_list_.Mutable(index);
}
inline ::com::mservice::momo::msg::Promotion* GetPromotionReply::add_promotion_list() {
  return promotion_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::Promotion >&
GetPromotionReply::promotion_list() const {
  return promotion_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::Promotion >*
GetPromotionReply::mutable_promotion_list() {
  return &promotion_list_;
}

// -------------------------------------------------------------------

// GetPromotionDetail

// optional string id = 1;
inline bool GetPromotionDetail::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetPromotionDetail::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetPromotionDetail::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetPromotionDetail::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& GetPromotionDetail::id() const {
  return *id_;
}
inline void GetPromotionDetail::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void GetPromotionDetail::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void GetPromotionDetail::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetPromotionDetail::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* GetPromotionDetail::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetPromotionDetail::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GetPromotionDetailReply

// optional string intro_data = 1;
inline bool GetPromotionDetailReply::has_intro_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetPromotionDetailReply::set_has_intro_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetPromotionDetailReply::clear_has_intro_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetPromotionDetailReply::clear_intro_data() {
  if (intro_data_ != &::google::protobuf::internal::kEmptyString) {
    intro_data_->clear();
  }
  clear_has_intro_data();
}
inline const ::std::string& GetPromotionDetailReply::intro_data() const {
  return *intro_data_;
}
inline void GetPromotionDetailReply::set_intro_data(const ::std::string& value) {
  set_has_intro_data();
  if (intro_data_ == &::google::protobuf::internal::kEmptyString) {
    intro_data_ = new ::std::string;
  }
  intro_data_->assign(value);
}
inline void GetPromotionDetailReply::set_intro_data(const char* value) {
  set_has_intro_data();
  if (intro_data_ == &::google::protobuf::internal::kEmptyString) {
    intro_data_ = new ::std::string;
  }
  intro_data_->assign(value);
}
inline void GetPromotionDetailReply::set_intro_data(const char* value, size_t size) {
  set_has_intro_data();
  if (intro_data_ == &::google::protobuf::internal::kEmptyString) {
    intro_data_ = new ::std::string;
  }
  intro_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetPromotionDetailReply::mutable_intro_data() {
  set_has_intro_data();
  if (intro_data_ == &::google::protobuf::internal::kEmptyString) {
    intro_data_ = new ::std::string;
  }
  return intro_data_;
}
inline ::std::string* GetPromotionDetailReply::release_intro_data() {
  clear_has_intro_data();
  if (intro_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = intro_data_;
    intro_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetPromotionDetailReply::set_allocated_intro_data(::std::string* intro_data) {
  if (intro_data_ != &::google::protobuf::internal::kEmptyString) {
    delete intro_data_;
  }
  if (intro_data) {
    set_has_intro_data();
    intro_data_ = intro_data;
  } else {
    clear_has_intro_data();
    intro_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string intro_sms = 2;
inline bool GetPromotionDetailReply::has_intro_sms() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetPromotionDetailReply::set_has_intro_sms() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetPromotionDetailReply::clear_has_intro_sms() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetPromotionDetailReply::clear_intro_sms() {
  if (intro_sms_ != &::google::protobuf::internal::kEmptyString) {
    intro_sms_->clear();
  }
  clear_has_intro_sms();
}
inline const ::std::string& GetPromotionDetailReply::intro_sms() const {
  return *intro_sms_;
}
inline void GetPromotionDetailReply::set_intro_sms(const ::std::string& value) {
  set_has_intro_sms();
  if (intro_sms_ == &::google::protobuf::internal::kEmptyString) {
    intro_sms_ = new ::std::string;
  }
  intro_sms_->assign(value);
}
inline void GetPromotionDetailReply::set_intro_sms(const char* value) {
  set_has_intro_sms();
  if (intro_sms_ == &::google::protobuf::internal::kEmptyString) {
    intro_sms_ = new ::std::string;
  }
  intro_sms_->assign(value);
}
inline void GetPromotionDetailReply::set_intro_sms(const char* value, size_t size) {
  set_has_intro_sms();
  if (intro_sms_ == &::google::protobuf::internal::kEmptyString) {
    intro_sms_ = new ::std::string;
  }
  intro_sms_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetPromotionDetailReply::mutable_intro_sms() {
  set_has_intro_sms();
  if (intro_sms_ == &::google::protobuf::internal::kEmptyString) {
    intro_sms_ = new ::std::string;
  }
  return intro_sms_;
}
inline ::std::string* GetPromotionDetailReply::release_intro_sms() {
  clear_has_intro_sms();
  if (intro_sms_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = intro_sms_;
    intro_sms_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetPromotionDetailReply::set_allocated_intro_sms(::std::string* intro_sms) {
  if (intro_sms_ != &::google::protobuf::internal::kEmptyString) {
    delete intro_sms_;
  }
  if (intro_sms) {
    set_has_intro_sms();
    intro_sms_ = intro_sms;
  } else {
    clear_has_intro_sms();
    intro_sms_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 duration = 3;
inline bool GetPromotionDetailReply::has_duration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetPromotionDetailReply::set_has_duration() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetPromotionDetailReply::clear_has_duration() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetPromotionDetailReply::clear_duration() {
  duration_ = 0u;
  clear_has_duration();
}
inline ::google::protobuf::uint32 GetPromotionDetailReply::duration() const {
  return duration_;
}
inline void GetPromotionDetailReply::set_duration(::google::protobuf::uint32 value) {
  set_has_duration();
  duration_ = value;
}

// -------------------------------------------------------------------

// MinMax

// optional uint32 tran_type = 1;
inline bool MinMax::has_tran_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MinMax::set_has_tran_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MinMax::clear_has_tran_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MinMax::clear_tran_type() {
  tran_type_ = 0u;
  clear_has_tran_type();
}
inline ::google::protobuf::uint32 MinMax::tran_type() const {
  return tran_type_;
}
inline void MinMax::set_tran_type(::google::protobuf::uint32 value) {
  set_has_tran_type();
  tran_type_ = value;
}

// optional bool is_named = 2;
inline bool MinMax::has_is_named() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MinMax::set_has_is_named() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MinMax::clear_has_is_named() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MinMax::clear_is_named() {
  is_named_ = false;
  clear_has_is_named();
}
inline bool MinMax::is_named() const {
  return is_named_;
}
inline void MinMax::set_is_named(bool value) {
  set_has_is_named();
  is_named_ = value;
}

// optional uint64 min_value = 3;
inline bool MinMax::has_min_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MinMax::set_has_min_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MinMax::clear_has_min_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MinMax::clear_min_value() {
  min_value_ = GOOGLE_ULONGLONG(0);
  clear_has_min_value();
}
inline ::google::protobuf::uint64 MinMax::min_value() const {
  return min_value_;
}
inline void MinMax::set_min_value(::google::protobuf::uint64 value) {
  set_has_min_value();
  min_value_ = value;
}

// optional uint64 max_value = 4;
inline bool MinMax::has_max_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MinMax::set_has_max_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MinMax::clear_has_max_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MinMax::clear_max_value() {
  max_value_ = GOOGLE_ULONGLONG(0);
  clear_has_max_value();
}
inline ::google::protobuf::uint64 MinMax::max_value() const {
  return max_value_;
}
inline void MinMax::set_max_value(::google::protobuf::uint64 value) {
  set_has_max_value();
  max_value_ = value;
}

// -------------------------------------------------------------------

// MinMaxReply

// repeated .com.mservice.momo.msg.MinMax min_max_list = 1;
inline int MinMaxReply::min_max_list_size() const {
  return min_max_list_.size();
}
inline void MinMaxReply::clear_min_max_list() {
  min_max_list_.Clear();
}
inline const ::com::mservice::momo::msg::MinMax& MinMaxReply::min_max_list(int index) const {
  return min_max_list_.Get(index);
}
inline ::com::mservice::momo::msg::MinMax* MinMaxReply::mutable_min_max_list(int index) {
  return min_max_list_.Mutable(index);
}
inline ::com::mservice::momo::msg::MinMax* MinMaxReply::add_min_max_list() {
  return min_max_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::MinMax >&
MinMaxReply::min_max_list() const {
  return min_max_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::MinMax >*
MinMaxReply::mutable_min_max_list() {
  return &min_max_list_;
}

// -------------------------------------------------------------------

// CreateOrder123Phim

// optional uint64 session_id = 1;
inline bool CreateOrder123Phim::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateOrder123Phim::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateOrder123Phim::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateOrder123Phim::clear_session_id() {
  session_id_ = GOOGLE_ULONGLONG(0);
  clear_has_session_id();
}
inline ::google::protobuf::uint64 CreateOrder123Phim::session_id() const {
  return session_id_;
}
inline void CreateOrder123Phim::set_session_id(::google::protobuf::uint64 value) {
  set_has_session_id();
  session_id_ = value;
}

// repeated string seat_list = 2;
inline int CreateOrder123Phim::seat_list_size() const {
  return seat_list_.size();
}
inline void CreateOrder123Phim::clear_seat_list() {
  seat_list_.Clear();
}
inline const ::std::string& CreateOrder123Phim::seat_list(int index) const {
  return seat_list_.Get(index);
}
inline ::std::string* CreateOrder123Phim::mutable_seat_list(int index) {
  return seat_list_.Mutable(index);
}
inline void CreateOrder123Phim::set_seat_list(int index, const ::std::string& value) {
  seat_list_.Mutable(index)->assign(value);
}
inline void CreateOrder123Phim::set_seat_list(int index, const char* value) {
  seat_list_.Mutable(index)->assign(value);
}
inline void CreateOrder123Phim::set_seat_list(int index, const char* value, size_t size) {
  seat_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateOrder123Phim::add_seat_list() {
  return seat_list_.Add();
}
inline void CreateOrder123Phim::add_seat_list(const ::std::string& value) {
  seat_list_.Add()->assign(value);
}
inline void CreateOrder123Phim::add_seat_list(const char* value) {
  seat_list_.Add()->assign(value);
}
inline void CreateOrder123Phim::add_seat_list(const char* value, size_t size) {
  seat_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CreateOrder123Phim::seat_list() const {
  return seat_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CreateOrder123Phim::mutable_seat_list() {
  return &seat_list_;
}

// optional string device_id = 3;
inline bool CreateOrder123Phim::has_device_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateOrder123Phim::set_has_device_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateOrder123Phim::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateOrder123Phim::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& CreateOrder123Phim::device_id() const {
  return *device_id_;
}
inline void CreateOrder123Phim::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void CreateOrder123Phim::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void CreateOrder123Phim::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateOrder123Phim::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* CreateOrder123Phim::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateOrder123Phim::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string phone_number = 4;
inline bool CreateOrder123Phim::has_phone_number() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CreateOrder123Phim::set_has_phone_number() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CreateOrder123Phim::clear_has_phone_number() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CreateOrder123Phim::clear_phone_number() {
  if (phone_number_ != &::google::protobuf::internal::kEmptyString) {
    phone_number_->clear();
  }
  clear_has_phone_number();
}
inline const ::std::string& CreateOrder123Phim::phone_number() const {
  return *phone_number_;
}
inline void CreateOrder123Phim::set_phone_number(const ::std::string& value) {
  set_has_phone_number();
  if (phone_number_ == &::google::protobuf::internal::kEmptyString) {
    phone_number_ = new ::std::string;
  }
  phone_number_->assign(value);
}
inline void CreateOrder123Phim::set_phone_number(const char* value) {
  set_has_phone_number();
  if (phone_number_ == &::google::protobuf::internal::kEmptyString) {
    phone_number_ = new ::std::string;
  }
  phone_number_->assign(value);
}
inline void CreateOrder123Phim::set_phone_number(const char* value, size_t size) {
  set_has_phone_number();
  if (phone_number_ == &::google::protobuf::internal::kEmptyString) {
    phone_number_ = new ::std::string;
  }
  phone_number_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateOrder123Phim::mutable_phone_number() {
  set_has_phone_number();
  if (phone_number_ == &::google::protobuf::internal::kEmptyString) {
    phone_number_ = new ::std::string;
  }
  return phone_number_;
}
inline ::std::string* CreateOrder123Phim::release_phone_number() {
  clear_has_phone_number();
  if (phone_number_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phone_number_;
    phone_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateOrder123Phim::set_allocated_phone_number(::std::string* phone_number) {
  if (phone_number_ != &::google::protobuf::internal::kEmptyString) {
    delete phone_number_;
  }
  if (phone_number) {
    set_has_phone_number();
    phone_number_ = phone_number;
  } else {
    clear_has_phone_number();
    phone_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string email = 5;
inline bool CreateOrder123Phim::has_email() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CreateOrder123Phim::set_has_email() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CreateOrder123Phim::clear_has_email() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CreateOrder123Phim::clear_email() {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& CreateOrder123Phim::email() const {
  return *email_;
}
inline void CreateOrder123Phim::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void CreateOrder123Phim::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void CreateOrder123Phim::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateOrder123Phim::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  return email_;
}
inline ::std::string* CreateOrder123Phim::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateOrder123Phim::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Seat

// optional string seat = 1;
inline bool Seat::has_seat() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Seat::set_has_seat() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Seat::clear_has_seat() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Seat::clear_seat() {
  if (seat_ != &::google::protobuf::internal::kEmptyString) {
    seat_->clear();
  }
  clear_has_seat();
}
inline const ::std::string& Seat::seat() const {
  return *seat_;
}
inline void Seat::set_seat(const ::std::string& value) {
  set_has_seat();
  if (seat_ == &::google::protobuf::internal::kEmptyString) {
    seat_ = new ::std::string;
  }
  seat_->assign(value);
}
inline void Seat::set_seat(const char* value) {
  set_has_seat();
  if (seat_ == &::google::protobuf::internal::kEmptyString) {
    seat_ = new ::std::string;
  }
  seat_->assign(value);
}
inline void Seat::set_seat(const char* value, size_t size) {
  set_has_seat();
  if (seat_ == &::google::protobuf::internal::kEmptyString) {
    seat_ = new ::std::string;
  }
  seat_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Seat::mutable_seat() {
  set_has_seat();
  if (seat_ == &::google::protobuf::internal::kEmptyString) {
    seat_ = new ::std::string;
  }
  return seat_;
}
inline ::std::string* Seat::release_seat() {
  clear_has_seat();
  if (seat_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = seat_;
    seat_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Seat::set_allocated_seat(::std::string* seat) {
  if (seat_ != &::google::protobuf::internal::kEmptyString) {
    delete seat_;
  }
  if (seat) {
    set_has_seat();
    seat_ = seat;
  } else {
    clear_has_seat();
    seat_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 price = 2;
inline bool Seat::has_price() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Seat::set_has_price() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Seat::clear_has_price() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Seat::clear_price() {
  price_ = 0u;
  clear_has_price();
}
inline ::google::protobuf::uint32 Seat::price() const {
  return price_;
}
inline void Seat::set_price(::google::protobuf::uint32 value) {
  set_has_price();
  price_ = value;
}

// -------------------------------------------------------------------

// CreateOrder123PhimReply

// optional string invoice_no = 1;
inline bool CreateOrder123PhimReply::has_invoice_no() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateOrder123PhimReply::set_has_invoice_no() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateOrder123PhimReply::clear_has_invoice_no() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateOrder123PhimReply::clear_invoice_no() {
  if (invoice_no_ != &::google::protobuf::internal::kEmptyString) {
    invoice_no_->clear();
  }
  clear_has_invoice_no();
}
inline const ::std::string& CreateOrder123PhimReply::invoice_no() const {
  return *invoice_no_;
}
inline void CreateOrder123PhimReply::set_invoice_no(const ::std::string& value) {
  set_has_invoice_no();
  if (invoice_no_ == &::google::protobuf::internal::kEmptyString) {
    invoice_no_ = new ::std::string;
  }
  invoice_no_->assign(value);
}
inline void CreateOrder123PhimReply::set_invoice_no(const char* value) {
  set_has_invoice_no();
  if (invoice_no_ == &::google::protobuf::internal::kEmptyString) {
    invoice_no_ = new ::std::string;
  }
  invoice_no_->assign(value);
}
inline void CreateOrder123PhimReply::set_invoice_no(const char* value, size_t size) {
  set_has_invoice_no();
  if (invoice_no_ == &::google::protobuf::internal::kEmptyString) {
    invoice_no_ = new ::std::string;
  }
  invoice_no_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateOrder123PhimReply::mutable_invoice_no() {
  set_has_invoice_no();
  if (invoice_no_ == &::google::protobuf::internal::kEmptyString) {
    invoice_no_ = new ::std::string;
  }
  return invoice_no_;
}
inline ::std::string* CreateOrder123PhimReply::release_invoice_no() {
  clear_has_invoice_no();
  if (invoice_no_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = invoice_no_;
    invoice_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateOrder123PhimReply::set_allocated_invoice_no(::std::string* invoice_no) {
  if (invoice_no_ != &::google::protobuf::internal::kEmptyString) {
    delete invoice_no_;
  }
  if (invoice_no) {
    set_has_invoice_no();
    invoice_no_ = invoice_no;
  } else {
    clear_has_invoice_no();
    invoice_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ticket_code = 2;
inline bool CreateOrder123PhimReply::has_ticket_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateOrder123PhimReply::set_has_ticket_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateOrder123PhimReply::clear_has_ticket_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateOrder123PhimReply::clear_ticket_code() {
  if (ticket_code_ != &::google::protobuf::internal::kEmptyString) {
    ticket_code_->clear();
  }
  clear_has_ticket_code();
}
inline const ::std::string& CreateOrder123PhimReply::ticket_code() const {
  return *ticket_code_;
}
inline void CreateOrder123PhimReply::set_ticket_code(const ::std::string& value) {
  set_has_ticket_code();
  if (ticket_code_ == &::google::protobuf::internal::kEmptyString) {
    ticket_code_ = new ::std::string;
  }
  ticket_code_->assign(value);
}
inline void CreateOrder123PhimReply::set_ticket_code(const char* value) {
  set_has_ticket_code();
  if (ticket_code_ == &::google::protobuf::internal::kEmptyString) {
    ticket_code_ = new ::std::string;
  }
  ticket_code_->assign(value);
}
inline void CreateOrder123PhimReply::set_ticket_code(const char* value, size_t size) {
  set_has_ticket_code();
  if (ticket_code_ == &::google::protobuf::internal::kEmptyString) {
    ticket_code_ = new ::std::string;
  }
  ticket_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateOrder123PhimReply::mutable_ticket_code() {
  set_has_ticket_code();
  if (ticket_code_ == &::google::protobuf::internal::kEmptyString) {
    ticket_code_ = new ::std::string;
  }
  return ticket_code_;
}
inline ::std::string* CreateOrder123PhimReply::release_ticket_code() {
  clear_has_ticket_code();
  if (ticket_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ticket_code_;
    ticket_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateOrder123PhimReply::set_allocated_ticket_code(::std::string* ticket_code) {
  if (ticket_code_ != &::google::protobuf::internal::kEmptyString) {
    delete ticket_code_;
  }
  if (ticket_code) {
    set_has_ticket_code();
    ticket_code_ = ticket_code;
  } else {
    clear_has_ticket_code();
    ticket_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 total_amount = 3;
inline bool CreateOrder123PhimReply::has_total_amount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateOrder123PhimReply::set_has_total_amount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateOrder123PhimReply::clear_has_total_amount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateOrder123PhimReply::clear_total_amount() {
  total_amount_ = GOOGLE_ULONGLONG(0);
  clear_has_total_amount();
}
inline ::google::protobuf::uint64 CreateOrder123PhimReply::total_amount() const {
  return total_amount_;
}
inline void CreateOrder123PhimReply::set_total_amount(::google::protobuf::uint64 value) {
  set_has_total_amount();
  total_amount_ = value;
}

// repeated .com.mservice.momo.msg.Seat seat_list = 4;
inline int CreateOrder123PhimReply::seat_list_size() const {
  return seat_list_.size();
}
inline void CreateOrder123PhimReply::clear_seat_list() {
  seat_list_.Clear();
}
inline const ::com::mservice::momo::msg::Seat& CreateOrder123PhimReply::seat_list(int index) const {
  return seat_list_.Get(index);
}
inline ::com::mservice::momo::msg::Seat* CreateOrder123PhimReply::mutable_seat_list(int index) {
  return seat_list_.Mutable(index);
}
inline ::com::mservice::momo::msg::Seat* CreateOrder123PhimReply::add_seat_list() {
  return seat_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::Seat >&
CreateOrder123PhimReply::seat_list() const {
  return seat_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::Seat >*
CreateOrder123PhimReply::mutable_seat_list() {
  return &seat_list_;
}

// optional uint32 rcode = 5;
inline bool CreateOrder123PhimReply::has_rcode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CreateOrder123PhimReply::set_has_rcode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CreateOrder123PhimReply::clear_has_rcode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CreateOrder123PhimReply::clear_rcode() {
  rcode_ = 0u;
  clear_has_rcode();
}
inline ::google::protobuf::uint32 CreateOrder123PhimReply::rcode() const {
  return rcode_;
}
inline void CreateOrder123PhimReply::set_rcode(::google::protobuf::uint32 value) {
  set_has_rcode();
  rcode_ = value;
}

// -------------------------------------------------------------------

// StandardSync

// optional uint64 last_update_time = 1;
inline bool StandardSync::has_last_update_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StandardSync::set_has_last_update_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StandardSync::clear_has_last_update_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StandardSync::clear_last_update_time() {
  last_update_time_ = GOOGLE_ULONGLONG(0);
  clear_has_last_update_time();
}
inline ::google::protobuf::uint64 StandardSync::last_update_time() const {
  return last_update_time_;
}
inline void StandardSync::set_last_update_time(::google::protobuf::uint64 value) {
  set_has_last_update_time();
  last_update_time_ = value;
}

// optional uint64 target_time = 2;
inline bool StandardSync::has_target_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StandardSync::set_has_target_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StandardSync::clear_has_target_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StandardSync::clear_target_time() {
  target_time_ = GOOGLE_ULONGLONG(0);
  clear_has_target_time();
}
inline ::google::protobuf::uint64 StandardSync::target_time() const {
  return target_time_;
}
inline void StandardSync::set_target_time(::google::protobuf::uint64 value) {
  set_has_target_time();
  target_time_ = value;
}

// optional uint64 batch_size = 3;
inline bool StandardSync::has_batch_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StandardSync::set_has_batch_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StandardSync::clear_has_batch_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StandardSync::clear_batch_size() {
  batch_size_ = GOOGLE_ULONGLONG(0);
  clear_has_batch_size();
}
inline ::google::protobuf::uint64 StandardSync::batch_size() const {
  return batch_size_;
}
inline void StandardSync::set_batch_size(::google::protobuf::uint64 value) {
  set_has_batch_size();
  batch_size_ = value;
}

// optional uint64 batch_direction = 4;
inline bool StandardSync::has_batch_direction() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StandardSync::set_has_batch_direction() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StandardSync::clear_has_batch_direction() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StandardSync::clear_batch_direction() {
  batch_direction_ = GOOGLE_ULONGLONG(0);
  clear_has_batch_direction();
}
inline ::google::protobuf::uint64 StandardSync::batch_direction() const {
  return batch_direction_;
}
inline void StandardSync::set_batch_direction(::google::protobuf::uint64 value) {
  set_has_batch_direction();
  batch_direction_ = value;
}

// -------------------------------------------------------------------

// StandardReply

// optional bool result = 1;
inline bool StandardReply::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StandardReply::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StandardReply::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StandardReply::clear_result() {
  result_ = false;
  clear_has_result();
}
inline bool StandardReply::result() const {
  return result_;
}
inline void StandardReply::set_result(bool value) {
  set_has_result();
  result_ = value;
}

// optional string desc = 2;
inline bool StandardReply::has_desc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StandardReply::set_has_desc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StandardReply::clear_has_desc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StandardReply::clear_desc() {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& StandardReply::desc() const {
  return *desc_;
}
inline void StandardReply::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void StandardReply::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void StandardReply::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StandardReply::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  return desc_;
}
inline ::std::string* StandardReply::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StandardReply::set_allocated_desc(::std::string* desc) {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    delete desc_;
  }
  if (desc) {
    set_has_desc();
    desc_ = desc;
  } else {
    clear_has_desc();
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 rcode = 3;
inline bool StandardReply::has_rcode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StandardReply::set_has_rcode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StandardReply::clear_has_rcode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StandardReply::clear_rcode() {
  rcode_ = 0u;
  clear_has_rcode();
}
inline ::google::protobuf::uint32 StandardReply::rcode() const {
  return rcode_;
}
inline void StandardReply::set_rcode(::google::protobuf::uint32 value) {
  set_has_rcode();
  rcode_ = value;
}

// -------------------------------------------------------------------

// BanketVerifyOtp

// optional string merchant_trans_id = 1;
inline bool BanketVerifyOtp::has_merchant_trans_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BanketVerifyOtp::set_has_merchant_trans_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BanketVerifyOtp::clear_has_merchant_trans_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BanketVerifyOtp::clear_merchant_trans_id() {
  if (merchant_trans_id_ != &::google::protobuf::internal::kEmptyString) {
    merchant_trans_id_->clear();
  }
  clear_has_merchant_trans_id();
}
inline const ::std::string& BanketVerifyOtp::merchant_trans_id() const {
  return *merchant_trans_id_;
}
inline void BanketVerifyOtp::set_merchant_trans_id(const ::std::string& value) {
  set_has_merchant_trans_id();
  if (merchant_trans_id_ == &::google::protobuf::internal::kEmptyString) {
    merchant_trans_id_ = new ::std::string;
  }
  merchant_trans_id_->assign(value);
}
inline void BanketVerifyOtp::set_merchant_trans_id(const char* value) {
  set_has_merchant_trans_id();
  if (merchant_trans_id_ == &::google::protobuf::internal::kEmptyString) {
    merchant_trans_id_ = new ::std::string;
  }
  merchant_trans_id_->assign(value);
}
inline void BanketVerifyOtp::set_merchant_trans_id(const char* value, size_t size) {
  set_has_merchant_trans_id();
  if (merchant_trans_id_ == &::google::protobuf::internal::kEmptyString) {
    merchant_trans_id_ = new ::std::string;
  }
  merchant_trans_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BanketVerifyOtp::mutable_merchant_trans_id() {
  set_has_merchant_trans_id();
  if (merchant_trans_id_ == &::google::protobuf::internal::kEmptyString) {
    merchant_trans_id_ = new ::std::string;
  }
  return merchant_trans_id_;
}
inline ::std::string* BanketVerifyOtp::release_merchant_trans_id() {
  clear_has_merchant_trans_id();
  if (merchant_trans_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = merchant_trans_id_;
    merchant_trans_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BanketVerifyOtp::set_allocated_merchant_trans_id(::std::string* merchant_trans_id) {
  if (merchant_trans_id_ != &::google::protobuf::internal::kEmptyString) {
    delete merchant_trans_id_;
  }
  if (merchant_trans_id) {
    set_has_merchant_trans_id();
    merchant_trans_id_ = merchant_trans_id;
  } else {
    clear_has_merchant_trans_id();
    merchant_trans_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string trans_id = 2;
inline bool BanketVerifyOtp::has_trans_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BanketVerifyOtp::set_has_trans_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BanketVerifyOtp::clear_has_trans_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BanketVerifyOtp::clear_trans_id() {
  if (trans_id_ != &::google::protobuf::internal::kEmptyString) {
    trans_id_->clear();
  }
  clear_has_trans_id();
}
inline const ::std::string& BanketVerifyOtp::trans_id() const {
  return *trans_id_;
}
inline void BanketVerifyOtp::set_trans_id(const ::std::string& value) {
  set_has_trans_id();
  if (trans_id_ == &::google::protobuf::internal::kEmptyString) {
    trans_id_ = new ::std::string;
  }
  trans_id_->assign(value);
}
inline void BanketVerifyOtp::set_trans_id(const char* value) {
  set_has_trans_id();
  if (trans_id_ == &::google::protobuf::internal::kEmptyString) {
    trans_id_ = new ::std::string;
  }
  trans_id_->assign(value);
}
inline void BanketVerifyOtp::set_trans_id(const char* value, size_t size) {
  set_has_trans_id();
  if (trans_id_ == &::google::protobuf::internal::kEmptyString) {
    trans_id_ = new ::std::string;
  }
  trans_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BanketVerifyOtp::mutable_trans_id() {
  set_has_trans_id();
  if (trans_id_ == &::google::protobuf::internal::kEmptyString) {
    trans_id_ = new ::std::string;
  }
  return trans_id_;
}
inline ::std::string* BanketVerifyOtp::release_trans_id() {
  clear_has_trans_id();
  if (trans_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = trans_id_;
    trans_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BanketVerifyOtp::set_allocated_trans_id(::std::string* trans_id) {
  if (trans_id_ != &::google::protobuf::internal::kEmptyString) {
    delete trans_id_;
  }
  if (trans_id) {
    set_has_trans_id();
    trans_id_ = trans_id;
  } else {
    clear_has_trans_id();
    trans_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 full_amount = 3;
inline bool BanketVerifyOtp::has_full_amount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BanketVerifyOtp::set_has_full_amount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BanketVerifyOtp::clear_has_full_amount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BanketVerifyOtp::clear_full_amount() {
  full_amount_ = GOOGLE_ULONGLONG(0);
  clear_has_full_amount();
}
inline ::google::protobuf::uint64 BanketVerifyOtp::full_amount() const {
  return full_amount_;
}
inline void BanketVerifyOtp::set_full_amount(::google::protobuf::uint64 value) {
  set_has_full_amount();
  full_amount_ = value;
}

// optional string otp = 4;
inline bool BanketVerifyOtp::has_otp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BanketVerifyOtp::set_has_otp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BanketVerifyOtp::clear_has_otp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BanketVerifyOtp::clear_otp() {
  if (otp_ != &::google::protobuf::internal::kEmptyString) {
    otp_->clear();
  }
  clear_has_otp();
}
inline const ::std::string& BanketVerifyOtp::otp() const {
  return *otp_;
}
inline void BanketVerifyOtp::set_otp(const ::std::string& value) {
  set_has_otp();
  if (otp_ == &::google::protobuf::internal::kEmptyString) {
    otp_ = new ::std::string;
  }
  otp_->assign(value);
}
inline void BanketVerifyOtp::set_otp(const char* value) {
  set_has_otp();
  if (otp_ == &::google::protobuf::internal::kEmptyString) {
    otp_ = new ::std::string;
  }
  otp_->assign(value);
}
inline void BanketVerifyOtp::set_otp(const char* value, size_t size) {
  set_has_otp();
  if (otp_ == &::google::protobuf::internal::kEmptyString) {
    otp_ = new ::std::string;
  }
  otp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BanketVerifyOtp::mutable_otp() {
  set_has_otp();
  if (otp_ == &::google::protobuf::internal::kEmptyString) {
    otp_ = new ::std::string;
  }
  return otp_;
}
inline ::std::string* BanketVerifyOtp::release_otp() {
  clear_has_otp();
  if (otp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = otp_;
    otp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BanketVerifyOtp::set_allocated_otp(::std::string* otp) {
  if (otp_ != &::google::protobuf::internal::kEmptyString) {
    delete otp_;
  }
  if (otp) {
    set_has_otp();
    otp_ = otp;
  } else {
    clear_has_otp();
    otp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 fee_amount = 5;
inline bool BanketVerifyOtp::has_fee_amount() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BanketVerifyOtp::set_has_fee_amount() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BanketVerifyOtp::clear_has_fee_amount() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BanketVerifyOtp::clear_fee_amount() {
  fee_amount_ = GOOGLE_ULONGLONG(0);
  clear_has_fee_amount();
}
inline ::google::protobuf::uint64 BanketVerifyOtp::fee_amount() const {
  return fee_amount_;
}
inline void BanketVerifyOtp::set_fee_amount(::google::protobuf::uint64 value) {
  set_has_fee_amount();
  fee_amount_ = value;
}

// -------------------------------------------------------------------

// IdList

// repeated uint64 ids = 1;
inline int IdList::ids_size() const {
  return ids_.size();
}
inline void IdList::clear_ids() {
  ids_.Clear();
}
inline ::google::protobuf::uint64 IdList::ids(int index) const {
  return ids_.Get(index);
}
inline void IdList::set_ids(int index, ::google::protobuf::uint64 value) {
  ids_.Set(index, value);
}
inline void IdList::add_ids(::google::protobuf::uint64 value) {
  ids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
IdList::ids() const {
  return ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
IdList::mutable_ids() {
  return &ids_;
}

// -------------------------------------------------------------------

// BankOfBanknet

// repeated string bank_id = 1;
inline int BankOfBanknet::bank_id_size() const {
  return bank_id_.size();
}
inline void BankOfBanknet::clear_bank_id() {
  bank_id_.Clear();
}
inline const ::std::string& BankOfBanknet::bank_id(int index) const {
  return bank_id_.Get(index);
}
inline ::std::string* BankOfBanknet::mutable_bank_id(int index) {
  return bank_id_.Mutable(index);
}
inline void BankOfBanknet::set_bank_id(int index, const ::std::string& value) {
  bank_id_.Mutable(index)->assign(value);
}
inline void BankOfBanknet::set_bank_id(int index, const char* value) {
  bank_id_.Mutable(index)->assign(value);
}
inline void BankOfBanknet::set_bank_id(int index, const char* value, size_t size) {
  bank_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BankOfBanknet::add_bank_id() {
  return bank_id_.Add();
}
inline void BankOfBanknet::add_bank_id(const ::std::string& value) {
  bank_id_.Add()->assign(value);
}
inline void BankOfBanknet::add_bank_id(const char* value) {
  bank_id_.Add()->assign(value);
}
inline void BankOfBanknet::add_bank_id(const char* value, size_t size) {
  bank_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BankOfBanknet::bank_id() const {
  return bank_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BankOfBanknet::mutable_bank_id() {
  return &bank_id_;
}

// repeated string bank_name = 2;
inline int BankOfBanknet::bank_name_size() const {
  return bank_name_.size();
}
inline void BankOfBanknet::clear_bank_name() {
  bank_name_.Clear();
}
inline const ::std::string& BankOfBanknet::bank_name(int index) const {
  return bank_name_.Get(index);
}
inline ::std::string* BankOfBanknet::mutable_bank_name(int index) {
  return bank_name_.Mutable(index);
}
inline void BankOfBanknet::set_bank_name(int index, const ::std::string& value) {
  bank_name_.Mutable(index)->assign(value);
}
inline void BankOfBanknet::set_bank_name(int index, const char* value) {
  bank_name_.Mutable(index)->assign(value);
}
inline void BankOfBanknet::set_bank_name(int index, const char* value, size_t size) {
  bank_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BankOfBanknet::add_bank_name() {
  return bank_name_.Add();
}
inline void BankOfBanknet::add_bank_name(const ::std::string& value) {
  bank_name_.Add()->assign(value);
}
inline void BankOfBanknet::add_bank_name(const char* value) {
  bank_name_.Add()->assign(value);
}
inline void BankOfBanknet::add_bank_name(const char* value, size_t size) {
  bank_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BankOfBanknet::bank_name() const {
  return bank_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BankOfBanknet::mutable_bank_name() {
  return &bank_name_;
}

// -------------------------------------------------------------------

// TranStatisticPerDayReply

// optional uint32 total_count = 1;
inline bool TranStatisticPerDayReply::has_total_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TranStatisticPerDayReply::set_has_total_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TranStatisticPerDayReply::clear_has_total_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TranStatisticPerDayReply::clear_total_count() {
  total_count_ = 0u;
  clear_has_total_count();
}
inline ::google::protobuf::uint32 TranStatisticPerDayReply::total_count() const {
  return total_count_;
}
inline void TranStatisticPerDayReply::set_total_count(::google::protobuf::uint32 value) {
  set_has_total_count();
  total_count_ = value;
}

// optional uint32 remain_count = 2;
inline bool TranStatisticPerDayReply::has_remain_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TranStatisticPerDayReply::set_has_remain_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TranStatisticPerDayReply::clear_has_remain_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TranStatisticPerDayReply::clear_remain_count() {
  remain_count_ = 0u;
  clear_has_remain_count();
}
inline ::google::protobuf::uint32 TranStatisticPerDayReply::remain_count() const {
  return remain_count_;
}
inline void TranStatisticPerDayReply::set_remain_count(::google::protobuf::uint32 value) {
  set_has_remain_count();
  remain_count_ = value;
}

// optional uint64 total_amount = 3;
inline bool TranStatisticPerDayReply::has_total_amount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TranStatisticPerDayReply::set_has_total_amount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TranStatisticPerDayReply::clear_has_total_amount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TranStatisticPerDayReply::clear_total_amount() {
  total_amount_ = GOOGLE_ULONGLONG(0);
  clear_has_total_amount();
}
inline ::google::protobuf::uint64 TranStatisticPerDayReply::total_amount() const {
  return total_amount_;
}
inline void TranStatisticPerDayReply::set_total_amount(::google::protobuf::uint64 value) {
  set_has_total_amount();
  total_amount_ = value;
}

// optional uint64 max_amount = 4;
inline bool TranStatisticPerDayReply::has_max_amount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TranStatisticPerDayReply::set_has_max_amount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TranStatisticPerDayReply::clear_has_max_amount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TranStatisticPerDayReply::clear_max_amount() {
  max_amount_ = GOOGLE_ULONGLONG(0);
  clear_has_max_amount();
}
inline ::google::protobuf::uint64 TranStatisticPerDayReply::max_amount() const {
  return max_amount_;
}
inline void TranStatisticPerDayReply::set_max_amount(::google::protobuf::uint64 value) {
  set_has_max_amount();
  max_amount_ = value;
}

// -------------------------------------------------------------------

// GetFee

// optional string bank_id = 1;
inline bool GetFee::has_bank_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetFee::set_has_bank_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetFee::clear_has_bank_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetFee::clear_bank_id() {
  if (bank_id_ != &::google::protobuf::internal::kEmptyString) {
    bank_id_->clear();
  }
  clear_has_bank_id();
}
inline const ::std::string& GetFee::bank_id() const {
  return *bank_id_;
}
inline void GetFee::set_bank_id(const ::std::string& value) {
  set_has_bank_id();
  if (bank_id_ == &::google::protobuf::internal::kEmptyString) {
    bank_id_ = new ::std::string;
  }
  bank_id_->assign(value);
}
inline void GetFee::set_bank_id(const char* value) {
  set_has_bank_id();
  if (bank_id_ == &::google::protobuf::internal::kEmptyString) {
    bank_id_ = new ::std::string;
  }
  bank_id_->assign(value);
}
inline void GetFee::set_bank_id(const char* value, size_t size) {
  set_has_bank_id();
  if (bank_id_ == &::google::protobuf::internal::kEmptyString) {
    bank_id_ = new ::std::string;
  }
  bank_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetFee::mutable_bank_id() {
  set_has_bank_id();
  if (bank_id_ == &::google::protobuf::internal::kEmptyString) {
    bank_id_ = new ::std::string;
  }
  return bank_id_;
}
inline ::std::string* GetFee::release_bank_id() {
  clear_has_bank_id();
  if (bank_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bank_id_;
    bank_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetFee::set_allocated_bank_id(::std::string* bank_id) {
  if (bank_id_ != &::google::protobuf::internal::kEmptyString) {
    delete bank_id_;
  }
  if (bank_id) {
    set_has_bank_id();
    bank_id_ = bank_id;
  } else {
    clear_has_bank_id();
    bank_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 tran_type = 2;
inline bool GetFee::has_tran_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetFee::set_has_tran_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetFee::clear_has_tran_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetFee::clear_tran_type() {
  tran_type_ = 0u;
  clear_has_tran_type();
}
inline ::google::protobuf::uint32 GetFee::tran_type() const {
  return tran_type_;
}
inline void GetFee::set_tran_type(::google::protobuf::uint32 value) {
  set_has_tran_type();
  tran_type_ = value;
}

// optional uint32 channel = 3;
inline bool GetFee::has_channel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetFee::set_has_channel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetFee::clear_has_channel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetFee::clear_channel() {
  channel_ = 0u;
  clear_has_channel();
}
inline ::google::protobuf::uint32 GetFee::channel() const {
  return channel_;
}
inline void GetFee::set_channel(::google::protobuf::uint32 value) {
  set_has_channel();
  channel_ = value;
}

// optional uint32 io_city = 4;
inline bool GetFee::has_io_city() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetFee::set_has_io_city() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetFee::clear_has_io_city() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetFee::clear_io_city() {
  io_city_ = 0u;
  clear_has_io_city();
}
inline ::google::protobuf::uint32 GetFee::io_city() const {
  return io_city_;
}
inline void GetFee::set_io_city(::google::protobuf::uint32 value) {
  set_has_io_city();
  io_city_ = value;
}

// optional uint64 amount = 5;
inline bool GetFee::has_amount() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetFee::set_has_amount() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetFee::clear_has_amount() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetFee::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 GetFee::amount() const {
  return amount_;
}
inline void GetFee::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
}

// -------------------------------------------------------------------

// GetFeeReply

// optional double dymanic_fee = 1;
inline bool GetFeeReply::has_dymanic_fee() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetFeeReply::set_has_dymanic_fee() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetFeeReply::clear_has_dymanic_fee() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetFeeReply::clear_dymanic_fee() {
  dymanic_fee_ = 0;
  clear_has_dymanic_fee();
}
inline double GetFeeReply::dymanic_fee() const {
  return dymanic_fee_;
}
inline void GetFeeReply::set_dymanic_fee(double value) {
  set_has_dymanic_fee();
  dymanic_fee_ = value;
}

// optional uint32 static_fee = 2;
inline bool GetFeeReply::has_static_fee() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetFeeReply::set_has_static_fee() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetFeeReply::clear_has_static_fee() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetFeeReply::clear_static_fee() {
  static_fee_ = 0u;
  clear_has_static_fee();
}
inline ::google::protobuf::uint32 GetFeeReply::static_fee() const {
  return static_fee_;
}
inline void GetFeeReply::set_static_fee(::google::protobuf::uint32 value) {
  set_has_static_fee();
  static_fee_ = value;
}

// optional string bank_id = 3;
inline bool GetFeeReply::has_bank_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetFeeReply::set_has_bank_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetFeeReply::clear_has_bank_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetFeeReply::clear_bank_id() {
  if (bank_id_ != &::google::protobuf::internal::kEmptyString) {
    bank_id_->clear();
  }
  clear_has_bank_id();
}
inline const ::std::string& GetFeeReply::bank_id() const {
  return *bank_id_;
}
inline void GetFeeReply::set_bank_id(const ::std::string& value) {
  set_has_bank_id();
  if (bank_id_ == &::google::protobuf::internal::kEmptyString) {
    bank_id_ = new ::std::string;
  }
  bank_id_->assign(value);
}
inline void GetFeeReply::set_bank_id(const char* value) {
  set_has_bank_id();
  if (bank_id_ == &::google::protobuf::internal::kEmptyString) {
    bank_id_ = new ::std::string;
  }
  bank_id_->assign(value);
}
inline void GetFeeReply::set_bank_id(const char* value, size_t size) {
  set_has_bank_id();
  if (bank_id_ == &::google::protobuf::internal::kEmptyString) {
    bank_id_ = new ::std::string;
  }
  bank_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetFeeReply::mutable_bank_id() {
  set_has_bank_id();
  if (bank_id_ == &::google::protobuf::internal::kEmptyString) {
    bank_id_ = new ::std::string;
  }
  return bank_id_;
}
inline ::std::string* GetFeeReply::release_bank_id() {
  clear_has_bank_id();
  if (bank_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bank_id_;
    bank_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetFeeReply::set_allocated_bank_id(::std::string* bank_id) {
  if (bank_id_ != &::google::protobuf::internal::kEmptyString) {
    delete bank_id_;
  }
  if (bank_id) {
    set_has_bank_id();
    bank_id_ = bank_id;
  } else {
    clear_has_bank_id();
    bank_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 tran_type = 4;
inline bool GetFeeReply::has_tran_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetFeeReply::set_has_tran_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetFeeReply::clear_has_tran_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetFeeReply::clear_tran_type() {
  tran_type_ = 0u;
  clear_has_tran_type();
}
inline ::google::protobuf::uint32 GetFeeReply::tran_type() const {
  return tran_type_;
}
inline void GetFeeReply::set_tran_type(::google::protobuf::uint32 value) {
  set_has_tran_type();
  tran_type_ = value;
}

// optional uint32 channel = 5;
inline bool GetFeeReply::has_channel() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetFeeReply::set_has_channel() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetFeeReply::clear_has_channel() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetFeeReply::clear_channel() {
  channel_ = 0u;
  clear_has_channel();
}
inline ::google::protobuf::uint32 GetFeeReply::channel() const {
  return channel_;
}
inline void GetFeeReply::set_channel(::google::protobuf::uint32 value) {
  set_has_channel();
  channel_ = value;
}

// optional uint32 io_city = 6;
inline bool GetFeeReply::has_io_city() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GetFeeReply::set_has_io_city() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GetFeeReply::clear_has_io_city() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GetFeeReply::clear_io_city() {
  io_city_ = 0u;
  clear_has_io_city();
}
inline ::google::protobuf::uint32 GetFeeReply::io_city() const {
  return io_city_;
}
inline void GetFeeReply::set_io_city(::google::protobuf::uint32 value) {
  set_has_io_city();
  io_city_ = value;
}

// optional uint32 fee_type = 7;
inline bool GetFeeReply::has_fee_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GetFeeReply::set_has_fee_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GetFeeReply::clear_has_fee_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GetFeeReply::clear_fee_type() {
  fee_type_ = 0u;
  clear_has_fee_type();
}
inline ::google::protobuf::uint32 GetFeeReply::fee_type() const {
  return fee_type_;
}
inline void GetFeeReply::set_fee_type(::google::protobuf::uint32 value) {
  set_has_fee_type();
  fee_type_ = value;
}

// -------------------------------------------------------------------

// NewUser

// optional uint32 new_number = 1;
inline bool NewUser::has_new_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewUser::set_has_new_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewUser::clear_has_new_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewUser::clear_new_number() {
  new_number_ = 0u;
  clear_has_new_number();
}
inline ::google::protobuf::uint32 NewUser::new_number() const {
  return new_number_;
}
inline void NewUser::set_new_number(::google::protobuf::uint32 value) {
  set_has_new_number();
  new_number_ = value;
}

// optional uint64 time = 2;
inline bool NewUser::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewUser::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewUser::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewUser::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::uint64 NewUser::time() const {
  return time_;
}
inline void NewUser::set_time(::google::protobuf::uint64 value) {
  set_has_time();
  time_ = value;
}

// -------------------------------------------------------------------

// TicketInfo

// optional uint32 rcode = 1;
inline bool TicketInfo::has_rcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TicketInfo::set_has_rcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TicketInfo::clear_has_rcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TicketInfo::clear_rcode() {
  rcode_ = 0u;
  clear_has_rcode();
}
inline ::google::protobuf::uint32 TicketInfo::rcode() const {
  return rcode_;
}
inline void TicketInfo::set_rcode(::google::protobuf::uint32 value) {
  set_has_rcode();
  rcode_ = value;
}

// optional string provider_id = 2;
inline bool TicketInfo::has_provider_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TicketInfo::set_has_provider_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TicketInfo::clear_has_provider_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TicketInfo::clear_provider_id() {
  if (provider_id_ != &::google::protobuf::internal::kEmptyString) {
    provider_id_->clear();
  }
  clear_has_provider_id();
}
inline const ::std::string& TicketInfo::provider_id() const {
  return *provider_id_;
}
inline void TicketInfo::set_provider_id(const ::std::string& value) {
  set_has_provider_id();
  if (provider_id_ == &::google::protobuf::internal::kEmptyString) {
    provider_id_ = new ::std::string;
  }
  provider_id_->assign(value);
}
inline void TicketInfo::set_provider_id(const char* value) {
  set_has_provider_id();
  if (provider_id_ == &::google::protobuf::internal::kEmptyString) {
    provider_id_ = new ::std::string;
  }
  provider_id_->assign(value);
}
inline void TicketInfo::set_provider_id(const char* value, size_t size) {
  set_has_provider_id();
  if (provider_id_ == &::google::protobuf::internal::kEmptyString) {
    provider_id_ = new ::std::string;
  }
  provider_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TicketInfo::mutable_provider_id() {
  set_has_provider_id();
  if (provider_id_ == &::google::protobuf::internal::kEmptyString) {
    provider_id_ = new ::std::string;
  }
  return provider_id_;
}
inline ::std::string* TicketInfo::release_provider_id() {
  clear_has_provider_id();
  if (provider_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = provider_id_;
    provider_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TicketInfo::set_allocated_provider_id(::std::string* provider_id) {
  if (provider_id_ != &::google::protobuf::internal::kEmptyString) {
    delete provider_id_;
  }
  if (provider_id) {
    set_has_provider_id();
    provider_id_ = provider_id;
  } else {
    clear_has_provider_id();
    provider_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string bill_id = 3;
inline bool TicketInfo::has_bill_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TicketInfo::set_has_bill_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TicketInfo::clear_has_bill_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TicketInfo::clear_bill_id() {
  if (bill_id_ != &::google::protobuf::internal::kEmptyString) {
    bill_id_->clear();
  }
  clear_has_bill_id();
}
inline const ::std::string& TicketInfo::bill_id() const {
  return *bill_id_;
}
inline void TicketInfo::set_bill_id(const ::std::string& value) {
  set_has_bill_id();
  if (bill_id_ == &::google::protobuf::internal::kEmptyString) {
    bill_id_ = new ::std::string;
  }
  bill_id_->assign(value);
}
inline void TicketInfo::set_bill_id(const char* value) {
  set_has_bill_id();
  if (bill_id_ == &::google::protobuf::internal::kEmptyString) {
    bill_id_ = new ::std::string;
  }
  bill_id_->assign(value);
}
inline void TicketInfo::set_bill_id(const char* value, size_t size) {
  set_has_bill_id();
  if (bill_id_ == &::google::protobuf::internal::kEmptyString) {
    bill_id_ = new ::std::string;
  }
  bill_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TicketInfo::mutable_bill_id() {
  set_has_bill_id();
  if (bill_id_ == &::google::protobuf::internal::kEmptyString) {
    bill_id_ = new ::std::string;
  }
  return bill_id_;
}
inline ::std::string* TicketInfo::release_bill_id() {
  clear_has_bill_id();
  if (bill_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bill_id_;
    bill_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TicketInfo::set_allocated_bill_id(::std::string* bill_id) {
  if (bill_id_ != &::google::protobuf::internal::kEmptyString) {
    delete bill_id_;
  }
  if (bill_id) {
    set_has_bill_id();
    bill_id_ = bill_id;
  } else {
    clear_has_bill_id();
    bill_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RegStatus

// optional bool is_setup = 1;
inline bool RegStatus::has_is_setup() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegStatus::set_has_is_setup() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegStatus::clear_has_is_setup() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegStatus::clear_is_setup() {
  is_setup_ = false;
  clear_has_is_setup();
}
inline bool RegStatus::is_setup() const {
  return is_setup_;
}
inline void RegStatus::set_is_setup(bool value) {
  set_has_is_setup();
  is_setup_ = value;
}

// optional bool is_reged = 2;
inline bool RegStatus::has_is_reged() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegStatus::set_has_is_reged() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegStatus::clear_has_is_reged() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegStatus::clear_is_reged() {
  is_reged_ = false;
  clear_has_is_reged();
}
inline bool RegStatus::is_reged() const {
  return is_reged_;
}
inline void RegStatus::set_is_reged(bool value) {
  set_has_is_reged();
  is_reged_ = value;
}

// optional bool is_active = 3;
inline bool RegStatus::has_is_active() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegStatus::set_has_is_active() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegStatus::clear_has_is_active() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegStatus::clear_is_active() {
  is_active_ = false;
  clear_has_is_active();
}
inline bool RegStatus::is_active() const {
  return is_active_;
}
inline void RegStatus::set_is_active(bool value) {
  set_has_is_active();
  is_active_ = value;
}

// optional bool is_named = 4;
inline bool RegStatus::has_is_named() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RegStatus::set_has_is_named() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RegStatus::clear_has_is_named() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RegStatus::clear_is_named() {
  is_named_ = false;
  clear_has_is_named();
}
inline bool RegStatus::is_named() const {
  return is_named_;
}
inline void RegStatus::set_is_named(bool value) {
  set_has_is_named();
  is_named_ = value;
}

// optional bool is_frozen = 5;
inline bool RegStatus::has_is_frozen() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RegStatus::set_has_is_frozen() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RegStatus::clear_has_is_frozen() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RegStatus::clear_is_frozen() {
  is_frozen_ = false;
  clear_has_is_frozen();
}
inline bool RegStatus::is_frozen() const {
  return is_frozen_;
}
inline void RegStatus::set_is_frozen(bool value) {
  set_has_is_frozen();
  is_frozen_ = value;
}

// optional bool is_suppend = 6;
inline bool RegStatus::has_is_suppend() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RegStatus::set_has_is_suppend() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RegStatus::clear_has_is_suppend() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RegStatus::clear_is_suppend() {
  is_suppend_ = false;
  clear_has_is_suppend();
}
inline bool RegStatus::is_suppend() const {
  return is_suppend_;
}
inline void RegStatus::set_is_suppend(bool value) {
  set_has_is_suppend();
  is_suppend_ = value;
}

// optional bool is_stopped = 7;
inline bool RegStatus::has_is_stopped() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RegStatus::set_has_is_stopped() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RegStatus::clear_has_is_stopped() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RegStatus::clear_is_stopped() {
  is_stopped_ = false;
  clear_has_is_stopped();
}
inline bool RegStatus::is_stopped() const {
  return is_stopped_;
}
inline void RegStatus::set_is_stopped(bool value) {
  set_has_is_stopped();
  is_stopped_ = value;
}

// -------------------------------------------------------------------

// Hello

// optional string imei = 1;
inline bool Hello::has_imei() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Hello::set_has_imei() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Hello::clear_has_imei() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Hello::clear_imei() {
  if (imei_ != &::google::protobuf::internal::kEmptyString) {
    imei_->clear();
  }
  clear_has_imei();
}
inline const ::std::string& Hello::imei() const {
  return *imei_;
}
inline void Hello::set_imei(const ::std::string& value) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  imei_->assign(value);
}
inline void Hello::set_imei(const char* value) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  imei_->assign(value);
}
inline void Hello::set_imei(const char* value, size_t size) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  imei_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Hello::mutable_imei() {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  return imei_;
}
inline ::std::string* Hello::release_imei() {
  clear_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = imei_;
    imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Hello::set_allocated_imei(::std::string* imei) {
  if (imei_ != &::google::protobuf::internal::kEmptyString) {
    delete imei_;
  }
  if (imei) {
    set_has_imei();
    imei_ = imei;
  } else {
    clear_has_imei();
    imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string imei_key = 2;
inline bool Hello::has_imei_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Hello::set_has_imei_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Hello::clear_has_imei_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Hello::clear_imei_key() {
  if (imei_key_ != &::google::protobuf::internal::kEmptyString) {
    imei_key_->clear();
  }
  clear_has_imei_key();
}
inline const ::std::string& Hello::imei_key() const {
  return *imei_key_;
}
inline void Hello::set_imei_key(const ::std::string& value) {
  set_has_imei_key();
  if (imei_key_ == &::google::protobuf::internal::kEmptyString) {
    imei_key_ = new ::std::string;
  }
  imei_key_->assign(value);
}
inline void Hello::set_imei_key(const char* value) {
  set_has_imei_key();
  if (imei_key_ == &::google::protobuf::internal::kEmptyString) {
    imei_key_ = new ::std::string;
  }
  imei_key_->assign(value);
}
inline void Hello::set_imei_key(const char* value, size_t size) {
  set_has_imei_key();
  if (imei_key_ == &::google::protobuf::internal::kEmptyString) {
    imei_key_ = new ::std::string;
  }
  imei_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Hello::mutable_imei_key() {
  set_has_imei_key();
  if (imei_key_ == &::google::protobuf::internal::kEmptyString) {
    imei_key_ = new ::std::string;
  }
  return imei_key_;
}
inline ::std::string* Hello::release_imei_key() {
  clear_has_imei_key();
  if (imei_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = imei_key_;
    imei_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Hello::set_allocated_imei_key(::std::string* imei_key) {
  if (imei_key_ != &::google::protobuf::internal::kEmptyString) {
    delete imei_key_;
  }
  if (imei_key) {
    set_has_imei_key();
    imei_key_ = imei_key;
  } else {
    clear_has_imei_key();
    imei_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string session_key = 3;
inline bool Hello::has_session_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Hello::set_has_session_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Hello::clear_has_session_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Hello::clear_session_key() {
  if (session_key_ != &::google::protobuf::internal::kEmptyString) {
    session_key_->clear();
  }
  clear_has_session_key();
}
inline const ::std::string& Hello::session_key() const {
  return *session_key_;
}
inline void Hello::set_session_key(const ::std::string& value) {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::kEmptyString) {
    session_key_ = new ::std::string;
  }
  session_key_->assign(value);
}
inline void Hello::set_session_key(const char* value) {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::kEmptyString) {
    session_key_ = new ::std::string;
  }
  session_key_->assign(value);
}
inline void Hello::set_session_key(const char* value, size_t size) {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::kEmptyString) {
    session_key_ = new ::std::string;
  }
  session_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Hello::mutable_session_key() {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::kEmptyString) {
    session_key_ = new ::std::string;
  }
  return session_key_;
}
inline ::std::string* Hello::release_session_key() {
  clear_has_session_key();
  if (session_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = session_key_;
    session_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Hello::set_allocated_session_key(::std::string* session_key) {
  if (session_key_ != &::google::protobuf::internal::kEmptyString) {
    delete session_key_;
  }
  if (session_key) {
    set_has_session_key();
    session_key_ = session_key;
  } else {
    clear_has_session_key();
    session_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string device_os = 4;
inline bool Hello::has_device_os() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Hello::set_has_device_os() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Hello::clear_has_device_os() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Hello::clear_device_os() {
  if (device_os_ != &::google::protobuf::internal::kEmptyString) {
    device_os_->clear();
  }
  clear_has_device_os();
}
inline const ::std::string& Hello::device_os() const {
  return *device_os_;
}
inline void Hello::set_device_os(const ::std::string& value) {
  set_has_device_os();
  if (device_os_ == &::google::protobuf::internal::kEmptyString) {
    device_os_ = new ::std::string;
  }
  device_os_->assign(value);
}
inline void Hello::set_device_os(const char* value) {
  set_has_device_os();
  if (device_os_ == &::google::protobuf::internal::kEmptyString) {
    device_os_ = new ::std::string;
  }
  device_os_->assign(value);
}
inline void Hello::set_device_os(const char* value, size_t size) {
  set_has_device_os();
  if (device_os_ == &::google::protobuf::internal::kEmptyString) {
    device_os_ = new ::std::string;
  }
  device_os_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Hello::mutable_device_os() {
  set_has_device_os();
  if (device_os_ == &::google::protobuf::internal::kEmptyString) {
    device_os_ = new ::std::string;
  }
  return device_os_;
}
inline ::std::string* Hello::release_device_os() {
  clear_has_device_os();
  if (device_os_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_os_;
    device_os_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Hello::set_allocated_device_os(::std::string* device_os) {
  if (device_os_ != &::google::protobuf::internal::kEmptyString) {
    delete device_os_;
  }
  if (device_os) {
    set_has_device_os();
    device_os_ = device_os;
  } else {
    clear_has_device_os();
    device_os_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string device_key = 5;
inline bool Hello::has_device_key() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Hello::set_has_device_key() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Hello::clear_has_device_key() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Hello::clear_device_key() {
  if (device_key_ != &::google::protobuf::internal::kEmptyString) {
    device_key_->clear();
  }
  clear_has_device_key();
}
inline const ::std::string& Hello::device_key() const {
  return *device_key_;
}
inline void Hello::set_device_key(const ::std::string& value) {
  set_has_device_key();
  if (device_key_ == &::google::protobuf::internal::kEmptyString) {
    device_key_ = new ::std::string;
  }
  device_key_->assign(value);
}
inline void Hello::set_device_key(const char* value) {
  set_has_device_key();
  if (device_key_ == &::google::protobuf::internal::kEmptyString) {
    device_key_ = new ::std::string;
  }
  device_key_->assign(value);
}
inline void Hello::set_device_key(const char* value, size_t size) {
  set_has_device_key();
  if (device_key_ == &::google::protobuf::internal::kEmptyString) {
    device_key_ = new ::std::string;
  }
  device_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Hello::mutable_device_key() {
  set_has_device_key();
  if (device_key_ == &::google::protobuf::internal::kEmptyString) {
    device_key_ = new ::std::string;
  }
  return device_key_;
}
inline ::std::string* Hello::release_device_key() {
  clear_has_device_key();
  if (device_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_key_;
    device_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Hello::set_allocated_device_key(::std::string* device_key) {
  if (device_key_ != &::google::protobuf::internal::kEmptyString) {
    delete device_key_;
  }
  if (device_key) {
    set_has_device_key();
    device_key_ = device_key;
  } else {
    clear_has_device_key();
    device_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// HelloReply

// optional uint32 rcode = 1;
inline bool HelloReply::has_rcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HelloReply::set_has_rcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HelloReply::clear_has_rcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HelloReply::clear_rcode() {
  rcode_ = 0u;
  clear_has_rcode();
}
inline ::google::protobuf::uint32 HelloReply::rcode() const {
  return rcode_;
}
inline void HelloReply::set_rcode(::google::protobuf::uint32 value) {
  set_has_rcode();
  rcode_ = value;
}

// optional string rdesc = 2;
inline bool HelloReply::has_rdesc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HelloReply::set_has_rdesc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HelloReply::clear_has_rdesc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HelloReply::clear_rdesc() {
  if (rdesc_ != &::google::protobuf::internal::kEmptyString) {
    rdesc_->clear();
  }
  clear_has_rdesc();
}
inline const ::std::string& HelloReply::rdesc() const {
  return *rdesc_;
}
inline void HelloReply::set_rdesc(const ::std::string& value) {
  set_has_rdesc();
  if (rdesc_ == &::google::protobuf::internal::kEmptyString) {
    rdesc_ = new ::std::string;
  }
  rdesc_->assign(value);
}
inline void HelloReply::set_rdesc(const char* value) {
  set_has_rdesc();
  if (rdesc_ == &::google::protobuf::internal::kEmptyString) {
    rdesc_ = new ::std::string;
  }
  rdesc_->assign(value);
}
inline void HelloReply::set_rdesc(const char* value, size_t size) {
  set_has_rdesc();
  if (rdesc_ == &::google::protobuf::internal::kEmptyString) {
    rdesc_ = new ::std::string;
  }
  rdesc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HelloReply::mutable_rdesc() {
  set_has_rdesc();
  if (rdesc_ == &::google::protobuf::internal::kEmptyString) {
    rdesc_ = new ::std::string;
  }
  return rdesc_;
}
inline ::std::string* HelloReply::release_rdesc() {
  clear_has_rdesc();
  if (rdesc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rdesc_;
    rdesc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HelloReply::set_allocated_rdesc(::std::string* rdesc) {
  if (rdesc_ != &::google::protobuf::internal::kEmptyString) {
    delete rdesc_;
  }
  if (rdesc) {
    set_has_rdesc();
    rdesc_ = rdesc;
  } else {
    clear_has_rdesc();
    rdesc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 version_code = 3;
inline bool HelloReply::has_version_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HelloReply::set_has_version_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HelloReply::clear_has_version_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HelloReply::clear_version_code() {
  version_code_ = 0u;
  clear_has_version_code();
}
inline ::google::protobuf::uint32 HelloReply::version_code() const {
  return version_code_;
}
inline void HelloReply::set_version_code(::google::protobuf::uint32 value) {
  set_has_version_code();
  version_code_ = value;
}

// optional string version_name = 4;
inline bool HelloReply::has_version_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HelloReply::set_has_version_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HelloReply::clear_has_version_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HelloReply::clear_version_name() {
  if (version_name_ != &::google::protobuf::internal::kEmptyString) {
    version_name_->clear();
  }
  clear_has_version_name();
}
inline const ::std::string& HelloReply::version_name() const {
  return *version_name_;
}
inline void HelloReply::set_version_name(const ::std::string& value) {
  set_has_version_name();
  if (version_name_ == &::google::protobuf::internal::kEmptyString) {
    version_name_ = new ::std::string;
  }
  version_name_->assign(value);
}
inline void HelloReply::set_version_name(const char* value) {
  set_has_version_name();
  if (version_name_ == &::google::protobuf::internal::kEmptyString) {
    version_name_ = new ::std::string;
  }
  version_name_->assign(value);
}
inline void HelloReply::set_version_name(const char* value, size_t size) {
  set_has_version_name();
  if (version_name_ == &::google::protobuf::internal::kEmptyString) {
    version_name_ = new ::std::string;
  }
  version_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HelloReply::mutable_version_name() {
  set_has_version_name();
  if (version_name_ == &::google::protobuf::internal::kEmptyString) {
    version_name_ = new ::std::string;
  }
  return version_name_;
}
inline ::std::string* HelloReply::release_version_name() {
  clear_has_version_name();
  if (version_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_name_;
    version_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HelloReply::set_allocated_version_name(::std::string* version_name) {
  if (version_name_ != &::google::protobuf::internal::kEmptyString) {
    delete version_name_;
  }
  if (version_name) {
    set_has_version_name();
    version_name_ = version_name;
  } else {
    clear_has_version_name();
    version_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .com.mservice.momo.msg.RegStatus reg_status = 5;
inline bool HelloReply::has_reg_status() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HelloReply::set_has_reg_status() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HelloReply::clear_has_reg_status() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HelloReply::clear_reg_status() {
  if (reg_status_ != NULL) reg_status_->::com::mservice::momo::msg::RegStatus::Clear();
  clear_has_reg_status();
}
inline const ::com::mservice::momo::msg::RegStatus& HelloReply::reg_status() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return reg_status_ != NULL ? *reg_status_ : *default_instance().reg_status_;
#else
  return reg_status_ != NULL ? *reg_status_ : *default_instance_->reg_status_;
#endif
}
inline ::com::mservice::momo::msg::RegStatus* HelloReply::mutable_reg_status() {
  set_has_reg_status();
  if (reg_status_ == NULL) reg_status_ = new ::com::mservice::momo::msg::RegStatus;
  return reg_status_;
}
inline ::com::mservice::momo::msg::RegStatus* HelloReply::release_reg_status() {
  clear_has_reg_status();
  ::com::mservice::momo::msg::RegStatus* temp = reg_status_;
  reg_status_ = NULL;
  return temp;
}
inline void HelloReply::set_allocated_reg_status(::com::mservice::momo::msg::RegStatus* reg_status) {
  delete reg_status_;
  reg_status_ = reg_status;
  if (reg_status) {
    set_has_reg_status();
  } else {
    clear_has_reg_status();
  }
}

// -------------------------------------------------------------------

// VerifyOtp

// optional string otp = 1;
inline bool VerifyOtp::has_otp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VerifyOtp::set_has_otp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VerifyOtp::clear_has_otp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VerifyOtp::clear_otp() {
  if (otp_ != &::google::protobuf::internal::kEmptyString) {
    otp_->clear();
  }
  clear_has_otp();
}
inline const ::std::string& VerifyOtp::otp() const {
  return *otp_;
}
inline void VerifyOtp::set_otp(const ::std::string& value) {
  set_has_otp();
  if (otp_ == &::google::protobuf::internal::kEmptyString) {
    otp_ = new ::std::string;
  }
  otp_->assign(value);
}
inline void VerifyOtp::set_otp(const char* value) {
  set_has_otp();
  if (otp_ == &::google::protobuf::internal::kEmptyString) {
    otp_ = new ::std::string;
  }
  otp_->assign(value);
}
inline void VerifyOtp::set_otp(const char* value, size_t size) {
  set_has_otp();
  if (otp_ == &::google::protobuf::internal::kEmptyString) {
    otp_ = new ::std::string;
  }
  otp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VerifyOtp::mutable_otp() {
  set_has_otp();
  if (otp_ == &::google::protobuf::internal::kEmptyString) {
    otp_ = new ::std::string;
  }
  return otp_;
}
inline ::std::string* VerifyOtp::release_otp() {
  clear_has_otp();
  if (otp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = otp_;
    otp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void VerifyOtp::set_allocated_otp(::std::string* otp) {
  if (otp_ != &::google::protobuf::internal::kEmptyString) {
    delete otp_;
  }
  if (otp) {
    set_has_otp();
    otp_ = otp;
  } else {
    clear_has_otp();
    otp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// VerifyOtpReply

// optional bool result = 1;
inline bool VerifyOtpReply::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VerifyOtpReply::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VerifyOtpReply::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VerifyOtpReply::clear_result() {
  result_ = false;
  clear_has_result();
}
inline bool VerifyOtpReply::result() const {
  return result_;
}
inline void VerifyOtpReply::set_result(bool value) {
  set_has_result();
  result_ = value;
}

// optional uint32 rcode = 2;
inline bool VerifyOtpReply::has_rcode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VerifyOtpReply::set_has_rcode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VerifyOtpReply::clear_has_rcode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VerifyOtpReply::clear_rcode() {
  rcode_ = 0u;
  clear_has_rcode();
}
inline ::google::protobuf::uint32 VerifyOtpReply::rcode() const {
  return rcode_;
}
inline void VerifyOtpReply::set_rcode(::google::protobuf::uint32 value) {
  set_has_rcode();
  rcode_ = value;
}

// optional string imei_key = 3;
inline bool VerifyOtpReply::has_imei_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VerifyOtpReply::set_has_imei_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VerifyOtpReply::clear_has_imei_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VerifyOtpReply::clear_imei_key() {
  if (imei_key_ != &::google::protobuf::internal::kEmptyString) {
    imei_key_->clear();
  }
  clear_has_imei_key();
}
inline const ::std::string& VerifyOtpReply::imei_key() const {
  return *imei_key_;
}
inline void VerifyOtpReply::set_imei_key(const ::std::string& value) {
  set_has_imei_key();
  if (imei_key_ == &::google::protobuf::internal::kEmptyString) {
    imei_key_ = new ::std::string;
  }
  imei_key_->assign(value);
}
inline void VerifyOtpReply::set_imei_key(const char* value) {
  set_has_imei_key();
  if (imei_key_ == &::google::protobuf::internal::kEmptyString) {
    imei_key_ = new ::std::string;
  }
  imei_key_->assign(value);
}
inline void VerifyOtpReply::set_imei_key(const char* value, size_t size) {
  set_has_imei_key();
  if (imei_key_ == &::google::protobuf::internal::kEmptyString) {
    imei_key_ = new ::std::string;
  }
  imei_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VerifyOtpReply::mutable_imei_key() {
  set_has_imei_key();
  if (imei_key_ == &::google::protobuf::internal::kEmptyString) {
    imei_key_ = new ::std::string;
  }
  return imei_key_;
}
inline ::std::string* VerifyOtpReply::release_imei_key() {
  clear_has_imei_key();
  if (imei_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = imei_key_;
    imei_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void VerifyOtpReply::set_allocated_imei_key(::std::string* imei_key) {
  if (imei_key_ != &::google::protobuf::internal::kEmptyString) {
    delete imei_key_;
  }
  if (imei_key) {
    set_has_imei_key();
    imei_key_ = imei_key;
  } else {
    clear_has_imei_key();
    imei_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .com.mservice.momo.msg.RegStatus reg_status = 4;
inline bool VerifyOtpReply::has_reg_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VerifyOtpReply::set_has_reg_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VerifyOtpReply::clear_has_reg_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VerifyOtpReply::clear_reg_status() {
  if (reg_status_ != NULL) reg_status_->::com::mservice::momo::msg::RegStatus::Clear();
  clear_has_reg_status();
}
inline const ::com::mservice::momo::msg::RegStatus& VerifyOtpReply::reg_status() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return reg_status_ != NULL ? *reg_status_ : *default_instance().reg_status_;
#else
  return reg_status_ != NULL ? *reg_status_ : *default_instance_->reg_status_;
#endif
}
inline ::com::mservice::momo::msg::RegStatus* VerifyOtpReply::mutable_reg_status() {
  set_has_reg_status();
  if (reg_status_ == NULL) reg_status_ = new ::com::mservice::momo::msg::RegStatus;
  return reg_status_;
}
inline ::com::mservice::momo::msg::RegStatus* VerifyOtpReply::release_reg_status() {
  clear_has_reg_status();
  ::com::mservice::momo::msg::RegStatus* temp = reg_status_;
  reg_status_ = NULL;
  return temp;
}
inline void VerifyOtpReply::set_allocated_reg_status(::com::mservice::momo::msg::RegStatus* reg_status) {
  delete reg_status_;
  reg_status_ = reg_status;
  if (reg_status) {
    set_has_reg_status();
  } else {
    clear_has_reg_status();
  }
}

// -------------------------------------------------------------------

// Register

// optional string name = 1;
inline bool Register::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Register::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Register::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Register::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Register::name() const {
  return *name_;
}
inline void Register::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Register::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Register::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Register::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Register::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Register::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string card_id = 2;
inline bool Register::has_card_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Register::set_has_card_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Register::clear_has_card_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Register::clear_card_id() {
  if (card_id_ != &::google::protobuf::internal::kEmptyString) {
    card_id_->clear();
  }
  clear_has_card_id();
}
inline const ::std::string& Register::card_id() const {
  return *card_id_;
}
inline void Register::set_card_id(const ::std::string& value) {
  set_has_card_id();
  if (card_id_ == &::google::protobuf::internal::kEmptyString) {
    card_id_ = new ::std::string;
  }
  card_id_->assign(value);
}
inline void Register::set_card_id(const char* value) {
  set_has_card_id();
  if (card_id_ == &::google::protobuf::internal::kEmptyString) {
    card_id_ = new ::std::string;
  }
  card_id_->assign(value);
}
inline void Register::set_card_id(const char* value, size_t size) {
  set_has_card_id();
  if (card_id_ == &::google::protobuf::internal::kEmptyString) {
    card_id_ = new ::std::string;
  }
  card_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Register::mutable_card_id() {
  set_has_card_id();
  if (card_id_ == &::google::protobuf::internal::kEmptyString) {
    card_id_ = new ::std::string;
  }
  return card_id_;
}
inline ::std::string* Register::release_card_id() {
  clear_has_card_id();
  if (card_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = card_id_;
    card_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Register::set_allocated_card_id(::std::string* card_id) {
  if (card_id_ != &::google::protobuf::internal::kEmptyString) {
    delete card_id_;
  }
  if (card_id) {
    set_has_card_id();
    card_id_ = card_id;
  } else {
    clear_has_card_id();
    card_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string address = 3;
inline bool Register::has_address() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Register::set_has_address() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Register::clear_has_address() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Register::clear_address() {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& Register::address() const {
  return *address_;
}
inline void Register::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void Register::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void Register::set_address(const char* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Register::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  return address_;
}
inline ::std::string* Register::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Register::set_allocated_address(::std::string* address) {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    delete address_;
  }
  if (address) {
    set_has_address();
    address_ = address;
  } else {
    clear_has_address();
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string dob = 4;
inline bool Register::has_dob() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Register::set_has_dob() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Register::clear_has_dob() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Register::clear_dob() {
  if (dob_ != &::google::protobuf::internal::kEmptyString) {
    dob_->clear();
  }
  clear_has_dob();
}
inline const ::std::string& Register::dob() const {
  return *dob_;
}
inline void Register::set_dob(const ::std::string& value) {
  set_has_dob();
  if (dob_ == &::google::protobuf::internal::kEmptyString) {
    dob_ = new ::std::string;
  }
  dob_->assign(value);
}
inline void Register::set_dob(const char* value) {
  set_has_dob();
  if (dob_ == &::google::protobuf::internal::kEmptyString) {
    dob_ = new ::std::string;
  }
  dob_->assign(value);
}
inline void Register::set_dob(const char* value, size_t size) {
  set_has_dob();
  if (dob_ == &::google::protobuf::internal::kEmptyString) {
    dob_ = new ::std::string;
  }
  dob_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Register::mutable_dob() {
  set_has_dob();
  if (dob_ == &::google::protobuf::internal::kEmptyString) {
    dob_ = new ::std::string;
  }
  return dob_;
}
inline ::std::string* Register::release_dob() {
  clear_has_dob();
  if (dob_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dob_;
    dob_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Register::set_allocated_dob(::std::string* dob) {
  if (dob_ != &::google::protobuf::internal::kEmptyString) {
    delete dob_;
  }
  if (dob) {
    set_has_dob();
    dob_ = dob;
  } else {
    clear_has_dob();
    dob_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string pin = 5;
inline bool Register::has_pin() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Register::set_has_pin() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Register::clear_has_pin() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Register::clear_pin() {
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    pin_->clear();
  }
  clear_has_pin();
}
inline const ::std::string& Register::pin() const {
  return *pin_;
}
inline void Register::set_pin(const ::std::string& value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void Register::set_pin(const char* value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void Register::set_pin(const char* value, size_t size) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Register::mutable_pin() {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  return pin_;
}
inline ::std::string* Register::release_pin() {
  clear_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pin_;
    pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Register::set_allocated_pin(::std::string* pin) {
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    delete pin_;
  }
  if (pin) {
    set_has_pin();
    pin_ = pin;
  } else {
    clear_has_pin();
    pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string email = 6;
inline bool Register::has_email() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Register::set_has_email() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Register::clear_has_email() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Register::clear_email() {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& Register::email() const {
  return *email_;
}
inline void Register::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void Register::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void Register::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Register::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  return email_;
}
inline ::std::string* Register::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Register::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string question = 7;
inline bool Register::has_question() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Register::set_has_question() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Register::clear_has_question() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Register::clear_question() {
  if (question_ != &::google::protobuf::internal::kEmptyString) {
    question_->clear();
  }
  clear_has_question();
}
inline const ::std::string& Register::question() const {
  return *question_;
}
inline void Register::set_question(const ::std::string& value) {
  set_has_question();
  if (question_ == &::google::protobuf::internal::kEmptyString) {
    question_ = new ::std::string;
  }
  question_->assign(value);
}
inline void Register::set_question(const char* value) {
  set_has_question();
  if (question_ == &::google::protobuf::internal::kEmptyString) {
    question_ = new ::std::string;
  }
  question_->assign(value);
}
inline void Register::set_question(const char* value, size_t size) {
  set_has_question();
  if (question_ == &::google::protobuf::internal::kEmptyString) {
    question_ = new ::std::string;
  }
  question_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Register::mutable_question() {
  set_has_question();
  if (question_ == &::google::protobuf::internal::kEmptyString) {
    question_ = new ::std::string;
  }
  return question_;
}
inline ::std::string* Register::release_question() {
  clear_has_question();
  if (question_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = question_;
    question_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Register::set_allocated_question(::std::string* question) {
  if (question_ != &::google::protobuf::internal::kEmptyString) {
    delete question_;
  }
  if (question) {
    set_has_question();
    question_ = question;
  } else {
    clear_has_question();
    question_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string answer = 8;
inline bool Register::has_answer() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Register::set_has_answer() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Register::clear_has_answer() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Register::clear_answer() {
  if (answer_ != &::google::protobuf::internal::kEmptyString) {
    answer_->clear();
  }
  clear_has_answer();
}
inline const ::std::string& Register::answer() const {
  return *answer_;
}
inline void Register::set_answer(const ::std::string& value) {
  set_has_answer();
  if (answer_ == &::google::protobuf::internal::kEmptyString) {
    answer_ = new ::std::string;
  }
  answer_->assign(value);
}
inline void Register::set_answer(const char* value) {
  set_has_answer();
  if (answer_ == &::google::protobuf::internal::kEmptyString) {
    answer_ = new ::std::string;
  }
  answer_->assign(value);
}
inline void Register::set_answer(const char* value, size_t size) {
  set_has_answer();
  if (answer_ == &::google::protobuf::internal::kEmptyString) {
    answer_ = new ::std::string;
  }
  answer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Register::mutable_answer() {
  set_has_answer();
  if (answer_ == &::google::protobuf::internal::kEmptyString) {
    answer_ = new ::std::string;
  }
  return answer_;
}
inline ::std::string* Register::release_answer() {
  clear_has_answer();
  if (answer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = answer_;
    answer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Register::set_allocated_answer(::std::string* answer) {
  if (answer_ != &::google::protobuf::internal::kEmptyString) {
    delete answer_;
  }
  if (answer) {
    set_has_answer();
    answer_ = answer;
  } else {
    clear_has_answer();
    answer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string reference = 9;
inline bool Register::has_reference() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Register::set_has_reference() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Register::clear_has_reference() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Register::clear_reference() {
  if (reference_ != &::google::protobuf::internal::kEmptyString) {
    reference_->clear();
  }
  clear_has_reference();
}
inline const ::std::string& Register::reference() const {
  return *reference_;
}
inline void Register::set_reference(const ::std::string& value) {
  set_has_reference();
  if (reference_ == &::google::protobuf::internal::kEmptyString) {
    reference_ = new ::std::string;
  }
  reference_->assign(value);
}
inline void Register::set_reference(const char* value) {
  set_has_reference();
  if (reference_ == &::google::protobuf::internal::kEmptyString) {
    reference_ = new ::std::string;
  }
  reference_->assign(value);
}
inline void Register::set_reference(const char* value, size_t size) {
  set_has_reference();
  if (reference_ == &::google::protobuf::internal::kEmptyString) {
    reference_ = new ::std::string;
  }
  reference_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Register::mutable_reference() {
  set_has_reference();
  if (reference_ == &::google::protobuf::internal::kEmptyString) {
    reference_ = new ::std::string;
  }
  return reference_;
}
inline ::std::string* Register::release_reference() {
  clear_has_reference();
  if (reference_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reference_;
    reference_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Register::set_allocated_reference(::std::string* reference) {
  if (reference_ != &::google::protobuf::internal::kEmptyString) {
    delete reference_;
  }
  if (reference) {
    set_has_reference();
    reference_ = reference;
  } else {
    clear_has_reference();
    reference_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .com.mservice.momo.msg.TextValue keyValue = 10;
inline int Register::keyvalue_size() const {
  return keyvalue_.size();
}
inline void Register::clear_keyvalue() {
  keyvalue_.Clear();
}
inline const ::com::mservice::momo::msg::TextValue& Register::keyvalue(int index) const {
  return keyvalue_.Get(index);
}
inline ::com::mservice::momo::msg::TextValue* Register::mutable_keyvalue(int index) {
  return keyvalue_.Mutable(index);
}
inline ::com::mservice::momo::msg::TextValue* Register::add_keyvalue() {
  return keyvalue_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::TextValue >&
Register::keyvalue() const {
  return keyvalue_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::TextValue >*
Register::mutable_keyvalue() {
  return &keyvalue_;
}

// -------------------------------------------------------------------

// LogIn

// optional string mpin = 1;
inline bool LogIn::has_mpin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogIn::set_has_mpin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogIn::clear_has_mpin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogIn::clear_mpin() {
  if (mpin_ != &::google::protobuf::internal::kEmptyString) {
    mpin_->clear();
  }
  clear_has_mpin();
}
inline const ::std::string& LogIn::mpin() const {
  return *mpin_;
}
inline void LogIn::set_mpin(const ::std::string& value) {
  set_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    mpin_ = new ::std::string;
  }
  mpin_->assign(value);
}
inline void LogIn::set_mpin(const char* value) {
  set_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    mpin_ = new ::std::string;
  }
  mpin_->assign(value);
}
inline void LogIn::set_mpin(const char* value, size_t size) {
  set_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    mpin_ = new ::std::string;
  }
  mpin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogIn::mutable_mpin() {
  set_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    mpin_ = new ::std::string;
  }
  return mpin_;
}
inline ::std::string* LogIn::release_mpin() {
  clear_has_mpin();
  if (mpin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mpin_;
    mpin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LogIn::set_allocated_mpin(::std::string* mpin) {
  if (mpin_ != &::google::protobuf::internal::kEmptyString) {
    delete mpin_;
  }
  if (mpin) {
    set_has_mpin();
    mpin_ = mpin;
  } else {
    clear_has_mpin();
    mpin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string device_model = 2;
inline bool LogIn::has_device_model() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogIn::set_has_device_model() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogIn::clear_has_device_model() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogIn::clear_device_model() {
  if (device_model_ != &::google::protobuf::internal::kEmptyString) {
    device_model_->clear();
  }
  clear_has_device_model();
}
inline const ::std::string& LogIn::device_model() const {
  return *device_model_;
}
inline void LogIn::set_device_model(const ::std::string& value) {
  set_has_device_model();
  if (device_model_ == &::google::protobuf::internal::kEmptyString) {
    device_model_ = new ::std::string;
  }
  device_model_->assign(value);
}
inline void LogIn::set_device_model(const char* value) {
  set_has_device_model();
  if (device_model_ == &::google::protobuf::internal::kEmptyString) {
    device_model_ = new ::std::string;
  }
  device_model_->assign(value);
}
inline void LogIn::set_device_model(const char* value, size_t size) {
  set_has_device_model();
  if (device_model_ == &::google::protobuf::internal::kEmptyString) {
    device_model_ = new ::std::string;
  }
  device_model_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogIn::mutable_device_model() {
  set_has_device_model();
  if (device_model_ == &::google::protobuf::internal::kEmptyString) {
    device_model_ = new ::std::string;
  }
  return device_model_;
}
inline ::std::string* LogIn::release_device_model() {
  clear_has_device_model();
  if (device_model_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_model_;
    device_model_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LogIn::set_allocated_device_model(::std::string* device_model) {
  if (device_model_ != &::google::protobuf::internal::kEmptyString) {
    delete device_model_;
  }
  if (device_model) {
    set_has_device_model();
    device_model_ = device_model;
  } else {
    clear_has_device_model();
    device_model_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string agent_type = 3;
inline bool LogIn::has_agent_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LogIn::set_has_agent_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LogIn::clear_has_agent_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LogIn::clear_agent_type() {
  if (agent_type_ != &::google::protobuf::internal::kEmptyString) {
    agent_type_->clear();
  }
  clear_has_agent_type();
}
inline const ::std::string& LogIn::agent_type() const {
  return *agent_type_;
}
inline void LogIn::set_agent_type(const ::std::string& value) {
  set_has_agent_type();
  if (agent_type_ == &::google::protobuf::internal::kEmptyString) {
    agent_type_ = new ::std::string;
  }
  agent_type_->assign(value);
}
inline void LogIn::set_agent_type(const char* value) {
  set_has_agent_type();
  if (agent_type_ == &::google::protobuf::internal::kEmptyString) {
    agent_type_ = new ::std::string;
  }
  agent_type_->assign(value);
}
inline void LogIn::set_agent_type(const char* value, size_t size) {
  set_has_agent_type();
  if (agent_type_ == &::google::protobuf::internal::kEmptyString) {
    agent_type_ = new ::std::string;
  }
  agent_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogIn::mutable_agent_type() {
  set_has_agent_type();
  if (agent_type_ == &::google::protobuf::internal::kEmptyString) {
    agent_type_ = new ::std::string;
  }
  return agent_type_;
}
inline ::std::string* LogIn::release_agent_type() {
  clear_has_agent_type();
  if (agent_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = agent_type_;
    agent_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LogIn::set_allocated_agent_type(::std::string* agent_type) {
  if (agent_type_ != &::google::protobuf::internal::kEmptyString) {
    delete agent_type_;
  }
  if (agent_type) {
    set_has_agent_type();
    agent_type_ = agent_type;
  } else {
    clear_has_agent_type();
    agent_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string appVer = 4;
inline bool LogIn::has_appver() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LogIn::set_has_appver() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LogIn::clear_has_appver() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LogIn::clear_appver() {
  if (appver_ != &::google::protobuf::internal::kEmptyString) {
    appver_->clear();
  }
  clear_has_appver();
}
inline const ::std::string& LogIn::appver() const {
  return *appver_;
}
inline void LogIn::set_appver(const ::std::string& value) {
  set_has_appver();
  if (appver_ == &::google::protobuf::internal::kEmptyString) {
    appver_ = new ::std::string;
  }
  appver_->assign(value);
}
inline void LogIn::set_appver(const char* value) {
  set_has_appver();
  if (appver_ == &::google::protobuf::internal::kEmptyString) {
    appver_ = new ::std::string;
  }
  appver_->assign(value);
}
inline void LogIn::set_appver(const char* value, size_t size) {
  set_has_appver();
  if (appver_ == &::google::protobuf::internal::kEmptyString) {
    appver_ = new ::std::string;
  }
  appver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogIn::mutable_appver() {
  set_has_appver();
  if (appver_ == &::google::protobuf::internal::kEmptyString) {
    appver_ = new ::std::string;
  }
  return appver_;
}
inline ::std::string* LogIn::release_appver() {
  clear_has_appver();
  if (appver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = appver_;
    appver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LogIn::set_allocated_appver(::std::string* appver) {
  if (appver_ != &::google::protobuf::internal::kEmptyString) {
    delete appver_;
  }
  if (appver) {
    set_has_appver();
    appver_ = appver;
  } else {
    clear_has_appver();
    appver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string codeVer = 5;
inline bool LogIn::has_codever() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LogIn::set_has_codever() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LogIn::clear_has_codever() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LogIn::clear_codever() {
  if (codever_ != &::google::protobuf::internal::kEmptyString) {
    codever_->clear();
  }
  clear_has_codever();
}
inline const ::std::string& LogIn::codever() const {
  return *codever_;
}
inline void LogIn::set_codever(const ::std::string& value) {
  set_has_codever();
  if (codever_ == &::google::protobuf::internal::kEmptyString) {
    codever_ = new ::std::string;
  }
  codever_->assign(value);
}
inline void LogIn::set_codever(const char* value) {
  set_has_codever();
  if (codever_ == &::google::protobuf::internal::kEmptyString) {
    codever_ = new ::std::string;
  }
  codever_->assign(value);
}
inline void LogIn::set_codever(const char* value, size_t size) {
  set_has_codever();
  if (codever_ == &::google::protobuf::internal::kEmptyString) {
    codever_ = new ::std::string;
  }
  codever_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogIn::mutable_codever() {
  set_has_codever();
  if (codever_ == &::google::protobuf::internal::kEmptyString) {
    codever_ = new ::std::string;
  }
  return codever_;
}
inline ::std::string* LogIn::release_codever() {
  clear_has_codever();
  if (codever_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = codever_;
    codever_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LogIn::set_allocated_codever(::std::string* codever) {
  if (codever_ != &::google::protobuf::internal::kEmptyString) {
    delete codever_;
  }
  if (codever) {
    set_has_codever();
    codever_ = codever;
  } else {
    clear_has_codever();
    codever_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LogInReply

// optional bool result = 1;
inline bool LogInReply::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogInReply::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogInReply::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogInReply::clear_result() {
  result_ = false;
  clear_has_result();
}
inline bool LogInReply::result() const {
  return result_;
}
inline void LogInReply::set_result(bool value) {
  set_has_result();
  result_ = value;
}

// optional uint32 rcode = 2;
inline bool LogInReply::has_rcode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogInReply::set_has_rcode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogInReply::clear_has_rcode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogInReply::clear_rcode() {
  rcode_ = 0u;
  clear_has_rcode();
}
inline ::google::protobuf::uint32 LogInReply::rcode() const {
  return rcode_;
}
inline void LogInReply::set_rcode(::google::protobuf::uint32 value) {
  set_has_rcode();
  rcode_ = value;
}

// optional string skey = 3;
inline bool LogInReply::has_skey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LogInReply::set_has_skey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LogInReply::clear_has_skey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LogInReply::clear_skey() {
  if (skey_ != &::google::protobuf::internal::kEmptyString) {
    skey_->clear();
  }
  clear_has_skey();
}
inline const ::std::string& LogInReply::skey() const {
  return *skey_;
}
inline void LogInReply::set_skey(const ::std::string& value) {
  set_has_skey();
  if (skey_ == &::google::protobuf::internal::kEmptyString) {
    skey_ = new ::std::string;
  }
  skey_->assign(value);
}
inline void LogInReply::set_skey(const char* value) {
  set_has_skey();
  if (skey_ == &::google::protobuf::internal::kEmptyString) {
    skey_ = new ::std::string;
  }
  skey_->assign(value);
}
inline void LogInReply::set_skey(const char* value, size_t size) {
  set_has_skey();
  if (skey_ == &::google::protobuf::internal::kEmptyString) {
    skey_ = new ::std::string;
  }
  skey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogInReply::mutable_skey() {
  set_has_skey();
  if (skey_ == &::google::protobuf::internal::kEmptyString) {
    skey_ = new ::std::string;
  }
  return skey_;
}
inline ::std::string* LogInReply::release_skey() {
  clear_has_skey();
  if (skey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = skey_;
    skey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LogInReply::set_allocated_skey(::std::string* skey) {
  if (skey_ != &::google::protobuf::internal::kEmptyString) {
    delete skey_;
  }
  if (skey) {
    set_has_skey();
    skey_ = skey;
  } else {
    clear_has_skey();
    skey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 time = 4;
inline bool LogInReply::has_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LogInReply::set_has_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LogInReply::clear_has_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LogInReply::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::uint64 LogInReply::time() const {
  return time_;
}
inline void LogInReply::set_time(::google::protobuf::uint64 value) {
  set_has_time();
  time_ = value;
}

// optional uint32 login_remain_count = 5;
inline bool LogInReply::has_login_remain_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LogInReply::set_has_login_remain_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LogInReply::clear_has_login_remain_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LogInReply::clear_login_remain_count() {
  login_remain_count_ = 0u;
  clear_has_login_remain_count();
}
inline ::google::protobuf::uint32 LogInReply::login_remain_count() const {
  return login_remain_count_;
}
inline void LogInReply::set_login_remain_count(::google::protobuf::uint32 value) {
  set_has_login_remain_count();
  login_remain_count_ = value;
}

// optional uint64 locked_until = 6;
inline bool LogInReply::has_locked_until() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LogInReply::set_has_locked_until() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LogInReply::clear_has_locked_until() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LogInReply::clear_locked_until() {
  locked_until_ = GOOGLE_ULONGLONG(0);
  clear_has_locked_until();
}
inline ::google::protobuf::uint64 LogInReply::locked_until() const {
  return locked_until_;
}
inline void LogInReply::set_locked_until(::google::protobuf::uint64 value) {
  set_has_locked_until();
  locked_until_ = value;
}

// -------------------------------------------------------------------

// GetBillInfo

// optional string provider_id = 1;
inline bool GetBillInfo::has_provider_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetBillInfo::set_has_provider_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetBillInfo::clear_has_provider_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetBillInfo::clear_provider_id() {
  if (provider_id_ != &::google::protobuf::internal::kEmptyString) {
    provider_id_->clear();
  }
  clear_has_provider_id();
}
inline const ::std::string& GetBillInfo::provider_id() const {
  return *provider_id_;
}
inline void GetBillInfo::set_provider_id(const ::std::string& value) {
  set_has_provider_id();
  if (provider_id_ == &::google::protobuf::internal::kEmptyString) {
    provider_id_ = new ::std::string;
  }
  provider_id_->assign(value);
}
inline void GetBillInfo::set_provider_id(const char* value) {
  set_has_provider_id();
  if (provider_id_ == &::google::protobuf::internal::kEmptyString) {
    provider_id_ = new ::std::string;
  }
  provider_id_->assign(value);
}
inline void GetBillInfo::set_provider_id(const char* value, size_t size) {
  set_has_provider_id();
  if (provider_id_ == &::google::protobuf::internal::kEmptyString) {
    provider_id_ = new ::std::string;
  }
  provider_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetBillInfo::mutable_provider_id() {
  set_has_provider_id();
  if (provider_id_ == &::google::protobuf::internal::kEmptyString) {
    provider_id_ = new ::std::string;
  }
  return provider_id_;
}
inline ::std::string* GetBillInfo::release_provider_id() {
  clear_has_provider_id();
  if (provider_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = provider_id_;
    provider_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetBillInfo::set_allocated_provider_id(::std::string* provider_id) {
  if (provider_id_ != &::google::protobuf::internal::kEmptyString) {
    delete provider_id_;
  }
  if (provider_id) {
    set_has_provider_id();
    provider_id_ = provider_id;
  } else {
    clear_has_provider_id();
    provider_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string bill_id = 2;
inline bool GetBillInfo::has_bill_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetBillInfo::set_has_bill_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetBillInfo::clear_has_bill_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetBillInfo::clear_bill_id() {
  if (bill_id_ != &::google::protobuf::internal::kEmptyString) {
    bill_id_->clear();
  }
  clear_has_bill_id();
}
inline const ::std::string& GetBillInfo::bill_id() const {
  return *bill_id_;
}
inline void GetBillInfo::set_bill_id(const ::std::string& value) {
  set_has_bill_id();
  if (bill_id_ == &::google::protobuf::internal::kEmptyString) {
    bill_id_ = new ::std::string;
  }
  bill_id_->assign(value);
}
inline void GetBillInfo::set_bill_id(const char* value) {
  set_has_bill_id();
  if (bill_id_ == &::google::protobuf::internal::kEmptyString) {
    bill_id_ = new ::std::string;
  }
  bill_id_->assign(value);
}
inline void GetBillInfo::set_bill_id(const char* value, size_t size) {
  set_has_bill_id();
  if (bill_id_ == &::google::protobuf::internal::kEmptyString) {
    bill_id_ = new ::std::string;
  }
  bill_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetBillInfo::mutable_bill_id() {
  set_has_bill_id();
  if (bill_id_ == &::google::protobuf::internal::kEmptyString) {
    bill_id_ = new ::std::string;
  }
  return bill_id_;
}
inline ::std::string* GetBillInfo::release_bill_id() {
  clear_has_bill_id();
  if (bill_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bill_id_;
    bill_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetBillInfo::set_allocated_bill_id(::std::string* bill_id) {
  if (bill_id_ != &::google::protobuf::internal::kEmptyString) {
    delete bill_id_;
  }
  if (bill_id) {
    set_has_bill_id();
    bill_id_ = bill_id;
  } else {
    clear_has_bill_id();
    bill_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 getBillInfoAction = 3;
inline bool GetBillInfo::has_getbillinfoaction() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetBillInfo::set_has_getbillinfoaction() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetBillInfo::clear_has_getbillinfoaction() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetBillInfo::clear_getbillinfoaction() {
  getbillinfoaction_ = 0;
  clear_has_getbillinfoaction();
}
inline ::google::protobuf::int32 GetBillInfo::getbillinfoaction() const {
  return getbillinfoaction_;
}
inline void GetBillInfo::set_getbillinfoaction(::google::protobuf::int32 value) {
  set_has_getbillinfoaction();
  getbillinfoaction_ = value;
}

// -------------------------------------------------------------------

// BillDetail

// optional string bill_id = 1;
inline bool BillDetail::has_bill_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BillDetail::set_has_bill_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BillDetail::clear_has_bill_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BillDetail::clear_bill_id() {
  if (bill_id_ != &::google::protobuf::internal::kEmptyString) {
    bill_id_->clear();
  }
  clear_has_bill_id();
}
inline const ::std::string& BillDetail::bill_id() const {
  return *bill_id_;
}
inline void BillDetail::set_bill_id(const ::std::string& value) {
  set_has_bill_id();
  if (bill_id_ == &::google::protobuf::internal::kEmptyString) {
    bill_id_ = new ::std::string;
  }
  bill_id_->assign(value);
}
inline void BillDetail::set_bill_id(const char* value) {
  set_has_bill_id();
  if (bill_id_ == &::google::protobuf::internal::kEmptyString) {
    bill_id_ = new ::std::string;
  }
  bill_id_->assign(value);
}
inline void BillDetail::set_bill_id(const char* value, size_t size) {
  set_has_bill_id();
  if (bill_id_ == &::google::protobuf::internal::kEmptyString) {
    bill_id_ = new ::std::string;
  }
  bill_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BillDetail::mutable_bill_id() {
  set_has_bill_id();
  if (bill_id_ == &::google::protobuf::internal::kEmptyString) {
    bill_id_ = new ::std::string;
  }
  return bill_id_;
}
inline ::std::string* BillDetail::release_bill_id() {
  clear_has_bill_id();
  if (bill_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bill_id_;
    bill_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BillDetail::set_allocated_bill_id(::std::string* bill_id) {
  if (bill_id_ != &::google::protobuf::internal::kEmptyString) {
    delete bill_id_;
  }
  if (bill_id) {
    set_has_bill_id();
    bill_id_ = bill_id;
  } else {
    clear_has_bill_id();
    bill_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 amount = 2;
inline bool BillDetail::has_amount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BillDetail::set_has_amount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BillDetail::clear_has_amount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BillDetail::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 BillDetail::amount() const {
  return amount_;
}
inline void BillDetail::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
}

// optional string from_date = 3;
inline bool BillDetail::has_from_date() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BillDetail::set_has_from_date() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BillDetail::clear_has_from_date() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BillDetail::clear_from_date() {
  if (from_date_ != &::google::protobuf::internal::kEmptyString) {
    from_date_->clear();
  }
  clear_has_from_date();
}
inline const ::std::string& BillDetail::from_date() const {
  return *from_date_;
}
inline void BillDetail::set_from_date(const ::std::string& value) {
  set_has_from_date();
  if (from_date_ == &::google::protobuf::internal::kEmptyString) {
    from_date_ = new ::std::string;
  }
  from_date_->assign(value);
}
inline void BillDetail::set_from_date(const char* value) {
  set_has_from_date();
  if (from_date_ == &::google::protobuf::internal::kEmptyString) {
    from_date_ = new ::std::string;
  }
  from_date_->assign(value);
}
inline void BillDetail::set_from_date(const char* value, size_t size) {
  set_has_from_date();
  if (from_date_ == &::google::protobuf::internal::kEmptyString) {
    from_date_ = new ::std::string;
  }
  from_date_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BillDetail::mutable_from_date() {
  set_has_from_date();
  if (from_date_ == &::google::protobuf::internal::kEmptyString) {
    from_date_ = new ::std::string;
  }
  return from_date_;
}
inline ::std::string* BillDetail::release_from_date() {
  clear_has_from_date();
  if (from_date_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = from_date_;
    from_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BillDetail::set_allocated_from_date(::std::string* from_date) {
  if (from_date_ != &::google::protobuf::internal::kEmptyString) {
    delete from_date_;
  }
  if (from_date) {
    set_has_from_date();
    from_date_ = from_date;
  } else {
    clear_has_from_date();
    from_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string to_date = 4;
inline bool BillDetail::has_to_date() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BillDetail::set_has_to_date() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BillDetail::clear_has_to_date() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BillDetail::clear_to_date() {
  if (to_date_ != &::google::protobuf::internal::kEmptyString) {
    to_date_->clear();
  }
  clear_has_to_date();
}
inline const ::std::string& BillDetail::to_date() const {
  return *to_date_;
}
inline void BillDetail::set_to_date(const ::std::string& value) {
  set_has_to_date();
  if (to_date_ == &::google::protobuf::internal::kEmptyString) {
    to_date_ = new ::std::string;
  }
  to_date_->assign(value);
}
inline void BillDetail::set_to_date(const char* value) {
  set_has_to_date();
  if (to_date_ == &::google::protobuf::internal::kEmptyString) {
    to_date_ = new ::std::string;
  }
  to_date_->assign(value);
}
inline void BillDetail::set_to_date(const char* value, size_t size) {
  set_has_to_date();
  if (to_date_ == &::google::protobuf::internal::kEmptyString) {
    to_date_ = new ::std::string;
  }
  to_date_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BillDetail::mutable_to_date() {
  set_has_to_date();
  if (to_date_ == &::google::protobuf::internal::kEmptyString) {
    to_date_ = new ::std::string;
  }
  return to_date_;
}
inline ::std::string* BillDetail::release_to_date() {
  clear_has_to_date();
  if (to_date_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = to_date_;
    to_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BillDetail::set_allocated_to_date(::std::string* to_date) {
  if (to_date_ != &::google::protobuf::internal::kEmptyString) {
    delete to_date_;
  }
  if (to_date) {
    set_has_to_date();
    to_date_ = to_date;
  } else {
    clear_has_to_date();
    to_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GetBillInfoReply

// optional bool result = 1;
inline bool GetBillInfoReply::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetBillInfoReply::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetBillInfoReply::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetBillInfoReply::clear_result() {
  result_ = false;
  clear_has_result();
}
inline bool GetBillInfoReply::result() const {
  return result_;
}
inline void GetBillInfoReply::set_result(bool value) {
  set_has_result();
  result_ = value;
}

// optional uint32 rcode = 2;
inline bool GetBillInfoReply::has_rcode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetBillInfoReply::set_has_rcode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetBillInfoReply::clear_has_rcode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetBillInfoReply::clear_rcode() {
  rcode_ = 0u;
  clear_has_rcode();
}
inline ::google::protobuf::uint32 GetBillInfoReply::rcode() const {
  return rcode_;
}
inline void GetBillInfoReply::set_rcode(::google::protobuf::uint32 value) {
  set_has_rcode();
  rcode_ = value;
}

// optional string rdesc = 3;
inline bool GetBillInfoReply::has_rdesc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetBillInfoReply::set_has_rdesc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetBillInfoReply::clear_has_rdesc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetBillInfoReply::clear_rdesc() {
  if (rdesc_ != &::google::protobuf::internal::kEmptyString) {
    rdesc_->clear();
  }
  clear_has_rdesc();
}
inline const ::std::string& GetBillInfoReply::rdesc() const {
  return *rdesc_;
}
inline void GetBillInfoReply::set_rdesc(const ::std::string& value) {
  set_has_rdesc();
  if (rdesc_ == &::google::protobuf::internal::kEmptyString) {
    rdesc_ = new ::std::string;
  }
  rdesc_->assign(value);
}
inline void GetBillInfoReply::set_rdesc(const char* value) {
  set_has_rdesc();
  if (rdesc_ == &::google::protobuf::internal::kEmptyString) {
    rdesc_ = new ::std::string;
  }
  rdesc_->assign(value);
}
inline void GetBillInfoReply::set_rdesc(const char* value, size_t size) {
  set_has_rdesc();
  if (rdesc_ == &::google::protobuf::internal::kEmptyString) {
    rdesc_ = new ::std::string;
  }
  rdesc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetBillInfoReply::mutable_rdesc() {
  set_has_rdesc();
  if (rdesc_ == &::google::protobuf::internal::kEmptyString) {
    rdesc_ = new ::std::string;
  }
  return rdesc_;
}
inline ::std::string* GetBillInfoReply::release_rdesc() {
  clear_has_rdesc();
  if (rdesc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rdesc_;
    rdesc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetBillInfoReply::set_allocated_rdesc(::std::string* rdesc) {
  if (rdesc_ != &::google::protobuf::internal::kEmptyString) {
    delete rdesc_;
  }
  if (rdesc) {
    set_has_rdesc();
    rdesc_ = rdesc;
  } else {
    clear_has_rdesc();
    rdesc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 4;
inline bool GetBillInfoReply::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetBillInfoReply::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetBillInfoReply::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetBillInfoReply::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& GetBillInfoReply::name() const {
  return *name_;
}
inline void GetBillInfoReply::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void GetBillInfoReply::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void GetBillInfoReply::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetBillInfoReply::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* GetBillInfoReply::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetBillInfoReply::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string phone = 5;
inline bool GetBillInfoReply::has_phone() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetBillInfoReply::set_has_phone() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetBillInfoReply::clear_has_phone() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetBillInfoReply::clear_phone() {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    phone_->clear();
  }
  clear_has_phone();
}
inline const ::std::string& GetBillInfoReply::phone() const {
  return *phone_;
}
inline void GetBillInfoReply::set_phone(const ::std::string& value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void GetBillInfoReply::set_phone(const char* value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void GetBillInfoReply::set_phone(const char* value, size_t size) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetBillInfoReply::mutable_phone() {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  return phone_;
}
inline ::std::string* GetBillInfoReply::release_phone() {
  clear_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phone_;
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetBillInfoReply::set_allocated_phone(::std::string* phone) {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    delete phone_;
  }
  if (phone) {
    set_has_phone();
    phone_ = phone;
  } else {
    clear_has_phone();
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string address = 6;
inline bool GetBillInfoReply::has_address() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GetBillInfoReply::set_has_address() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GetBillInfoReply::clear_has_address() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GetBillInfoReply::clear_address() {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& GetBillInfoReply::address() const {
  return *address_;
}
inline void GetBillInfoReply::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void GetBillInfoReply::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void GetBillInfoReply::set_address(const char* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetBillInfoReply::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  return address_;
}
inline ::std::string* GetBillInfoReply::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetBillInfoReply::set_allocated_address(::std::string* address) {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    delete address_;
  }
  if (address) {
    set_has_address();
    address_ = address;
  } else {
    clear_has_address();
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .com.mservice.momo.msg.BillDetail bills = 7;
inline int GetBillInfoReply::bills_size() const {
  return bills_.size();
}
inline void GetBillInfoReply::clear_bills() {
  bills_.Clear();
}
inline const ::com::mservice::momo::msg::BillDetail& GetBillInfoReply::bills(int index) const {
  return bills_.Get(index);
}
inline ::com::mservice::momo::msg::BillDetail* GetBillInfoReply::mutable_bills(int index) {
  return bills_.Mutable(index);
}
inline ::com::mservice::momo::msg::BillDetail* GetBillInfoReply::add_bills() {
  return bills_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::BillDetail >&
GetBillInfoReply::bills() const {
  return bills_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::BillDetail >*
GetBillInfoReply::mutable_bills() {
  return &bills_;
}

// optional .com.mservice.momo.msg.GetBillInfoAction action = 8;
inline bool GetBillInfoReply::has_action() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GetBillInfoReply::set_has_action() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GetBillInfoReply::clear_has_action() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GetBillInfoReply::clear_action() {
  action_ = 1;
  clear_has_action();
}
inline ::com::mservice::momo::msg::GetBillInfoAction GetBillInfoReply::action() const {
  return static_cast< ::com::mservice::momo::msg::GetBillInfoAction >(action_);
}
inline void GetBillInfoReply::set_action(::com::mservice::momo::msg::GetBillInfoAction value) {
  assert(::com::mservice::momo::msg::GetBillInfoAction_IsValid(value));
  set_has_action();
  action_ = value;
}

// optional string providerId = 9;
inline bool GetBillInfoReply::has_providerid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GetBillInfoReply::set_has_providerid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GetBillInfoReply::clear_has_providerid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GetBillInfoReply::clear_providerid() {
  if (providerid_ != &::google::protobuf::internal::kEmptyString) {
    providerid_->clear();
  }
  clear_has_providerid();
}
inline const ::std::string& GetBillInfoReply::providerid() const {
  return *providerid_;
}
inline void GetBillInfoReply::set_providerid(const ::std::string& value) {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  providerid_->assign(value);
}
inline void GetBillInfoReply::set_providerid(const char* value) {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  providerid_->assign(value);
}
inline void GetBillInfoReply::set_providerid(const char* value, size_t size) {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  providerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetBillInfoReply::mutable_providerid() {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  return providerid_;
}
inline ::std::string* GetBillInfoReply::release_providerid() {
  clear_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = providerid_;
    providerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetBillInfoReply::set_allocated_providerid(::std::string* providerid) {
  if (providerid_ != &::google::protobuf::internal::kEmptyString) {
    delete providerid_;
  }
  if (providerid) {
    set_has_providerid();
    providerid_ = providerid;
  } else {
    clear_has_providerid();
    providerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string billId = 10;
inline bool GetBillInfoReply::has_billid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GetBillInfoReply::set_has_billid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GetBillInfoReply::clear_has_billid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GetBillInfoReply::clear_billid() {
  if (billid_ != &::google::protobuf::internal::kEmptyString) {
    billid_->clear();
  }
  clear_has_billid();
}
inline const ::std::string& GetBillInfoReply::billid() const {
  return *billid_;
}
inline void GetBillInfoReply::set_billid(const ::std::string& value) {
  set_has_billid();
  if (billid_ == &::google::protobuf::internal::kEmptyString) {
    billid_ = new ::std::string;
  }
  billid_->assign(value);
}
inline void GetBillInfoReply::set_billid(const char* value) {
  set_has_billid();
  if (billid_ == &::google::protobuf::internal::kEmptyString) {
    billid_ = new ::std::string;
  }
  billid_->assign(value);
}
inline void GetBillInfoReply::set_billid(const char* value, size_t size) {
  set_has_billid();
  if (billid_ == &::google::protobuf::internal::kEmptyString) {
    billid_ = new ::std::string;
  }
  billid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetBillInfoReply::mutable_billid() {
  set_has_billid();
  if (billid_ == &::google::protobuf::internal::kEmptyString) {
    billid_ = new ::std::string;
  }
  return billid_;
}
inline ::std::string* GetBillInfoReply::release_billid() {
  clear_has_billid();
  if (billid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = billid_;
    billid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetBillInfoReply::set_allocated_billid(::std::string* billid) {
  if (billid_ != &::google::protobuf::internal::kEmptyString) {
    delete billid_;
  }
  if (billid) {
    set_has_billid();
    billid_ = billid;
  } else {
    clear_has_billid();
    billid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ChangePin

// optional string new_pin = 1;
inline bool ChangePin::has_new_pin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangePin::set_has_new_pin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangePin::clear_has_new_pin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangePin::clear_new_pin() {
  if (new_pin_ != &::google::protobuf::internal::kEmptyString) {
    new_pin_->clear();
  }
  clear_has_new_pin();
}
inline const ::std::string& ChangePin::new_pin() const {
  return *new_pin_;
}
inline void ChangePin::set_new_pin(const ::std::string& value) {
  set_has_new_pin();
  if (new_pin_ == &::google::protobuf::internal::kEmptyString) {
    new_pin_ = new ::std::string;
  }
  new_pin_->assign(value);
}
inline void ChangePin::set_new_pin(const char* value) {
  set_has_new_pin();
  if (new_pin_ == &::google::protobuf::internal::kEmptyString) {
    new_pin_ = new ::std::string;
  }
  new_pin_->assign(value);
}
inline void ChangePin::set_new_pin(const char* value, size_t size) {
  set_has_new_pin();
  if (new_pin_ == &::google::protobuf::internal::kEmptyString) {
    new_pin_ = new ::std::string;
  }
  new_pin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChangePin::mutable_new_pin() {
  set_has_new_pin();
  if (new_pin_ == &::google::protobuf::internal::kEmptyString) {
    new_pin_ = new ::std::string;
  }
  return new_pin_;
}
inline ::std::string* ChangePin::release_new_pin() {
  clear_has_new_pin();
  if (new_pin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = new_pin_;
    new_pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ChangePin::set_allocated_new_pin(::std::string* new_pin) {
  if (new_pin_ != &::google::protobuf::internal::kEmptyString) {
    delete new_pin_;
  }
  if (new_pin) {
    set_has_new_pin();
    new_pin_ = new_pin;
  } else {
    clear_has_new_pin();
    new_pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string old_pin = 2;
inline bool ChangePin::has_old_pin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChangePin::set_has_old_pin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChangePin::clear_has_old_pin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChangePin::clear_old_pin() {
  if (old_pin_ != &::google::protobuf::internal::kEmptyString) {
    old_pin_->clear();
  }
  clear_has_old_pin();
}
inline const ::std::string& ChangePin::old_pin() const {
  return *old_pin_;
}
inline void ChangePin::set_old_pin(const ::std::string& value) {
  set_has_old_pin();
  if (old_pin_ == &::google::protobuf::internal::kEmptyString) {
    old_pin_ = new ::std::string;
  }
  old_pin_->assign(value);
}
inline void ChangePin::set_old_pin(const char* value) {
  set_has_old_pin();
  if (old_pin_ == &::google::protobuf::internal::kEmptyString) {
    old_pin_ = new ::std::string;
  }
  old_pin_->assign(value);
}
inline void ChangePin::set_old_pin(const char* value, size_t size) {
  set_has_old_pin();
  if (old_pin_ == &::google::protobuf::internal::kEmptyString) {
    old_pin_ = new ::std::string;
  }
  old_pin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChangePin::mutable_old_pin() {
  set_has_old_pin();
  if (old_pin_ == &::google::protobuf::internal::kEmptyString) {
    old_pin_ = new ::std::string;
  }
  return old_pin_;
}
inline ::std::string* ChangePin::release_old_pin() {
  clear_has_old_pin();
  if (old_pin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = old_pin_;
    old_pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ChangePin::set_allocated_old_pin(::std::string* old_pin) {
  if (old_pin_ != &::google::protobuf::internal::kEmptyString) {
    delete old_pin_;
  }
  if (old_pin) {
    set_has_old_pin();
    old_pin_ = old_pin;
  } else {
    clear_has_old_pin();
    old_pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// WhoIsMomoer

// repeated uint32 numbers = 1;
inline int WhoIsMomoer::numbers_size() const {
  return numbers_.size();
}
inline void WhoIsMomoer::clear_numbers() {
  numbers_.Clear();
}
inline ::google::protobuf::uint32 WhoIsMomoer::numbers(int index) const {
  return numbers_.Get(index);
}
inline void WhoIsMomoer::set_numbers(int index, ::google::protobuf::uint32 value) {
  numbers_.Set(index, value);
}
inline void WhoIsMomoer::add_numbers(::google::protobuf::uint32 value) {
  numbers_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
WhoIsMomoer::numbers() const {
  return numbers_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
WhoIsMomoer::mutable_numbers() {
  return &numbers_;
}

// -------------------------------------------------------------------

// ViewPaymentHistoryByBillId

// optional string billId = 1;
inline bool ViewPaymentHistoryByBillId::has_billid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ViewPaymentHistoryByBillId::set_has_billid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ViewPaymentHistoryByBillId::clear_has_billid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ViewPaymentHistoryByBillId::clear_billid() {
  if (billid_ != &::google::protobuf::internal::kEmptyString) {
    billid_->clear();
  }
  clear_has_billid();
}
inline const ::std::string& ViewPaymentHistoryByBillId::billid() const {
  return *billid_;
}
inline void ViewPaymentHistoryByBillId::set_billid(const ::std::string& value) {
  set_has_billid();
  if (billid_ == &::google::protobuf::internal::kEmptyString) {
    billid_ = new ::std::string;
  }
  billid_->assign(value);
}
inline void ViewPaymentHistoryByBillId::set_billid(const char* value) {
  set_has_billid();
  if (billid_ == &::google::protobuf::internal::kEmptyString) {
    billid_ = new ::std::string;
  }
  billid_->assign(value);
}
inline void ViewPaymentHistoryByBillId::set_billid(const char* value, size_t size) {
  set_has_billid();
  if (billid_ == &::google::protobuf::internal::kEmptyString) {
    billid_ = new ::std::string;
  }
  billid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ViewPaymentHistoryByBillId::mutable_billid() {
  set_has_billid();
  if (billid_ == &::google::protobuf::internal::kEmptyString) {
    billid_ = new ::std::string;
  }
  return billid_;
}
inline ::std::string* ViewPaymentHistoryByBillId::release_billid() {
  clear_has_billid();
  if (billid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = billid_;
    billid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ViewPaymentHistoryByBillId::set_allocated_billid(::std::string* billid) {
  if (billid_ != &::google::protobuf::internal::kEmptyString) {
    delete billid_;
  }
  if (billid) {
    set_has_billid();
    billid_ = billid;
  } else {
    clear_has_billid();
    billid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ViewPaymentHistoryByBillIdReply

// optional bool result = 1;
inline bool ViewPaymentHistoryByBillIdReply::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ViewPaymentHistoryByBillIdReply::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ViewPaymentHistoryByBillIdReply::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ViewPaymentHistoryByBillIdReply::clear_result() {
  result_ = false;
  clear_has_result();
}
inline bool ViewPaymentHistoryByBillIdReply::result() const {
  return result_;
}
inline void ViewPaymentHistoryByBillIdReply::set_result(bool value) {
  set_has_result();
  result_ = value;
}

// optional string rcode = 2;
inline bool ViewPaymentHistoryByBillIdReply::has_rcode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ViewPaymentHistoryByBillIdReply::set_has_rcode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ViewPaymentHistoryByBillIdReply::clear_has_rcode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ViewPaymentHistoryByBillIdReply::clear_rcode() {
  if (rcode_ != &::google::protobuf::internal::kEmptyString) {
    rcode_->clear();
  }
  clear_has_rcode();
}
inline const ::std::string& ViewPaymentHistoryByBillIdReply::rcode() const {
  return *rcode_;
}
inline void ViewPaymentHistoryByBillIdReply::set_rcode(const ::std::string& value) {
  set_has_rcode();
  if (rcode_ == &::google::protobuf::internal::kEmptyString) {
    rcode_ = new ::std::string;
  }
  rcode_->assign(value);
}
inline void ViewPaymentHistoryByBillIdReply::set_rcode(const char* value) {
  set_has_rcode();
  if (rcode_ == &::google::protobuf::internal::kEmptyString) {
    rcode_ = new ::std::string;
  }
  rcode_->assign(value);
}
inline void ViewPaymentHistoryByBillIdReply::set_rcode(const char* value, size_t size) {
  set_has_rcode();
  if (rcode_ == &::google::protobuf::internal::kEmptyString) {
    rcode_ = new ::std::string;
  }
  rcode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ViewPaymentHistoryByBillIdReply::mutable_rcode() {
  set_has_rcode();
  if (rcode_ == &::google::protobuf::internal::kEmptyString) {
    rcode_ = new ::std::string;
  }
  return rcode_;
}
inline ::std::string* ViewPaymentHistoryByBillIdReply::release_rcode() {
  clear_has_rcode();
  if (rcode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rcode_;
    rcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ViewPaymentHistoryByBillIdReply::set_allocated_rcode(::std::string* rcode) {
  if (rcode_ != &::google::protobuf::internal::kEmptyString) {
    delete rcode_;
  }
  if (rcode) {
    set_has_rcode();
    rcode_ = rcode;
  } else {
    clear_has_rcode();
    rcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string payment_history = 3;
inline bool ViewPaymentHistoryByBillIdReply::has_payment_history() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ViewPaymentHistoryByBillIdReply::set_has_payment_history() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ViewPaymentHistoryByBillIdReply::clear_has_payment_history() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ViewPaymentHistoryByBillIdReply::clear_payment_history() {
  if (payment_history_ != &::google::protobuf::internal::kEmptyString) {
    payment_history_->clear();
  }
  clear_has_payment_history();
}
inline const ::std::string& ViewPaymentHistoryByBillIdReply::payment_history() const {
  return *payment_history_;
}
inline void ViewPaymentHistoryByBillIdReply::set_payment_history(const ::std::string& value) {
  set_has_payment_history();
  if (payment_history_ == &::google::protobuf::internal::kEmptyString) {
    payment_history_ = new ::std::string;
  }
  payment_history_->assign(value);
}
inline void ViewPaymentHistoryByBillIdReply::set_payment_history(const char* value) {
  set_has_payment_history();
  if (payment_history_ == &::google::protobuf::internal::kEmptyString) {
    payment_history_ = new ::std::string;
  }
  payment_history_->assign(value);
}
inline void ViewPaymentHistoryByBillIdReply::set_payment_history(const char* value, size_t size) {
  set_has_payment_history();
  if (payment_history_ == &::google::protobuf::internal::kEmptyString) {
    payment_history_ = new ::std::string;
  }
  payment_history_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ViewPaymentHistoryByBillIdReply::mutable_payment_history() {
  set_has_payment_history();
  if (payment_history_ == &::google::protobuf::internal::kEmptyString) {
    payment_history_ = new ::std::string;
  }
  return payment_history_;
}
inline ::std::string* ViewPaymentHistoryByBillIdReply::release_payment_history() {
  clear_has_payment_history();
  if (payment_history_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = payment_history_;
    payment_history_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ViewPaymentHistoryByBillIdReply::set_allocated_payment_history(::std::string* payment_history) {
  if (payment_history_ != &::google::protobuf::internal::kEmptyString) {
    delete payment_history_;
  }
  if (payment_history) {
    set_has_payment_history();
    payment_history_ = payment_history;
  } else {
    clear_has_payment_history();
    payment_history_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// DeviceInfo

// optional string deviceName = 1;
inline bool DeviceInfo::has_devicename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceInfo::set_has_devicename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeviceInfo::clear_has_devicename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceInfo::clear_devicename() {
  if (devicename_ != &::google::protobuf::internal::kEmptyString) {
    devicename_->clear();
  }
  clear_has_devicename();
}
inline const ::std::string& DeviceInfo::devicename() const {
  return *devicename_;
}
inline void DeviceInfo::set_devicename(const ::std::string& value) {
  set_has_devicename();
  if (devicename_ == &::google::protobuf::internal::kEmptyString) {
    devicename_ = new ::std::string;
  }
  devicename_->assign(value);
}
inline void DeviceInfo::set_devicename(const char* value) {
  set_has_devicename();
  if (devicename_ == &::google::protobuf::internal::kEmptyString) {
    devicename_ = new ::std::string;
  }
  devicename_->assign(value);
}
inline void DeviceInfo::set_devicename(const char* value, size_t size) {
  set_has_devicename();
  if (devicename_ == &::google::protobuf::internal::kEmptyString) {
    devicename_ = new ::std::string;
  }
  devicename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceInfo::mutable_devicename() {
  set_has_devicename();
  if (devicename_ == &::google::protobuf::internal::kEmptyString) {
    devicename_ = new ::std::string;
  }
  return devicename_;
}
inline ::std::string* DeviceInfo::release_devicename() {
  clear_has_devicename();
  if (devicename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = devicename_;
    devicename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DeviceInfo::set_allocated_devicename(::std::string* devicename) {
  if (devicename_ != &::google::protobuf::internal::kEmptyString) {
    delete devicename_;
  }
  if (devicename) {
    set_has_devicename();
    devicename_ = devicename;
  } else {
    clear_has_devicename();
    devicename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string deviceVersion = 2;
inline bool DeviceInfo::has_deviceversion() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceInfo::set_has_deviceversion() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeviceInfo::clear_has_deviceversion() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceInfo::clear_deviceversion() {
  if (deviceversion_ != &::google::protobuf::internal::kEmptyString) {
    deviceversion_->clear();
  }
  clear_has_deviceversion();
}
inline const ::std::string& DeviceInfo::deviceversion() const {
  return *deviceversion_;
}
inline void DeviceInfo::set_deviceversion(const ::std::string& value) {
  set_has_deviceversion();
  if (deviceversion_ == &::google::protobuf::internal::kEmptyString) {
    deviceversion_ = new ::std::string;
  }
  deviceversion_->assign(value);
}
inline void DeviceInfo::set_deviceversion(const char* value) {
  set_has_deviceversion();
  if (deviceversion_ == &::google::protobuf::internal::kEmptyString) {
    deviceversion_ = new ::std::string;
  }
  deviceversion_->assign(value);
}
inline void DeviceInfo::set_deviceversion(const char* value, size_t size) {
  set_has_deviceversion();
  if (deviceversion_ == &::google::protobuf::internal::kEmptyString) {
    deviceversion_ = new ::std::string;
  }
  deviceversion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceInfo::mutable_deviceversion() {
  set_has_deviceversion();
  if (deviceversion_ == &::google::protobuf::internal::kEmptyString) {
    deviceversion_ = new ::std::string;
  }
  return deviceversion_;
}
inline ::std::string* DeviceInfo::release_deviceversion() {
  clear_has_deviceversion();
  if (deviceversion_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deviceversion_;
    deviceversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DeviceInfo::set_allocated_deviceversion(::std::string* deviceversion) {
  if (deviceversion_ != &::google::protobuf::internal::kEmptyString) {
    delete deviceversion_;
  }
  if (deviceversion) {
    set_has_deviceversion();
    deviceversion_ = deviceversion;
  } else {
    clear_has_deviceversion();
    deviceversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string deviceModel = 3;
inline bool DeviceInfo::has_devicemodel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeviceInfo::set_has_devicemodel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeviceInfo::clear_has_devicemodel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeviceInfo::clear_devicemodel() {
  if (devicemodel_ != &::google::protobuf::internal::kEmptyString) {
    devicemodel_->clear();
  }
  clear_has_devicemodel();
}
inline const ::std::string& DeviceInfo::devicemodel() const {
  return *devicemodel_;
}
inline void DeviceInfo::set_devicemodel(const ::std::string& value) {
  set_has_devicemodel();
  if (devicemodel_ == &::google::protobuf::internal::kEmptyString) {
    devicemodel_ = new ::std::string;
  }
  devicemodel_->assign(value);
}
inline void DeviceInfo::set_devicemodel(const char* value) {
  set_has_devicemodel();
  if (devicemodel_ == &::google::protobuf::internal::kEmptyString) {
    devicemodel_ = new ::std::string;
  }
  devicemodel_->assign(value);
}
inline void DeviceInfo::set_devicemodel(const char* value, size_t size) {
  set_has_devicemodel();
  if (devicemodel_ == &::google::protobuf::internal::kEmptyString) {
    devicemodel_ = new ::std::string;
  }
  devicemodel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceInfo::mutable_devicemodel() {
  set_has_devicemodel();
  if (devicemodel_ == &::google::protobuf::internal::kEmptyString) {
    devicemodel_ = new ::std::string;
  }
  return devicemodel_;
}
inline ::std::string* DeviceInfo::release_devicemodel() {
  clear_has_devicemodel();
  if (devicemodel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = devicemodel_;
    devicemodel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DeviceInfo::set_allocated_devicemodel(::std::string* devicemodel) {
  if (devicemodel_ != &::google::protobuf::internal::kEmptyString) {
    delete devicemodel_;
  }
  if (devicemodel) {
    set_has_devicemodel();
    devicemodel_ = devicemodel;
  } else {
    clear_has_devicemodel();
    devicemodel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string deviceManufacturer = 4;
inline bool DeviceInfo::has_devicemanufacturer() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DeviceInfo::set_has_devicemanufacturer() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DeviceInfo::clear_has_devicemanufacturer() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DeviceInfo::clear_devicemanufacturer() {
  if (devicemanufacturer_ != &::google::protobuf::internal::kEmptyString) {
    devicemanufacturer_->clear();
  }
  clear_has_devicemanufacturer();
}
inline const ::std::string& DeviceInfo::devicemanufacturer() const {
  return *devicemanufacturer_;
}
inline void DeviceInfo::set_devicemanufacturer(const ::std::string& value) {
  set_has_devicemanufacturer();
  if (devicemanufacturer_ == &::google::protobuf::internal::kEmptyString) {
    devicemanufacturer_ = new ::std::string;
  }
  devicemanufacturer_->assign(value);
}
inline void DeviceInfo::set_devicemanufacturer(const char* value) {
  set_has_devicemanufacturer();
  if (devicemanufacturer_ == &::google::protobuf::internal::kEmptyString) {
    devicemanufacturer_ = new ::std::string;
  }
  devicemanufacturer_->assign(value);
}
inline void DeviceInfo::set_devicemanufacturer(const char* value, size_t size) {
  set_has_devicemanufacturer();
  if (devicemanufacturer_ == &::google::protobuf::internal::kEmptyString) {
    devicemanufacturer_ = new ::std::string;
  }
  devicemanufacturer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceInfo::mutable_devicemanufacturer() {
  set_has_devicemanufacturer();
  if (devicemanufacturer_ == &::google::protobuf::internal::kEmptyString) {
    devicemanufacturer_ = new ::std::string;
  }
  return devicemanufacturer_;
}
inline ::std::string* DeviceInfo::release_devicemanufacturer() {
  clear_has_devicemanufacturer();
  if (devicemanufacturer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = devicemanufacturer_;
    devicemanufacturer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DeviceInfo::set_allocated_devicemanufacturer(::std::string* devicemanufacturer) {
  if (devicemanufacturer_ != &::google::protobuf::internal::kEmptyString) {
    delete devicemanufacturer_;
  }
  if (devicemanufacturer) {
    set_has_devicemanufacturer();
    devicemanufacturer_ = devicemanufacturer;
  } else {
    clear_has_devicemanufacturer();
    devicemanufacturer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string appVersion = 5;
inline bool DeviceInfo::has_appversion() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DeviceInfo::set_has_appversion() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DeviceInfo::clear_has_appversion() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DeviceInfo::clear_appversion() {
  if (appversion_ != &::google::protobuf::internal::kEmptyString) {
    appversion_->clear();
  }
  clear_has_appversion();
}
inline const ::std::string& DeviceInfo::appversion() const {
  return *appversion_;
}
inline void DeviceInfo::set_appversion(const ::std::string& value) {
  set_has_appversion();
  if (appversion_ == &::google::protobuf::internal::kEmptyString) {
    appversion_ = new ::std::string;
  }
  appversion_->assign(value);
}
inline void DeviceInfo::set_appversion(const char* value) {
  set_has_appversion();
  if (appversion_ == &::google::protobuf::internal::kEmptyString) {
    appversion_ = new ::std::string;
  }
  appversion_->assign(value);
}
inline void DeviceInfo::set_appversion(const char* value, size_t size) {
  set_has_appversion();
  if (appversion_ == &::google::protobuf::internal::kEmptyString) {
    appversion_ = new ::std::string;
  }
  appversion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceInfo::mutable_appversion() {
  set_has_appversion();
  if (appversion_ == &::google::protobuf::internal::kEmptyString) {
    appversion_ = new ::std::string;
  }
  return appversion_;
}
inline ::std::string* DeviceInfo::release_appversion() {
  clear_has_appversion();
  if (appversion_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = appversion_;
    appversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DeviceInfo::set_allocated_appversion(::std::string* appversion) {
  if (appversion_ != &::google::protobuf::internal::kEmptyString) {
    delete appversion_;
  }
  if (appversion) {
    set_has_appversion();
    appversion_ = appversion;
  } else {
    clear_has_appversion();
    appversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string deviceSWidth = 6;
inline bool DeviceInfo::has_deviceswidth() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DeviceInfo::set_has_deviceswidth() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DeviceInfo::clear_has_deviceswidth() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DeviceInfo::clear_deviceswidth() {
  if (deviceswidth_ != &::google::protobuf::internal::kEmptyString) {
    deviceswidth_->clear();
  }
  clear_has_deviceswidth();
}
inline const ::std::string& DeviceInfo::deviceswidth() const {
  return *deviceswidth_;
}
inline void DeviceInfo::set_deviceswidth(const ::std::string& value) {
  set_has_deviceswidth();
  if (deviceswidth_ == &::google::protobuf::internal::kEmptyString) {
    deviceswidth_ = new ::std::string;
  }
  deviceswidth_->assign(value);
}
inline void DeviceInfo::set_deviceswidth(const char* value) {
  set_has_deviceswidth();
  if (deviceswidth_ == &::google::protobuf::internal::kEmptyString) {
    deviceswidth_ = new ::std::string;
  }
  deviceswidth_->assign(value);
}
inline void DeviceInfo::set_deviceswidth(const char* value, size_t size) {
  set_has_deviceswidth();
  if (deviceswidth_ == &::google::protobuf::internal::kEmptyString) {
    deviceswidth_ = new ::std::string;
  }
  deviceswidth_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceInfo::mutable_deviceswidth() {
  set_has_deviceswidth();
  if (deviceswidth_ == &::google::protobuf::internal::kEmptyString) {
    deviceswidth_ = new ::std::string;
  }
  return deviceswidth_;
}
inline ::std::string* DeviceInfo::release_deviceswidth() {
  clear_has_deviceswidth();
  if (deviceswidth_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deviceswidth_;
    deviceswidth_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DeviceInfo::set_allocated_deviceswidth(::std::string* deviceswidth) {
  if (deviceswidth_ != &::google::protobuf::internal::kEmptyString) {
    delete deviceswidth_;
  }
  if (deviceswidth) {
    set_has_deviceswidth();
    deviceswidth_ = deviceswidth;
  } else {
    clear_has_deviceswidth();
    deviceswidth_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string deviceSHeight = 7;
inline bool DeviceInfo::has_devicesheight() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DeviceInfo::set_has_devicesheight() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DeviceInfo::clear_has_devicesheight() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DeviceInfo::clear_devicesheight() {
  if (devicesheight_ != &::google::protobuf::internal::kEmptyString) {
    devicesheight_->clear();
  }
  clear_has_devicesheight();
}
inline const ::std::string& DeviceInfo::devicesheight() const {
  return *devicesheight_;
}
inline void DeviceInfo::set_devicesheight(const ::std::string& value) {
  set_has_devicesheight();
  if (devicesheight_ == &::google::protobuf::internal::kEmptyString) {
    devicesheight_ = new ::std::string;
  }
  devicesheight_->assign(value);
}
inline void DeviceInfo::set_devicesheight(const char* value) {
  set_has_devicesheight();
  if (devicesheight_ == &::google::protobuf::internal::kEmptyString) {
    devicesheight_ = new ::std::string;
  }
  devicesheight_->assign(value);
}
inline void DeviceInfo::set_devicesheight(const char* value, size_t size) {
  set_has_devicesheight();
  if (devicesheight_ == &::google::protobuf::internal::kEmptyString) {
    devicesheight_ = new ::std::string;
  }
  devicesheight_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceInfo::mutable_devicesheight() {
  set_has_devicesheight();
  if (devicesheight_ == &::google::protobuf::internal::kEmptyString) {
    devicesheight_ = new ::std::string;
  }
  return devicesheight_;
}
inline ::std::string* DeviceInfo::release_devicesheight() {
  clear_has_devicesheight();
  if (devicesheight_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = devicesheight_;
    devicesheight_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DeviceInfo::set_allocated_devicesheight(::std::string* devicesheight) {
  if (devicesheight_ != &::google::protobuf::internal::kEmptyString) {
    delete devicesheight_;
  }
  if (devicesheight) {
    set_has_devicesheight();
    devicesheight_ = devicesheight;
  } else {
    clear_has_devicesheight();
    devicesheight_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string devicePrimaryEmail = 8;
inline bool DeviceInfo::has_deviceprimaryemail() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DeviceInfo::set_has_deviceprimaryemail() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DeviceInfo::clear_has_deviceprimaryemail() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DeviceInfo::clear_deviceprimaryemail() {
  if (deviceprimaryemail_ != &::google::protobuf::internal::kEmptyString) {
    deviceprimaryemail_->clear();
  }
  clear_has_deviceprimaryemail();
}
inline const ::std::string& DeviceInfo::deviceprimaryemail() const {
  return *deviceprimaryemail_;
}
inline void DeviceInfo::set_deviceprimaryemail(const ::std::string& value) {
  set_has_deviceprimaryemail();
  if (deviceprimaryemail_ == &::google::protobuf::internal::kEmptyString) {
    deviceprimaryemail_ = new ::std::string;
  }
  deviceprimaryemail_->assign(value);
}
inline void DeviceInfo::set_deviceprimaryemail(const char* value) {
  set_has_deviceprimaryemail();
  if (deviceprimaryemail_ == &::google::protobuf::internal::kEmptyString) {
    deviceprimaryemail_ = new ::std::string;
  }
  deviceprimaryemail_->assign(value);
}
inline void DeviceInfo::set_deviceprimaryemail(const char* value, size_t size) {
  set_has_deviceprimaryemail();
  if (deviceprimaryemail_ == &::google::protobuf::internal::kEmptyString) {
    deviceprimaryemail_ = new ::std::string;
  }
  deviceprimaryemail_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceInfo::mutable_deviceprimaryemail() {
  set_has_deviceprimaryemail();
  if (deviceprimaryemail_ == &::google::protobuf::internal::kEmptyString) {
    deviceprimaryemail_ = new ::std::string;
  }
  return deviceprimaryemail_;
}
inline ::std::string* DeviceInfo::release_deviceprimaryemail() {
  clear_has_deviceprimaryemail();
  if (deviceprimaryemail_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deviceprimaryemail_;
    deviceprimaryemail_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DeviceInfo::set_allocated_deviceprimaryemail(::std::string* deviceprimaryemail) {
  if (deviceprimaryemail_ != &::google::protobuf::internal::kEmptyString) {
    delete deviceprimaryemail_;
  }
  if (deviceprimaryemail) {
    set_has_deviceprimaryemail();
    deviceprimaryemail_ = deviceprimaryemail;
  } else {
    clear_has_deviceprimaryemail();
    deviceprimaryemail_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string os = 9;
inline bool DeviceInfo::has_os() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DeviceInfo::set_has_os() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DeviceInfo::clear_has_os() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DeviceInfo::clear_os() {
  if (os_ != &::google::protobuf::internal::kEmptyString) {
    os_->clear();
  }
  clear_has_os();
}
inline const ::std::string& DeviceInfo::os() const {
  return *os_;
}
inline void DeviceInfo::set_os(const ::std::string& value) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  os_->assign(value);
}
inline void DeviceInfo::set_os(const char* value) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  os_->assign(value);
}
inline void DeviceInfo::set_os(const char* value, size_t size) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  os_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceInfo::mutable_os() {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  return os_;
}
inline ::std::string* DeviceInfo::release_os() {
  clear_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = os_;
    os_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DeviceInfo::set_allocated_os(::std::string* os) {
  if (os_ != &::google::protobuf::internal::kEmptyString) {
    delete os_;
  }
  if (os) {
    set_has_os();
    os_ = os;
  } else {
    clear_has_os();
    os_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string token = 10;
inline bool DeviceInfo::has_token() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DeviceInfo::set_has_token() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DeviceInfo::clear_has_token() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DeviceInfo::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& DeviceInfo::token() const {
  return *token_;
}
inline void DeviceInfo::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void DeviceInfo::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void DeviceInfo::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceInfo::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* DeviceInfo::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DeviceInfo::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GetAccessHistory

// optional uint32 page_num = 1;
inline bool GetAccessHistory::has_page_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetAccessHistory::set_has_page_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetAccessHistory::clear_has_page_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetAccessHistory::clear_page_num() {
  page_num_ = 0u;
  clear_has_page_num();
}
inline ::google::protobuf::uint32 GetAccessHistory::page_num() const {
  return page_num_;
}
inline void GetAccessHistory::set_page_num(::google::protobuf::uint32 value) {
  set_has_page_num();
  page_num_ = value;
}

// optional uint32 page_size = 2;
inline bool GetAccessHistory::has_page_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetAccessHistory::set_has_page_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetAccessHistory::clear_has_page_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetAccessHistory::clear_page_size() {
  page_size_ = 0u;
  clear_has_page_size();
}
inline ::google::protobuf::uint32 GetAccessHistory::page_size() const {
  return page_size_;
}
inline void GetAccessHistory::set_page_size(::google::protobuf::uint32 value) {
  set_has_page_size();
  page_size_ = value;
}

// -------------------------------------------------------------------

// AccessHistoryDetail

// optional string ip = 1;
inline bool AccessHistoryDetail::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccessHistoryDetail::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccessHistoryDetail::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccessHistoryDetail::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& AccessHistoryDetail::ip() const {
  return *ip_;
}
inline void AccessHistoryDetail::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void AccessHistoryDetail::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void AccessHistoryDetail::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccessHistoryDetail::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* AccessHistoryDetail::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccessHistoryDetail::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 time_in = 2;
inline bool AccessHistoryDetail::has_time_in() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccessHistoryDetail::set_has_time_in() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccessHistoryDetail::clear_has_time_in() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccessHistoryDetail::clear_time_in() {
  time_in_ = GOOGLE_ULONGLONG(0);
  clear_has_time_in();
}
inline ::google::protobuf::uint64 AccessHistoryDetail::time_in() const {
  return time_in_;
}
inline void AccessHistoryDetail::set_time_in(::google::protobuf::uint64 value) {
  set_has_time_in();
  time_in_ = value;
}

// optional uint64 time_out = 3;
inline bool AccessHistoryDetail::has_time_out() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AccessHistoryDetail::set_has_time_out() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AccessHistoryDetail::clear_has_time_out() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AccessHistoryDetail::clear_time_out() {
  time_out_ = GOOGLE_ULONGLONG(0);
  clear_has_time_out();
}
inline ::google::protobuf::uint64 AccessHistoryDetail::time_out() const {
  return time_out_;
}
inline void AccessHistoryDetail::set_time_out(::google::protobuf::uint64 value) {
  set_has_time_out();
  time_out_ = value;
}

// optional string device_model = 4;
inline bool AccessHistoryDetail::has_device_model() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AccessHistoryDetail::set_has_device_model() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AccessHistoryDetail::clear_has_device_model() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AccessHistoryDetail::clear_device_model() {
  if (device_model_ != &::google::protobuf::internal::kEmptyString) {
    device_model_->clear();
  }
  clear_has_device_model();
}
inline const ::std::string& AccessHistoryDetail::device_model() const {
  return *device_model_;
}
inline void AccessHistoryDetail::set_device_model(const ::std::string& value) {
  set_has_device_model();
  if (device_model_ == &::google::protobuf::internal::kEmptyString) {
    device_model_ = new ::std::string;
  }
  device_model_->assign(value);
}
inline void AccessHistoryDetail::set_device_model(const char* value) {
  set_has_device_model();
  if (device_model_ == &::google::protobuf::internal::kEmptyString) {
    device_model_ = new ::std::string;
  }
  device_model_->assign(value);
}
inline void AccessHistoryDetail::set_device_model(const char* value, size_t size) {
  set_has_device_model();
  if (device_model_ == &::google::protobuf::internal::kEmptyString) {
    device_model_ = new ::std::string;
  }
  device_model_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccessHistoryDetail::mutable_device_model() {
  set_has_device_model();
  if (device_model_ == &::google::protobuf::internal::kEmptyString) {
    device_model_ = new ::std::string;
  }
  return device_model_;
}
inline ::std::string* AccessHistoryDetail::release_device_model() {
  clear_has_device_model();
  if (device_model_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_model_;
    device_model_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccessHistoryDetail::set_allocated_device_model(::std::string* device_model) {
  if (device_model_ != &::google::protobuf::internal::kEmptyString) {
    delete device_model_;
  }
  if (device_model) {
    set_has_device_model();
    device_model_ = device_model;
  } else {
    clear_has_device_model();
    device_model_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GetAccessHistoryReply

// optional bool result = 1;
inline bool GetAccessHistoryReply::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetAccessHistoryReply::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetAccessHistoryReply::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetAccessHistoryReply::clear_result() {
  result_ = false;
  clear_has_result();
}
inline bool GetAccessHistoryReply::result() const {
  return result_;
}
inline void GetAccessHistoryReply::set_result(bool value) {
  set_has_result();
  result_ = value;
}

// repeated .com.mservice.momo.msg.AccessHistoryDetail access_detail = 2;
inline int GetAccessHistoryReply::access_detail_size() const {
  return access_detail_.size();
}
inline void GetAccessHistoryReply::clear_access_detail() {
  access_detail_.Clear();
}
inline const ::com::mservice::momo::msg::AccessHistoryDetail& GetAccessHistoryReply::access_detail(int index) const {
  return access_detail_.Get(index);
}
inline ::com::mservice::momo::msg::AccessHistoryDetail* GetAccessHistoryReply::mutable_access_detail(int index) {
  return access_detail_.Mutable(index);
}
inline ::com::mservice::momo::msg::AccessHistoryDetail* GetAccessHistoryReply::add_access_detail() {
  return access_detail_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::AccessHistoryDetail >&
GetAccessHistoryReply::access_detail() const {
  return access_detail_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::AccessHistoryDetail >*
GetAccessHistoryReply::mutable_access_detail() {
  return &access_detail_;
}

// -------------------------------------------------------------------

// StoreInfo

// optional string owner = 1;
inline bool StoreInfo::has_owner() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StoreInfo::set_has_owner() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StoreInfo::clear_has_owner() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StoreInfo::clear_owner() {
  if (owner_ != &::google::protobuf::internal::kEmptyString) {
    owner_->clear();
  }
  clear_has_owner();
}
inline const ::std::string& StoreInfo::owner() const {
  return *owner_;
}
inline void StoreInfo::set_owner(const ::std::string& value) {
  set_has_owner();
  if (owner_ == &::google::protobuf::internal::kEmptyString) {
    owner_ = new ::std::string;
  }
  owner_->assign(value);
}
inline void StoreInfo::set_owner(const char* value) {
  set_has_owner();
  if (owner_ == &::google::protobuf::internal::kEmptyString) {
    owner_ = new ::std::string;
  }
  owner_->assign(value);
}
inline void StoreInfo::set_owner(const char* value, size_t size) {
  set_has_owner();
  if (owner_ == &::google::protobuf::internal::kEmptyString) {
    owner_ = new ::std::string;
  }
  owner_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreInfo::mutable_owner() {
  set_has_owner();
  if (owner_ == &::google::protobuf::internal::kEmptyString) {
    owner_ = new ::std::string;
  }
  return owner_;
}
inline ::std::string* StoreInfo::release_owner() {
  clear_has_owner();
  if (owner_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = owner_;
    owner_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StoreInfo::set_allocated_owner(::std::string* owner) {
  if (owner_ != &::google::protobuf::internal::kEmptyString) {
    delete owner_;
  }
  if (owner) {
    set_has_owner();
    owner_ = owner;
  } else {
    clear_has_owner();
    owner_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string phone = 2;
inline bool StoreInfo::has_phone() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StoreInfo::set_has_phone() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StoreInfo::clear_has_phone() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StoreInfo::clear_phone() {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    phone_->clear();
  }
  clear_has_phone();
}
inline const ::std::string& StoreInfo::phone() const {
  return *phone_;
}
inline void StoreInfo::set_phone(const ::std::string& value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void StoreInfo::set_phone(const char* value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void StoreInfo::set_phone(const char* value, size_t size) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreInfo::mutable_phone() {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  return phone_;
}
inline ::std::string* StoreInfo::release_phone() {
  clear_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phone_;
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StoreInfo::set_allocated_phone(::std::string* phone) {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    delete phone_;
  }
  if (phone) {
    set_has_phone();
    phone_ = phone;
  } else {
    clear_has_phone();
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 3;
inline bool StoreInfo::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StoreInfo::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StoreInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StoreInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& StoreInfo::name() const {
  return *name_;
}
inline void StoreInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void StoreInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void StoreInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* StoreInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StoreInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string add = 4;
inline bool StoreInfo::has_add() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StoreInfo::set_has_add() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StoreInfo::clear_has_add() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StoreInfo::clear_add() {
  if (add_ != &::google::protobuf::internal::kEmptyString) {
    add_->clear();
  }
  clear_has_add();
}
inline const ::std::string& StoreInfo::add() const {
  return *add_;
}
inline void StoreInfo::set_add(const ::std::string& value) {
  set_has_add();
  if (add_ == &::google::protobuf::internal::kEmptyString) {
    add_ = new ::std::string;
  }
  add_->assign(value);
}
inline void StoreInfo::set_add(const char* value) {
  set_has_add();
  if (add_ == &::google::protobuf::internal::kEmptyString) {
    add_ = new ::std::string;
  }
  add_->assign(value);
}
inline void StoreInfo::set_add(const char* value, size_t size) {
  set_has_add();
  if (add_ == &::google::protobuf::internal::kEmptyString) {
    add_ = new ::std::string;
  }
  add_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreInfo::mutable_add() {
  set_has_add();
  if (add_ == &::google::protobuf::internal::kEmptyString) {
    add_ = new ::std::string;
  }
  return add_;
}
inline ::std::string* StoreInfo::release_add() {
  clear_has_add();
  if (add_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = add_;
    add_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StoreInfo::set_allocated_add(::std::string* add) {
  if (add_ != &::google::protobuf::internal::kEmptyString) {
    delete add_;
  }
  if (add) {
    set_has_add();
    add_ = add;
  } else {
    clear_has_add();
    add_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string street = 5;
inline bool StoreInfo::has_street() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StoreInfo::set_has_street() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StoreInfo::clear_has_street() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StoreInfo::clear_street() {
  if (street_ != &::google::protobuf::internal::kEmptyString) {
    street_->clear();
  }
  clear_has_street();
}
inline const ::std::string& StoreInfo::street() const {
  return *street_;
}
inline void StoreInfo::set_street(const ::std::string& value) {
  set_has_street();
  if (street_ == &::google::protobuf::internal::kEmptyString) {
    street_ = new ::std::string;
  }
  street_->assign(value);
}
inline void StoreInfo::set_street(const char* value) {
  set_has_street();
  if (street_ == &::google::protobuf::internal::kEmptyString) {
    street_ = new ::std::string;
  }
  street_->assign(value);
}
inline void StoreInfo::set_street(const char* value, size_t size) {
  set_has_street();
  if (street_ == &::google::protobuf::internal::kEmptyString) {
    street_ = new ::std::string;
  }
  street_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreInfo::mutable_street() {
  set_has_street();
  if (street_ == &::google::protobuf::internal::kEmptyString) {
    street_ = new ::std::string;
  }
  return street_;
}
inline ::std::string* StoreInfo::release_street() {
  clear_has_street();
  if (street_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = street_;
    street_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StoreInfo::set_allocated_street(::std::string* street) {
  if (street_ != &::google::protobuf::internal::kEmptyString) {
    delete street_;
  }
  if (street) {
    set_has_street();
    street_ = street;
  } else {
    clear_has_street();
    street_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ward = 6;
inline bool StoreInfo::has_ward() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void StoreInfo::set_has_ward() {
  _has_bits_[0] |= 0x00000020u;
}
inline void StoreInfo::clear_has_ward() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void StoreInfo::clear_ward() {
  if (ward_ != &::google::protobuf::internal::kEmptyString) {
    ward_->clear();
  }
  clear_has_ward();
}
inline const ::std::string& StoreInfo::ward() const {
  return *ward_;
}
inline void StoreInfo::set_ward(const ::std::string& value) {
  set_has_ward();
  if (ward_ == &::google::protobuf::internal::kEmptyString) {
    ward_ = new ::std::string;
  }
  ward_->assign(value);
}
inline void StoreInfo::set_ward(const char* value) {
  set_has_ward();
  if (ward_ == &::google::protobuf::internal::kEmptyString) {
    ward_ = new ::std::string;
  }
  ward_->assign(value);
}
inline void StoreInfo::set_ward(const char* value, size_t size) {
  set_has_ward();
  if (ward_ == &::google::protobuf::internal::kEmptyString) {
    ward_ = new ::std::string;
  }
  ward_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreInfo::mutable_ward() {
  set_has_ward();
  if (ward_ == &::google::protobuf::internal::kEmptyString) {
    ward_ = new ::std::string;
  }
  return ward_;
}
inline ::std::string* StoreInfo::release_ward() {
  clear_has_ward();
  if (ward_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ward_;
    ward_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StoreInfo::set_allocated_ward(::std::string* ward) {
  if (ward_ != &::google::protobuf::internal::kEmptyString) {
    delete ward_;
  }
  if (ward) {
    set_has_ward();
    ward_ = ward;
  } else {
    clear_has_ward();
    ward_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 did = 7;
inline bool StoreInfo::has_did() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void StoreInfo::set_has_did() {
  _has_bits_[0] |= 0x00000040u;
}
inline void StoreInfo::clear_has_did() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void StoreInfo::clear_did() {
  did_ = 0u;
  clear_has_did();
}
inline ::google::protobuf::uint32 StoreInfo::did() const {
  return did_;
}
inline void StoreInfo::set_did(::google::protobuf::uint32 value) {
  set_has_did();
  did_ = value;
}

// optional uint32 cid = 8;
inline bool StoreInfo::has_cid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void StoreInfo::set_has_cid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void StoreInfo::clear_has_cid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void StoreInfo::clear_cid() {
  cid_ = 0u;
  clear_has_cid();
}
inline ::google::protobuf::uint32 StoreInfo::cid() const {
  return cid_;
}
inline void StoreInfo::set_cid(::google::protobuf::uint32 value) {
  set_has_cid();
  cid_ = value;
}

// optional uint32 aid = 9;
inline bool StoreInfo::has_aid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void StoreInfo::set_has_aid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void StoreInfo::clear_has_aid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void StoreInfo::clear_aid() {
  aid_ = 0u;
  clear_has_aid();
}
inline ::google::protobuf::uint32 StoreInfo::aid() const {
  return aid_;
}
inline void StoreInfo::set_aid(::google::protobuf::uint32 value) {
  set_has_aid();
  aid_ = value;
}

// optional uint64 last_update_time = 10;
inline bool StoreInfo::has_last_update_time() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void StoreInfo::set_has_last_update_time() {
  _has_bits_[0] |= 0x00000200u;
}
inline void StoreInfo::clear_has_last_update_time() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void StoreInfo::clear_last_update_time() {
  last_update_time_ = GOOGLE_ULONGLONG(0);
  clear_has_last_update_time();
}
inline ::google::protobuf::uint64 StoreInfo::last_update_time() const {
  return last_update_time_;
}
inline void StoreInfo::set_last_update_time(::google::protobuf::uint64 value) {
  set_has_last_update_time();
  last_update_time_ = value;
}

// optional bool deleted = 11;
inline bool StoreInfo::has_deleted() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void StoreInfo::set_has_deleted() {
  _has_bits_[0] |= 0x00000400u;
}
inline void StoreInfo::clear_has_deleted() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void StoreInfo::clear_deleted() {
  deleted_ = false;
  clear_has_deleted();
}
inline bool StoreInfo::deleted() const {
  return deleted_;
}
inline void StoreInfo::set_deleted(bool value) {
  set_has_deleted();
  deleted_ = value;
}

// optional uint32 rowCoreId = 12;
inline bool StoreInfo::has_rowcoreid() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void StoreInfo::set_has_rowcoreid() {
  _has_bits_[0] |= 0x00000800u;
}
inline void StoreInfo::clear_has_rowcoreid() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void StoreInfo::clear_rowcoreid() {
  rowcoreid_ = 0u;
  clear_has_rowcoreid();
}
inline ::google::protobuf::uint32 StoreInfo::rowcoreid() const {
  return rowcoreid_;
}
inline void StoreInfo::set_rowcoreid(::google::protobuf::uint32 value) {
  set_has_rowcoreid();
  rowcoreid_ = value;
}

// optional double lng = 13;
inline bool StoreInfo::has_lng() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void StoreInfo::set_has_lng() {
  _has_bits_[0] |= 0x00001000u;
}
inline void StoreInfo::clear_has_lng() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void StoreInfo::clear_lng() {
  lng_ = 0;
  clear_has_lng();
}
inline double StoreInfo::lng() const {
  return lng_;
}
inline void StoreInfo::set_lng(double value) {
  set_has_lng();
  lng_ = value;
}

// optional double lat = 14;
inline bool StoreInfo::has_lat() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void StoreInfo::set_has_lat() {
  _has_bits_[0] |= 0x00002000u;
}
inline void StoreInfo::clear_has_lat() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void StoreInfo::clear_lat() {
  lat_ = 0;
  clear_has_lat();
}
inline double StoreInfo::lat() const {
  return lat_;
}
inline void StoreInfo::set_lat(double value) {
  set_has_lat();
  lat_ = value;
}

// optional string momo_number = 15;
inline bool StoreInfo::has_momo_number() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void StoreInfo::set_has_momo_number() {
  _has_bits_[0] |= 0x00004000u;
}
inline void StoreInfo::clear_has_momo_number() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void StoreInfo::clear_momo_number() {
  if (momo_number_ != &::google::protobuf::internal::kEmptyString) {
    momo_number_->clear();
  }
  clear_has_momo_number();
}
inline const ::std::string& StoreInfo::momo_number() const {
  return *momo_number_;
}
inline void StoreInfo::set_momo_number(const ::std::string& value) {
  set_has_momo_number();
  if (momo_number_ == &::google::protobuf::internal::kEmptyString) {
    momo_number_ = new ::std::string;
  }
  momo_number_->assign(value);
}
inline void StoreInfo::set_momo_number(const char* value) {
  set_has_momo_number();
  if (momo_number_ == &::google::protobuf::internal::kEmptyString) {
    momo_number_ = new ::std::string;
  }
  momo_number_->assign(value);
}
inline void StoreInfo::set_momo_number(const char* value, size_t size) {
  set_has_momo_number();
  if (momo_number_ == &::google::protobuf::internal::kEmptyString) {
    momo_number_ = new ::std::string;
  }
  momo_number_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreInfo::mutable_momo_number() {
  set_has_momo_number();
  if (momo_number_ == &::google::protobuf::internal::kEmptyString) {
    momo_number_ = new ::std::string;
  }
  return momo_number_;
}
inline ::std::string* StoreInfo::release_momo_number() {
  clear_has_momo_number();
  if (momo_number_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = momo_number_;
    momo_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StoreInfo::set_allocated_momo_number(::std::string* momo_number) {
  if (momo_number_ != &::google::protobuf::internal::kEmptyString) {
    delete momo_number_;
  }
  if (momo_number) {
    set_has_momo_number();
    momo_number_ = momo_number;
  } else {
    clear_has_momo_number();
    momo_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SyncStoreLocationReply

// optional bool result = 1;
inline bool SyncStoreLocationReply::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SyncStoreLocationReply::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SyncStoreLocationReply::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SyncStoreLocationReply::clear_result() {
  result_ = false;
  clear_has_result();
}
inline bool SyncStoreLocationReply::result() const {
  return result_;
}
inline void SyncStoreLocationReply::set_result(bool value) {
  set_has_result();
  result_ = value;
}

// repeated .com.mservice.momo.msg.StoreInfo stores = 2;
inline int SyncStoreLocationReply::stores_size() const {
  return stores_.size();
}
inline void SyncStoreLocationReply::clear_stores() {
  stores_.Clear();
}
inline const ::com::mservice::momo::msg::StoreInfo& SyncStoreLocationReply::stores(int index) const {
  return stores_.Get(index);
}
inline ::com::mservice::momo::msg::StoreInfo* SyncStoreLocationReply::mutable_stores(int index) {
  return stores_.Mutable(index);
}
inline ::com::mservice::momo::msg::StoreInfo* SyncStoreLocationReply::add_stores() {
  return stores_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::StoreInfo >&
SyncStoreLocationReply::stores() const {
  return stores_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::StoreInfo >*
SyncStoreLocationReply::mutable_stores() {
  return &stores_;
}

// -------------------------------------------------------------------

// PhoneExist

// optional string number = 1;
inline bool PhoneExist::has_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PhoneExist::set_has_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PhoneExist::clear_has_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PhoneExist::clear_number() {
  if (number_ != &::google::protobuf::internal::kEmptyString) {
    number_->clear();
  }
  clear_has_number();
}
inline const ::std::string& PhoneExist::number() const {
  return *number_;
}
inline void PhoneExist::set_number(const ::std::string& value) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  number_->assign(value);
}
inline void PhoneExist::set_number(const char* value) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  number_->assign(value);
}
inline void PhoneExist::set_number(const char* value, size_t size) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  number_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PhoneExist::mutable_number() {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  return number_;
}
inline ::std::string* PhoneExist::release_number() {
  clear_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = number_;
    number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PhoneExist::set_allocated_number(::std::string* number) {
  if (number_ != &::google::protobuf::internal::kEmptyString) {
    delete number_;
  }
  if (number) {
    set_has_number();
    number_ = number;
  } else {
    clear_has_number();
    number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AgentInfo

// optional bool result = 1;
inline bool AgentInfo::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AgentInfo::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AgentInfo::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AgentInfo::clear_result() {
  result_ = false;
  clear_has_result();
}
inline bool AgentInfo::result() const {
  return result_;
}
inline void AgentInfo::set_result(bool value) {
  set_has_result();
  result_ = value;
}

// optional string name = 2;
inline bool AgentInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AgentInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AgentInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AgentInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& AgentInfo::name() const {
  return *name_;
}
inline void AgentInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AgentInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AgentInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* AgentInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AgentInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string cardId = 3;
inline bool AgentInfo::has_cardid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AgentInfo::set_has_cardid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AgentInfo::clear_has_cardid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AgentInfo::clear_cardid() {
  if (cardid_ != &::google::protobuf::internal::kEmptyString) {
    cardid_->clear();
  }
  clear_has_cardid();
}
inline const ::std::string& AgentInfo::cardid() const {
  return *cardid_;
}
inline void AgentInfo::set_cardid(const ::std::string& value) {
  set_has_cardid();
  if (cardid_ == &::google::protobuf::internal::kEmptyString) {
    cardid_ = new ::std::string;
  }
  cardid_->assign(value);
}
inline void AgentInfo::set_cardid(const char* value) {
  set_has_cardid();
  if (cardid_ == &::google::protobuf::internal::kEmptyString) {
    cardid_ = new ::std::string;
  }
  cardid_->assign(value);
}
inline void AgentInfo::set_cardid(const char* value, size_t size) {
  set_has_cardid();
  if (cardid_ == &::google::protobuf::internal::kEmptyString) {
    cardid_ = new ::std::string;
  }
  cardid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentInfo::mutable_cardid() {
  set_has_cardid();
  if (cardid_ == &::google::protobuf::internal::kEmptyString) {
    cardid_ = new ::std::string;
  }
  return cardid_;
}
inline ::std::string* AgentInfo::release_cardid() {
  clear_has_cardid();
  if (cardid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cardid_;
    cardid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AgentInfo::set_allocated_cardid(::std::string* cardid) {
  if (cardid_ != &::google::protobuf::internal::kEmptyString) {
    delete cardid_;
  }
  if (cardid) {
    set_has_cardid();
    cardid_ = cardid;
  } else {
    clear_has_cardid();
    cardid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string address = 4;
inline bool AgentInfo::has_address() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AgentInfo::set_has_address() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AgentInfo::clear_has_address() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AgentInfo::clear_address() {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& AgentInfo::address() const {
  return *address_;
}
inline void AgentInfo::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void AgentInfo::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void AgentInfo::set_address(const char* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentInfo::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  return address_;
}
inline ::std::string* AgentInfo::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AgentInfo::set_allocated_address(::std::string* address) {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    delete address_;
  }
  if (address) {
    set_has_address();
    address_ = address;
  } else {
    clear_has_address();
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string dateOfBirth = 5;
inline bool AgentInfo::has_dateofbirth() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AgentInfo::set_has_dateofbirth() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AgentInfo::clear_has_dateofbirth() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AgentInfo::clear_dateofbirth() {
  if (dateofbirth_ != &::google::protobuf::internal::kEmptyString) {
    dateofbirth_->clear();
  }
  clear_has_dateofbirth();
}
inline const ::std::string& AgentInfo::dateofbirth() const {
  return *dateofbirth_;
}
inline void AgentInfo::set_dateofbirth(const ::std::string& value) {
  set_has_dateofbirth();
  if (dateofbirth_ == &::google::protobuf::internal::kEmptyString) {
    dateofbirth_ = new ::std::string;
  }
  dateofbirth_->assign(value);
}
inline void AgentInfo::set_dateofbirth(const char* value) {
  set_has_dateofbirth();
  if (dateofbirth_ == &::google::protobuf::internal::kEmptyString) {
    dateofbirth_ = new ::std::string;
  }
  dateofbirth_->assign(value);
}
inline void AgentInfo::set_dateofbirth(const char* value, size_t size) {
  set_has_dateofbirth();
  if (dateofbirth_ == &::google::protobuf::internal::kEmptyString) {
    dateofbirth_ = new ::std::string;
  }
  dateofbirth_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentInfo::mutable_dateofbirth() {
  set_has_dateofbirth();
  if (dateofbirth_ == &::google::protobuf::internal::kEmptyString) {
    dateofbirth_ = new ::std::string;
  }
  return dateofbirth_;
}
inline ::std::string* AgentInfo::release_dateofbirth() {
  clear_has_dateofbirth();
  if (dateofbirth_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dateofbirth_;
    dateofbirth_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AgentInfo::set_allocated_dateofbirth(::std::string* dateofbirth) {
  if (dateofbirth_ != &::google::protobuf::internal::kEmptyString) {
    delete dateofbirth_;
  }
  if (dateofbirth) {
    set_has_dateofbirth();
    dateofbirth_ = dateofbirth;
  } else {
    clear_has_dateofbirth();
    dateofbirth_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 point = 6;
inline bool AgentInfo::has_point() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AgentInfo::set_has_point() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AgentInfo::clear_has_point() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AgentInfo::clear_point() {
  point_ = GOOGLE_ULONGLONG(0);
  clear_has_point();
}
inline ::google::protobuf::uint64 AgentInfo::point() const {
  return point_;
}
inline void AgentInfo::set_point(::google::protobuf::uint64 value) {
  set_has_point();
  point_ = value;
}

// optional uint64 momo = 7;
inline bool AgentInfo::has_momo() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AgentInfo::set_has_momo() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AgentInfo::clear_has_momo() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AgentInfo::clear_momo() {
  momo_ = GOOGLE_ULONGLONG(0);
  clear_has_momo();
}
inline ::google::protobuf::uint64 AgentInfo::momo() const {
  return momo_;
}
inline void AgentInfo::set_momo(::google::protobuf::uint64 value) {
  set_has_momo();
  momo_ = value;
}

// optional uint64 mload = 8;
inline bool AgentInfo::has_mload() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AgentInfo::set_has_mload() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AgentInfo::clear_has_mload() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AgentInfo::clear_mload() {
  mload_ = GOOGLE_ULONGLONG(0);
  clear_has_mload();
}
inline ::google::protobuf::uint64 AgentInfo::mload() const {
  return mload_;
}
inline void AgentInfo::set_mload(::google::protobuf::uint64 value) {
  set_has_mload();
  mload_ = value;
}

// optional .com.mservice.momo.msg.RegStatus regStatus = 9;
inline bool AgentInfo::has_regstatus() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AgentInfo::set_has_regstatus() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AgentInfo::clear_has_regstatus() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AgentInfo::clear_regstatus() {
  if (regstatus_ != NULL) regstatus_->::com::mservice::momo::msg::RegStatus::Clear();
  clear_has_regstatus();
}
inline const ::com::mservice::momo::msg::RegStatus& AgentInfo::regstatus() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return regstatus_ != NULL ? *regstatus_ : *default_instance().regstatus_;
#else
  return regstatus_ != NULL ? *regstatus_ : *default_instance_->regstatus_;
#endif
}
inline ::com::mservice::momo::msg::RegStatus* AgentInfo::mutable_regstatus() {
  set_has_regstatus();
  if (regstatus_ == NULL) regstatus_ = new ::com::mservice::momo::msg::RegStatus;
  return regstatus_;
}
inline ::com::mservice::momo::msg::RegStatus* AgentInfo::release_regstatus() {
  clear_has_regstatus();
  ::com::mservice::momo::msg::RegStatus* temp = regstatus_;
  regstatus_ = NULL;
  return temp;
}
inline void AgentInfo::set_allocated_regstatus(::com::mservice::momo::msg::RegStatus* regstatus) {
  delete regstatus_;
  regstatus_ = regstatus;
  if (regstatus) {
    set_has_regstatus();
  } else {
    clear_has_regstatus();
  }
}

// optional string bank_name = 10;
inline bool AgentInfo::has_bank_name() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AgentInfo::set_has_bank_name() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AgentInfo::clear_has_bank_name() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AgentInfo::clear_bank_name() {
  if (bank_name_ != &::google::protobuf::internal::kEmptyString) {
    bank_name_->clear();
  }
  clear_has_bank_name();
}
inline const ::std::string& AgentInfo::bank_name() const {
  return *bank_name_;
}
inline void AgentInfo::set_bank_name(const ::std::string& value) {
  set_has_bank_name();
  if (bank_name_ == &::google::protobuf::internal::kEmptyString) {
    bank_name_ = new ::std::string;
  }
  bank_name_->assign(value);
}
inline void AgentInfo::set_bank_name(const char* value) {
  set_has_bank_name();
  if (bank_name_ == &::google::protobuf::internal::kEmptyString) {
    bank_name_ = new ::std::string;
  }
  bank_name_->assign(value);
}
inline void AgentInfo::set_bank_name(const char* value, size_t size) {
  set_has_bank_name();
  if (bank_name_ == &::google::protobuf::internal::kEmptyString) {
    bank_name_ = new ::std::string;
  }
  bank_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentInfo::mutable_bank_name() {
  set_has_bank_name();
  if (bank_name_ == &::google::protobuf::internal::kEmptyString) {
    bank_name_ = new ::std::string;
  }
  return bank_name_;
}
inline ::std::string* AgentInfo::release_bank_name() {
  clear_has_bank_name();
  if (bank_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bank_name_;
    bank_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AgentInfo::set_allocated_bank_name(::std::string* bank_name) {
  if (bank_name_ != &::google::protobuf::internal::kEmptyString) {
    delete bank_name_;
  }
  if (bank_name) {
    set_has_bank_name();
    bank_name_ = bank_name;
  } else {
    clear_has_bank_name();
    bank_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string bank_account = 11;
inline bool AgentInfo::has_bank_account() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AgentInfo::set_has_bank_account() {
  _has_bits_[0] |= 0x00000400u;
}
inline void AgentInfo::clear_has_bank_account() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void AgentInfo::clear_bank_account() {
  if (bank_account_ != &::google::protobuf::internal::kEmptyString) {
    bank_account_->clear();
  }
  clear_has_bank_account();
}
inline const ::std::string& AgentInfo::bank_account() const {
  return *bank_account_;
}
inline void AgentInfo::set_bank_account(const ::std::string& value) {
  set_has_bank_account();
  if (bank_account_ == &::google::protobuf::internal::kEmptyString) {
    bank_account_ = new ::std::string;
  }
  bank_account_->assign(value);
}
inline void AgentInfo::set_bank_account(const char* value) {
  set_has_bank_account();
  if (bank_account_ == &::google::protobuf::internal::kEmptyString) {
    bank_account_ = new ::std::string;
  }
  bank_account_->assign(value);
}
inline void AgentInfo::set_bank_account(const char* value, size_t size) {
  set_has_bank_account();
  if (bank_account_ == &::google::protobuf::internal::kEmptyString) {
    bank_account_ = new ::std::string;
  }
  bank_account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentInfo::mutable_bank_account() {
  set_has_bank_account();
  if (bank_account_ == &::google::protobuf::internal::kEmptyString) {
    bank_account_ = new ::std::string;
  }
  return bank_account_;
}
inline ::std::string* AgentInfo::release_bank_account() {
  clear_has_bank_account();
  if (bank_account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bank_account_;
    bank_account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AgentInfo::set_allocated_bank_account(::std::string* bank_account) {
  if (bank_account_ != &::google::protobuf::internal::kEmptyString) {
    delete bank_account_;
  }
  if (bank_account) {
    set_has_bank_account();
    bank_account_ = bank_account;
  } else {
    clear_has_bank_account();
    bank_account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string bank_code = 12;
inline bool AgentInfo::has_bank_code() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void AgentInfo::set_has_bank_code() {
  _has_bits_[0] |= 0x00000800u;
}
inline void AgentInfo::clear_has_bank_code() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void AgentInfo::clear_bank_code() {
  if (bank_code_ != &::google::protobuf::internal::kEmptyString) {
    bank_code_->clear();
  }
  clear_has_bank_code();
}
inline const ::std::string& AgentInfo::bank_code() const {
  return *bank_code_;
}
inline void AgentInfo::set_bank_code(const ::std::string& value) {
  set_has_bank_code();
  if (bank_code_ == &::google::protobuf::internal::kEmptyString) {
    bank_code_ = new ::std::string;
  }
  bank_code_->assign(value);
}
inline void AgentInfo::set_bank_code(const char* value) {
  set_has_bank_code();
  if (bank_code_ == &::google::protobuf::internal::kEmptyString) {
    bank_code_ = new ::std::string;
  }
  bank_code_->assign(value);
}
inline void AgentInfo::set_bank_code(const char* value, size_t size) {
  set_has_bank_code();
  if (bank_code_ == &::google::protobuf::internal::kEmptyString) {
    bank_code_ = new ::std::string;
  }
  bank_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentInfo::mutable_bank_code() {
  set_has_bank_code();
  if (bank_code_ == &::google::protobuf::internal::kEmptyString) {
    bank_code_ = new ::std::string;
  }
  return bank_code_;
}
inline ::std::string* AgentInfo::release_bank_code() {
  clear_has_bank_code();
  if (bank_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bank_code_;
    bank_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AgentInfo::set_allocated_bank_code(::std::string* bank_code) {
  if (bank_code_ != &::google::protobuf::internal::kEmptyString) {
    delete bank_code_;
  }
  if (bank_code) {
    set_has_bank_code();
    bank_code_ = bank_code;
  } else {
    clear_has_bank_code();
    bank_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string email = 13;
inline bool AgentInfo::has_email() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void AgentInfo::set_has_email() {
  _has_bits_[0] |= 0x00001000u;
}
inline void AgentInfo::clear_has_email() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void AgentInfo::clear_email() {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& AgentInfo::email() const {
  return *email_;
}
inline void AgentInfo::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void AgentInfo::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void AgentInfo::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentInfo::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  return email_;
}
inline ::std::string* AgentInfo::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AgentInfo::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 noname_count = 14;
inline bool AgentInfo::has_noname_count() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void AgentInfo::set_has_noname_count() {
  _has_bits_[0] |= 0x00002000u;
}
inline void AgentInfo::clear_has_noname_count() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void AgentInfo::clear_noname_count() {
  noname_count_ = 0u;
  clear_has_noname_count();
}
inline ::google::protobuf::uint32 AgentInfo::noname_count() const {
  return noname_count_;
}
inline void AgentInfo::set_noname_count(::google::protobuf::uint32 value) {
  set_has_noname_count();
  noname_count_ = value;
}

// optional bool in_promotion = 15;
inline bool AgentInfo::has_in_promotion() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void AgentInfo::set_has_in_promotion() {
  _has_bits_[0] |= 0x00004000u;
}
inline void AgentInfo::clear_has_in_promotion() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void AgentInfo::clear_in_promotion() {
  in_promotion_ = false;
  clear_has_in_promotion();
}
inline bool AgentInfo::in_promotion() const {
  return in_promotion_;
}
inline void AgentInfo::set_in_promotion(bool value) {
  set_has_in_promotion();
  in_promotion_ = value;
}

// optional bool exist = 16;
inline bool AgentInfo::has_exist() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void AgentInfo::set_has_exist() {
  _has_bits_[0] |= 0x00008000u;
}
inline void AgentInfo::clear_has_exist() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void AgentInfo::clear_exist() {
  exist_ = false;
  clear_has_exist();
}
inline bool AgentInfo::exist() const {
  return exist_;
}
inline void AgentInfo::set_exist(bool value) {
  set_has_exist();
  exist_ = value;
}

// repeated .com.mservice.momo.msg.TextValue list_key_value = 17;
inline int AgentInfo::list_key_value_size() const {
  return list_key_value_.size();
}
inline void AgentInfo::clear_list_key_value() {
  list_key_value_.Clear();
}
inline const ::com::mservice::momo::msg::TextValue& AgentInfo::list_key_value(int index) const {
  return list_key_value_.Get(index);
}
inline ::com::mservice::momo::msg::TextValue* AgentInfo::mutable_list_key_value(int index) {
  return list_key_value_.Mutable(index);
}
inline ::com::mservice::momo::msg::TextValue* AgentInfo::add_list_key_value() {
  return list_key_value_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::TextValue >&
AgentInfo::list_key_value() const {
  return list_key_value_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::TextValue >*
AgentInfo::mutable_list_key_value() {
  return &list_key_value_;
}

// -------------------------------------------------------------------

// BankNetToMomoRely

// optional bool result = 1;
inline bool BankNetToMomoRely::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BankNetToMomoRely::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BankNetToMomoRely::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BankNetToMomoRely::clear_result() {
  result_ = false;
  clear_has_result();
}
inline bool BankNetToMomoRely::result() const {
  return result_;
}
inline void BankNetToMomoRely::set_result(bool value) {
  set_has_result();
  result_ = value;
}

// optional uint32 rcode = 2;
inline bool BankNetToMomoRely::has_rcode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BankNetToMomoRely::set_has_rcode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BankNetToMomoRely::clear_has_rcode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BankNetToMomoRely::clear_rcode() {
  rcode_ = 0u;
  clear_has_rcode();
}
inline ::google::protobuf::uint32 BankNetToMomoRely::rcode() const {
  return rcode_;
}
inline void BankNetToMomoRely::set_rcode(::google::protobuf::uint32 value) {
  set_has_rcode();
  rcode_ = value;
}

// optional string merchant_trans_id = 3;
inline bool BankNetToMomoRely::has_merchant_trans_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BankNetToMomoRely::set_has_merchant_trans_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BankNetToMomoRely::clear_has_merchant_trans_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BankNetToMomoRely::clear_merchant_trans_id() {
  if (merchant_trans_id_ != &::google::protobuf::internal::kEmptyString) {
    merchant_trans_id_->clear();
  }
  clear_has_merchant_trans_id();
}
inline const ::std::string& BankNetToMomoRely::merchant_trans_id() const {
  return *merchant_trans_id_;
}
inline void BankNetToMomoRely::set_merchant_trans_id(const ::std::string& value) {
  set_has_merchant_trans_id();
  if (merchant_trans_id_ == &::google::protobuf::internal::kEmptyString) {
    merchant_trans_id_ = new ::std::string;
  }
  merchant_trans_id_->assign(value);
}
inline void BankNetToMomoRely::set_merchant_trans_id(const char* value) {
  set_has_merchant_trans_id();
  if (merchant_trans_id_ == &::google::protobuf::internal::kEmptyString) {
    merchant_trans_id_ = new ::std::string;
  }
  merchant_trans_id_->assign(value);
}
inline void BankNetToMomoRely::set_merchant_trans_id(const char* value, size_t size) {
  set_has_merchant_trans_id();
  if (merchant_trans_id_ == &::google::protobuf::internal::kEmptyString) {
    merchant_trans_id_ = new ::std::string;
  }
  merchant_trans_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BankNetToMomoRely::mutable_merchant_trans_id() {
  set_has_merchant_trans_id();
  if (merchant_trans_id_ == &::google::protobuf::internal::kEmptyString) {
    merchant_trans_id_ = new ::std::string;
  }
  return merchant_trans_id_;
}
inline ::std::string* BankNetToMomoRely::release_merchant_trans_id() {
  clear_has_merchant_trans_id();
  if (merchant_trans_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = merchant_trans_id_;
    merchant_trans_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BankNetToMomoRely::set_allocated_merchant_trans_id(::std::string* merchant_trans_id) {
  if (merchant_trans_id_ != &::google::protobuf::internal::kEmptyString) {
    delete merchant_trans_id_;
  }
  if (merchant_trans_id) {
    set_has_merchant_trans_id();
    merchant_trans_id_ = merchant_trans_id;
  } else {
    clear_has_merchant_trans_id();
    merchant_trans_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string trans_id = 4;
inline bool BankNetToMomoRely::has_trans_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BankNetToMomoRely::set_has_trans_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BankNetToMomoRely::clear_has_trans_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BankNetToMomoRely::clear_trans_id() {
  if (trans_id_ != &::google::protobuf::internal::kEmptyString) {
    trans_id_->clear();
  }
  clear_has_trans_id();
}
inline const ::std::string& BankNetToMomoRely::trans_id() const {
  return *trans_id_;
}
inline void BankNetToMomoRely::set_trans_id(const ::std::string& value) {
  set_has_trans_id();
  if (trans_id_ == &::google::protobuf::internal::kEmptyString) {
    trans_id_ = new ::std::string;
  }
  trans_id_->assign(value);
}
inline void BankNetToMomoRely::set_trans_id(const char* value) {
  set_has_trans_id();
  if (trans_id_ == &::google::protobuf::internal::kEmptyString) {
    trans_id_ = new ::std::string;
  }
  trans_id_->assign(value);
}
inline void BankNetToMomoRely::set_trans_id(const char* value, size_t size) {
  set_has_trans_id();
  if (trans_id_ == &::google::protobuf::internal::kEmptyString) {
    trans_id_ = new ::std::string;
  }
  trans_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BankNetToMomoRely::mutable_trans_id() {
  set_has_trans_id();
  if (trans_id_ == &::google::protobuf::internal::kEmptyString) {
    trans_id_ = new ::std::string;
  }
  return trans_id_;
}
inline ::std::string* BankNetToMomoRely::release_trans_id() {
  clear_has_trans_id();
  if (trans_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = trans_id_;
    trans_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BankNetToMomoRely::set_allocated_trans_id(::std::string* trans_id) {
  if (trans_id_ != &::google::protobuf::internal::kEmptyString) {
    delete trans_id_;
  }
  if (trans_id) {
    set_has_trans_id();
    trans_id_ = trans_id;
  } else {
    clear_has_trans_id();
    trans_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MoneyRequest

// optional uint32 to_number = 1;
inline bool MoneyRequest::has_to_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneyRequest::set_has_to_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoneyRequest::clear_has_to_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoneyRequest::clear_to_number() {
  to_number_ = 0u;
  clear_has_to_number();
}
inline ::google::protobuf::uint32 MoneyRequest::to_number() const {
  return to_number_;
}
inline void MoneyRequest::set_to_number(::google::protobuf::uint32 value) {
  set_has_to_number();
  to_number_ = value;
}

// optional uint64 amount = 2;
inline bool MoneyRequest::has_amount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneyRequest::set_has_amount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MoneyRequest::clear_has_amount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MoneyRequest::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 MoneyRequest::amount() const {
  return amount_;
}
inline void MoneyRequest::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
}

// optional string content = 3;
inline bool MoneyRequest::has_content() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoneyRequest::set_has_content() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MoneyRequest::clear_has_content() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MoneyRequest::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& MoneyRequest::content() const {
  return *content_;
}
inline void MoneyRequest::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void MoneyRequest::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void MoneyRequest::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MoneyRequest::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* MoneyRequest::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MoneyRequest::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 from_number = 4;
inline bool MoneyRequest::has_from_number() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MoneyRequest::set_has_from_number() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MoneyRequest::clear_has_from_number() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MoneyRequest::clear_from_number() {
  from_number_ = 0u;
  clear_has_from_number();
}
inline ::google::protobuf::uint32 MoneyRequest::from_number() const {
  return from_number_;
}
inline void MoneyRequest::set_from_number(::google::protobuf::uint32 value) {
  set_has_from_number();
  from_number_ = value;
}

// optional string from_name = 5;
inline bool MoneyRequest::has_from_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MoneyRequest::set_has_from_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MoneyRequest::clear_has_from_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MoneyRequest::clear_from_name() {
  if (from_name_ != &::google::protobuf::internal::kEmptyString) {
    from_name_->clear();
  }
  clear_has_from_name();
}
inline const ::std::string& MoneyRequest::from_name() const {
  return *from_name_;
}
inline void MoneyRequest::set_from_name(const ::std::string& value) {
  set_has_from_name();
  if (from_name_ == &::google::protobuf::internal::kEmptyString) {
    from_name_ = new ::std::string;
  }
  from_name_->assign(value);
}
inline void MoneyRequest::set_from_name(const char* value) {
  set_has_from_name();
  if (from_name_ == &::google::protobuf::internal::kEmptyString) {
    from_name_ = new ::std::string;
  }
  from_name_->assign(value);
}
inline void MoneyRequest::set_from_name(const char* value, size_t size) {
  set_has_from_name();
  if (from_name_ == &::google::protobuf::internal::kEmptyString) {
    from_name_ = new ::std::string;
  }
  from_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MoneyRequest::mutable_from_name() {
  set_has_from_name();
  if (from_name_ == &::google::protobuf::internal::kEmptyString) {
    from_name_ = new ::std::string;
  }
  return from_name_;
}
inline ::std::string* MoneyRequest::release_from_name() {
  clear_has_from_name();
  if (from_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = from_name_;
    from_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MoneyRequest::set_allocated_from_name(::std::string* from_name) {
  if (from_name_ != &::google::protobuf::internal::kEmptyString) {
    delete from_name_;
  }
  if (from_name) {
    set_has_from_name();
    from_name_ = from_name;
  } else {
    clear_has_from_name();
    from_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TranHisV1

// optional uint64 tranId = 1;
inline bool TranHisV1::has_tranid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TranHisV1::set_has_tranid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TranHisV1::clear_has_tranid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TranHisV1::clear_tranid() {
  tranid_ = GOOGLE_ULONGLONG(0);
  clear_has_tranid();
}
inline ::google::protobuf::uint64 TranHisV1::tranid() const {
  return tranid_;
}
inline void TranHisV1::set_tranid(::google::protobuf::uint64 value) {
  set_has_tranid();
  tranid_ = value;
}

// optional uint64 client_time = 2;
inline bool TranHisV1::has_client_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TranHisV1::set_has_client_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TranHisV1::clear_has_client_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TranHisV1::clear_client_time() {
  client_time_ = GOOGLE_ULONGLONG(0);
  clear_has_client_time();
}
inline ::google::protobuf::uint64 TranHisV1::client_time() const {
  return client_time_;
}
inline void TranHisV1::set_client_time(::google::protobuf::uint64 value) {
  set_has_client_time();
  client_time_ = value;
}

// optional uint64 ackTime = 3;
inline bool TranHisV1::has_acktime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TranHisV1::set_has_acktime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TranHisV1::clear_has_acktime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TranHisV1::clear_acktime() {
  acktime_ = GOOGLE_ULONGLONG(0);
  clear_has_acktime();
}
inline ::google::protobuf::uint64 TranHisV1::acktime() const {
  return acktime_;
}
inline void TranHisV1::set_acktime(::google::protobuf::uint64 value) {
  set_has_acktime();
  acktime_ = value;
}

// optional uint64 finishTime = 4;
inline bool TranHisV1::has_finishtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TranHisV1::set_has_finishtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TranHisV1::clear_has_finishtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TranHisV1::clear_finishtime() {
  finishtime_ = GOOGLE_ULONGLONG(0);
  clear_has_finishtime();
}
inline ::google::protobuf::uint64 TranHisV1::finishtime() const {
  return finishtime_;
}
inline void TranHisV1::set_finishtime(::google::protobuf::uint64 value) {
  set_has_finishtime();
  finishtime_ = value;
}

// optional uint32 tranType = 5;
inline bool TranHisV1::has_trantype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TranHisV1::set_has_trantype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TranHisV1::clear_has_trantype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TranHisV1::clear_trantype() {
  trantype_ = 0u;
  clear_has_trantype();
}
inline ::google::protobuf::uint32 TranHisV1::trantype() const {
  return trantype_;
}
inline void TranHisV1::set_trantype(::google::protobuf::uint32 value) {
  set_has_trantype();
  trantype_ = value;
}

// optional uint32 io = 6;
inline bool TranHisV1::has_io() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TranHisV1::set_has_io() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TranHisV1::clear_has_io() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TranHisV1::clear_io() {
  io_ = 0u;
  clear_has_io();
}
inline ::google::protobuf::uint32 TranHisV1::io() const {
  return io_;
}
inline void TranHisV1::set_io(::google::protobuf::uint32 value) {
  set_has_io();
  io_ = value;
}

// optional uint32 category = 7;
inline bool TranHisV1::has_category() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TranHisV1::set_has_category() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TranHisV1::clear_has_category() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TranHisV1::clear_category() {
  category_ = 0u;
  clear_has_category();
}
inline ::google::protobuf::uint32 TranHisV1::category() const {
  return category_;
}
inline void TranHisV1::set_category(::google::protobuf::uint32 value) {
  set_has_category();
  category_ = value;
}

// optional string partnerId = 8;
inline bool TranHisV1::has_partnerid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TranHisV1::set_has_partnerid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TranHisV1::clear_has_partnerid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TranHisV1::clear_partnerid() {
  if (partnerid_ != &::google::protobuf::internal::kEmptyString) {
    partnerid_->clear();
  }
  clear_has_partnerid();
}
inline const ::std::string& TranHisV1::partnerid() const {
  return *partnerid_;
}
inline void TranHisV1::set_partnerid(const ::std::string& value) {
  set_has_partnerid();
  if (partnerid_ == &::google::protobuf::internal::kEmptyString) {
    partnerid_ = new ::std::string;
  }
  partnerid_->assign(value);
}
inline void TranHisV1::set_partnerid(const char* value) {
  set_has_partnerid();
  if (partnerid_ == &::google::protobuf::internal::kEmptyString) {
    partnerid_ = new ::std::string;
  }
  partnerid_->assign(value);
}
inline void TranHisV1::set_partnerid(const char* value, size_t size) {
  set_has_partnerid();
  if (partnerid_ == &::google::protobuf::internal::kEmptyString) {
    partnerid_ = new ::std::string;
  }
  partnerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TranHisV1::mutable_partnerid() {
  set_has_partnerid();
  if (partnerid_ == &::google::protobuf::internal::kEmptyString) {
    partnerid_ = new ::std::string;
  }
  return partnerid_;
}
inline ::std::string* TranHisV1::release_partnerid() {
  clear_has_partnerid();
  if (partnerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = partnerid_;
    partnerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TranHisV1::set_allocated_partnerid(::std::string* partnerid) {
  if (partnerid_ != &::google::protobuf::internal::kEmptyString) {
    delete partnerid_;
  }
  if (partnerid) {
    set_has_partnerid();
    partnerid_ = partnerid;
  } else {
    clear_has_partnerid();
    partnerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string partnerCode = 9;
inline bool TranHisV1::has_partnercode() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TranHisV1::set_has_partnercode() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TranHisV1::clear_has_partnercode() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TranHisV1::clear_partnercode() {
  if (partnercode_ != &::google::protobuf::internal::kEmptyString) {
    partnercode_->clear();
  }
  clear_has_partnercode();
}
inline const ::std::string& TranHisV1::partnercode() const {
  return *partnercode_;
}
inline void TranHisV1::set_partnercode(const ::std::string& value) {
  set_has_partnercode();
  if (partnercode_ == &::google::protobuf::internal::kEmptyString) {
    partnercode_ = new ::std::string;
  }
  partnercode_->assign(value);
}
inline void TranHisV1::set_partnercode(const char* value) {
  set_has_partnercode();
  if (partnercode_ == &::google::protobuf::internal::kEmptyString) {
    partnercode_ = new ::std::string;
  }
  partnercode_->assign(value);
}
inline void TranHisV1::set_partnercode(const char* value, size_t size) {
  set_has_partnercode();
  if (partnercode_ == &::google::protobuf::internal::kEmptyString) {
    partnercode_ = new ::std::string;
  }
  partnercode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TranHisV1::mutable_partnercode() {
  set_has_partnercode();
  if (partnercode_ == &::google::protobuf::internal::kEmptyString) {
    partnercode_ = new ::std::string;
  }
  return partnercode_;
}
inline ::std::string* TranHisV1::release_partnercode() {
  clear_has_partnercode();
  if (partnercode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = partnercode_;
    partnercode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TranHisV1::set_allocated_partnercode(::std::string* partnercode) {
  if (partnercode_ != &::google::protobuf::internal::kEmptyString) {
    delete partnercode_;
  }
  if (partnercode) {
    set_has_partnercode();
    partnercode_ = partnercode;
  } else {
    clear_has_partnercode();
    partnercode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string partnerName = 10;
inline bool TranHisV1::has_partnername() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TranHisV1::set_has_partnername() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TranHisV1::clear_has_partnername() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TranHisV1::clear_partnername() {
  if (partnername_ != &::google::protobuf::internal::kEmptyString) {
    partnername_->clear();
  }
  clear_has_partnername();
}
inline const ::std::string& TranHisV1::partnername() const {
  return *partnername_;
}
inline void TranHisV1::set_partnername(const ::std::string& value) {
  set_has_partnername();
  if (partnername_ == &::google::protobuf::internal::kEmptyString) {
    partnername_ = new ::std::string;
  }
  partnername_->assign(value);
}
inline void TranHisV1::set_partnername(const char* value) {
  set_has_partnername();
  if (partnername_ == &::google::protobuf::internal::kEmptyString) {
    partnername_ = new ::std::string;
  }
  partnername_->assign(value);
}
inline void TranHisV1::set_partnername(const char* value, size_t size) {
  set_has_partnername();
  if (partnername_ == &::google::protobuf::internal::kEmptyString) {
    partnername_ = new ::std::string;
  }
  partnername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TranHisV1::mutable_partnername() {
  set_has_partnername();
  if (partnername_ == &::google::protobuf::internal::kEmptyString) {
    partnername_ = new ::std::string;
  }
  return partnername_;
}
inline ::std::string* TranHisV1::release_partnername() {
  clear_has_partnername();
  if (partnername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = partnername_;
    partnername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TranHisV1::set_allocated_partnername(::std::string* partnername) {
  if (partnername_ != &::google::protobuf::internal::kEmptyString) {
    delete partnername_;
  }
  if (partnername) {
    set_has_partnername();
    partnername_ = partnername;
  } else {
    clear_has_partnername();
    partnername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string partner_ref = 11;
inline bool TranHisV1::has_partner_ref() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TranHisV1::set_has_partner_ref() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TranHisV1::clear_has_partner_ref() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TranHisV1::clear_partner_ref() {
  if (partner_ref_ != &::google::protobuf::internal::kEmptyString) {
    partner_ref_->clear();
  }
  clear_has_partner_ref();
}
inline const ::std::string& TranHisV1::partner_ref() const {
  return *partner_ref_;
}
inline void TranHisV1::set_partner_ref(const ::std::string& value) {
  set_has_partner_ref();
  if (partner_ref_ == &::google::protobuf::internal::kEmptyString) {
    partner_ref_ = new ::std::string;
  }
  partner_ref_->assign(value);
}
inline void TranHisV1::set_partner_ref(const char* value) {
  set_has_partner_ref();
  if (partner_ref_ == &::google::protobuf::internal::kEmptyString) {
    partner_ref_ = new ::std::string;
  }
  partner_ref_->assign(value);
}
inline void TranHisV1::set_partner_ref(const char* value, size_t size) {
  set_has_partner_ref();
  if (partner_ref_ == &::google::protobuf::internal::kEmptyString) {
    partner_ref_ = new ::std::string;
  }
  partner_ref_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TranHisV1::mutable_partner_ref() {
  set_has_partner_ref();
  if (partner_ref_ == &::google::protobuf::internal::kEmptyString) {
    partner_ref_ = new ::std::string;
  }
  return partner_ref_;
}
inline ::std::string* TranHisV1::release_partner_ref() {
  clear_has_partner_ref();
  if (partner_ref_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = partner_ref_;
    partner_ref_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TranHisV1::set_allocated_partner_ref(::std::string* partner_ref) {
  if (partner_ref_ != &::google::protobuf::internal::kEmptyString) {
    delete partner_ref_;
  }
  if (partner_ref) {
    set_has_partner_ref();
    partner_ref_ = partner_ref;
  } else {
    clear_has_partner_ref();
    partner_ref_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string billId = 12;
inline bool TranHisV1::has_billid() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TranHisV1::set_has_billid() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TranHisV1::clear_has_billid() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TranHisV1::clear_billid() {
  if (billid_ != &::google::protobuf::internal::kEmptyString) {
    billid_->clear();
  }
  clear_has_billid();
}
inline const ::std::string& TranHisV1::billid() const {
  return *billid_;
}
inline void TranHisV1::set_billid(const ::std::string& value) {
  set_has_billid();
  if (billid_ == &::google::protobuf::internal::kEmptyString) {
    billid_ = new ::std::string;
  }
  billid_->assign(value);
}
inline void TranHisV1::set_billid(const char* value) {
  set_has_billid();
  if (billid_ == &::google::protobuf::internal::kEmptyString) {
    billid_ = new ::std::string;
  }
  billid_->assign(value);
}
inline void TranHisV1::set_billid(const char* value, size_t size) {
  set_has_billid();
  if (billid_ == &::google::protobuf::internal::kEmptyString) {
    billid_ = new ::std::string;
  }
  billid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TranHisV1::mutable_billid() {
  set_has_billid();
  if (billid_ == &::google::protobuf::internal::kEmptyString) {
    billid_ = new ::std::string;
  }
  return billid_;
}
inline ::std::string* TranHisV1::release_billid() {
  clear_has_billid();
  if (billid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = billid_;
    billid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TranHisV1::set_allocated_billid(::std::string* billid) {
  if (billid_ != &::google::protobuf::internal::kEmptyString) {
    delete billid_;
  }
  if (billid) {
    set_has_billid();
    billid_ = billid;
  } else {
    clear_has_billid();
    billid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 amount = 13;
inline bool TranHisV1::has_amount() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TranHisV1::set_has_amount() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TranHisV1::clear_has_amount() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TranHisV1::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 TranHisV1::amount() const {
  return amount_;
}
inline void TranHisV1::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
}

// optional string comment = 14;
inline bool TranHisV1::has_comment() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TranHisV1::set_has_comment() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TranHisV1::clear_has_comment() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TranHisV1::clear_comment() {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    comment_->clear();
  }
  clear_has_comment();
}
inline const ::std::string& TranHisV1::comment() const {
  return *comment_;
}
inline void TranHisV1::set_comment(const ::std::string& value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void TranHisV1::set_comment(const char* value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void TranHisV1::set_comment(const char* value, size_t size) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TranHisV1::mutable_comment() {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  return comment_;
}
inline ::std::string* TranHisV1::release_comment() {
  clear_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = comment_;
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TranHisV1::set_allocated_comment(::std::string* comment) {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    delete comment_;
  }
  if (comment) {
    set_has_comment();
    comment_ = comment;
  } else {
    clear_has_comment();
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 status = 15;
inline bool TranHisV1::has_status() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TranHisV1::set_has_status() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TranHisV1::clear_has_status() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TranHisV1::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 TranHisV1::status() const {
  return status_;
}
inline void TranHisV1::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
}

// optional uint32 error = 16;
inline bool TranHisV1::has_error() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TranHisV1::set_has_error() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TranHisV1::clear_has_error() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TranHisV1::clear_error() {
  error_ = 0u;
  clear_has_error();
}
inline ::google::protobuf::uint32 TranHisV1::error() const {
  return error_;
}
inline void TranHisV1::set_error(::google::protobuf::uint32 value) {
  set_has_error();
  error_ = value;
}

// optional uint64 command_Ind = 17;
inline bool TranHisV1::has_command_ind() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TranHisV1::set_has_command_ind() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TranHisV1::clear_has_command_ind() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TranHisV1::clear_command_ind() {
  command_ind_ = GOOGLE_ULONGLONG(0);
  clear_has_command_ind();
}
inline ::google::protobuf::uint64 TranHisV1::command_ind() const {
  return command_ind_;
}
inline void TranHisV1::set_command_ind(::google::protobuf::uint64 value) {
  set_has_command_ind();
  command_ind_ = value;
}

// optional uint32 source_from = 18;
inline bool TranHisV1::has_source_from() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TranHisV1::set_has_source_from() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TranHisV1::clear_has_source_from() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TranHisV1::clear_source_from() {
  source_from_ = 0u;
  clear_has_source_from();
}
inline ::google::protobuf::uint32 TranHisV1::source_from() const {
  return source_from_;
}
inline void TranHisV1::set_source_from(::google::protobuf::uint32 value) {
  set_has_source_from();
  source_from_ = value;
}

// optional string partner_extra_1 = 19;
inline bool TranHisV1::has_partner_extra_1() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void TranHisV1::set_has_partner_extra_1() {
  _has_bits_[0] |= 0x00040000u;
}
inline void TranHisV1::clear_has_partner_extra_1() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void TranHisV1::clear_partner_extra_1() {
  if (partner_extra_1_ != &::google::protobuf::internal::kEmptyString) {
    partner_extra_1_->clear();
  }
  clear_has_partner_extra_1();
}
inline const ::std::string& TranHisV1::partner_extra_1() const {
  return *partner_extra_1_;
}
inline void TranHisV1::set_partner_extra_1(const ::std::string& value) {
  set_has_partner_extra_1();
  if (partner_extra_1_ == &::google::protobuf::internal::kEmptyString) {
    partner_extra_1_ = new ::std::string;
  }
  partner_extra_1_->assign(value);
}
inline void TranHisV1::set_partner_extra_1(const char* value) {
  set_has_partner_extra_1();
  if (partner_extra_1_ == &::google::protobuf::internal::kEmptyString) {
    partner_extra_1_ = new ::std::string;
  }
  partner_extra_1_->assign(value);
}
inline void TranHisV1::set_partner_extra_1(const char* value, size_t size) {
  set_has_partner_extra_1();
  if (partner_extra_1_ == &::google::protobuf::internal::kEmptyString) {
    partner_extra_1_ = new ::std::string;
  }
  partner_extra_1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TranHisV1::mutable_partner_extra_1() {
  set_has_partner_extra_1();
  if (partner_extra_1_ == &::google::protobuf::internal::kEmptyString) {
    partner_extra_1_ = new ::std::string;
  }
  return partner_extra_1_;
}
inline ::std::string* TranHisV1::release_partner_extra_1() {
  clear_has_partner_extra_1();
  if (partner_extra_1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = partner_extra_1_;
    partner_extra_1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TranHisV1::set_allocated_partner_extra_1(::std::string* partner_extra_1) {
  if (partner_extra_1_ != &::google::protobuf::internal::kEmptyString) {
    delete partner_extra_1_;
  }
  if (partner_extra_1) {
    set_has_partner_extra_1();
    partner_extra_1_ = partner_extra_1;
  } else {
    clear_has_partner_extra_1();
    partner_extra_1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .com.mservice.momo.msg.TextValue kvp = 20;
inline int TranHisV1::kvp_size() const {
  return kvp_.size();
}
inline void TranHisV1::clear_kvp() {
  kvp_.Clear();
}
inline const ::com::mservice::momo::msg::TextValue& TranHisV1::kvp(int index) const {
  return kvp_.Get(index);
}
inline ::com::mservice::momo::msg::TextValue* TranHisV1::mutable_kvp(int index) {
  return kvp_.Mutable(index);
}
inline ::com::mservice::momo::msg::TextValue* TranHisV1::add_kvp() {
  return kvp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::TextValue >&
TranHisV1::kvp() const {
  return kvp_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::TextValue >*
TranHisV1::mutable_kvp() {
  return &kvp_;
}

// optional string desc = 21;
inline bool TranHisV1::has_desc() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void TranHisV1::set_has_desc() {
  _has_bits_[0] |= 0x00100000u;
}
inline void TranHisV1::clear_has_desc() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void TranHisV1::clear_desc() {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& TranHisV1::desc() const {
  return *desc_;
}
inline void TranHisV1::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void TranHisV1::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void TranHisV1::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TranHisV1::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  return desc_;
}
inline ::std::string* TranHisV1::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TranHisV1::set_allocated_desc(::std::string* desc) {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    delete desc_;
  }
  if (desc) {
    set_has_desc();
    desc_ = desc;
  } else {
    clear_has_desc();
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string share = 22;
inline bool TranHisV1::has_share() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void TranHisV1::set_has_share() {
  _has_bits_[0] |= 0x00200000u;
}
inline void TranHisV1::clear_has_share() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void TranHisV1::clear_share() {
  if (share_ != &::google::protobuf::internal::kEmptyString) {
    share_->clear();
  }
  clear_has_share();
}
inline const ::std::string& TranHisV1::share() const {
  return *share_;
}
inline void TranHisV1::set_share(const ::std::string& value) {
  set_has_share();
  if (share_ == &::google::protobuf::internal::kEmptyString) {
    share_ = new ::std::string;
  }
  share_->assign(value);
}
inline void TranHisV1::set_share(const char* value) {
  set_has_share();
  if (share_ == &::google::protobuf::internal::kEmptyString) {
    share_ = new ::std::string;
  }
  share_->assign(value);
}
inline void TranHisV1::set_share(const char* value, size_t size) {
  set_has_share();
  if (share_ == &::google::protobuf::internal::kEmptyString) {
    share_ = new ::std::string;
  }
  share_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TranHisV1::mutable_share() {
  set_has_share();
  if (share_ == &::google::protobuf::internal::kEmptyString) {
    share_ = new ::std::string;
  }
  return share_;
}
inline ::std::string* TranHisV1::release_share() {
  clear_has_share();
  if (share_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = share_;
    share_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TranHisV1::set_allocated_share(::std::string* share) {
  if (share_ != &::google::protobuf::internal::kEmptyString) {
    delete share_;
  }
  if (share) {
    set_has_share();
    share_ = share;
  } else {
    clear_has_share();
    share_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CardItem

// optional string card_holder_year = 1;
inline bool CardItem::has_card_holder_year() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CardItem::set_has_card_holder_year() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CardItem::clear_has_card_holder_year() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CardItem::clear_card_holder_year() {
  if (card_holder_year_ != &::google::protobuf::internal::kEmptyString) {
    card_holder_year_->clear();
  }
  clear_has_card_holder_year();
}
inline const ::std::string& CardItem::card_holder_year() const {
  return *card_holder_year_;
}
inline void CardItem::set_card_holder_year(const ::std::string& value) {
  set_has_card_holder_year();
  if (card_holder_year_ == &::google::protobuf::internal::kEmptyString) {
    card_holder_year_ = new ::std::string;
  }
  card_holder_year_->assign(value);
}
inline void CardItem::set_card_holder_year(const char* value) {
  set_has_card_holder_year();
  if (card_holder_year_ == &::google::protobuf::internal::kEmptyString) {
    card_holder_year_ = new ::std::string;
  }
  card_holder_year_->assign(value);
}
inline void CardItem::set_card_holder_year(const char* value, size_t size) {
  set_has_card_holder_year();
  if (card_holder_year_ == &::google::protobuf::internal::kEmptyString) {
    card_holder_year_ = new ::std::string;
  }
  card_holder_year_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CardItem::mutable_card_holder_year() {
  set_has_card_holder_year();
  if (card_holder_year_ == &::google::protobuf::internal::kEmptyString) {
    card_holder_year_ = new ::std::string;
  }
  return card_holder_year_;
}
inline ::std::string* CardItem::release_card_holder_year() {
  clear_has_card_holder_year();
  if (card_holder_year_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = card_holder_year_;
    card_holder_year_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CardItem::set_allocated_card_holder_year(::std::string* card_holder_year) {
  if (card_holder_year_ != &::google::protobuf::internal::kEmptyString) {
    delete card_holder_year_;
  }
  if (card_holder_year) {
    set_has_card_holder_year();
    card_holder_year_ = card_holder_year;
  } else {
    clear_has_card_holder_year();
    card_holder_year_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string card_holder_month = 2;
inline bool CardItem::has_card_holder_month() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CardItem::set_has_card_holder_month() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CardItem::clear_has_card_holder_month() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CardItem::clear_card_holder_month() {
  if (card_holder_month_ != &::google::protobuf::internal::kEmptyString) {
    card_holder_month_->clear();
  }
  clear_has_card_holder_month();
}
inline const ::std::string& CardItem::card_holder_month() const {
  return *card_holder_month_;
}
inline void CardItem::set_card_holder_month(const ::std::string& value) {
  set_has_card_holder_month();
  if (card_holder_month_ == &::google::protobuf::internal::kEmptyString) {
    card_holder_month_ = new ::std::string;
  }
  card_holder_month_->assign(value);
}
inline void CardItem::set_card_holder_month(const char* value) {
  set_has_card_holder_month();
  if (card_holder_month_ == &::google::protobuf::internal::kEmptyString) {
    card_holder_month_ = new ::std::string;
  }
  card_holder_month_->assign(value);
}
inline void CardItem::set_card_holder_month(const char* value, size_t size) {
  set_has_card_holder_month();
  if (card_holder_month_ == &::google::protobuf::internal::kEmptyString) {
    card_holder_month_ = new ::std::string;
  }
  card_holder_month_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CardItem::mutable_card_holder_month() {
  set_has_card_holder_month();
  if (card_holder_month_ == &::google::protobuf::internal::kEmptyString) {
    card_holder_month_ = new ::std::string;
  }
  return card_holder_month_;
}
inline ::std::string* CardItem::release_card_holder_month() {
  clear_has_card_holder_month();
  if (card_holder_month_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = card_holder_month_;
    card_holder_month_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CardItem::set_allocated_card_holder_month(::std::string* card_holder_month) {
  if (card_holder_month_ != &::google::protobuf::internal::kEmptyString) {
    delete card_holder_month_;
  }
  if (card_holder_month) {
    set_has_card_holder_month();
    card_holder_month_ = card_holder_month;
  } else {
    clear_has_card_holder_month();
    card_holder_month_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string card_holder_number = 3;
inline bool CardItem::has_card_holder_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CardItem::set_has_card_holder_number() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CardItem::clear_has_card_holder_number() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CardItem::clear_card_holder_number() {
  if (card_holder_number_ != &::google::protobuf::internal::kEmptyString) {
    card_holder_number_->clear();
  }
  clear_has_card_holder_number();
}
inline const ::std::string& CardItem::card_holder_number() const {
  return *card_holder_number_;
}
inline void CardItem::set_card_holder_number(const ::std::string& value) {
  set_has_card_holder_number();
  if (card_holder_number_ == &::google::protobuf::internal::kEmptyString) {
    card_holder_number_ = new ::std::string;
  }
  card_holder_number_->assign(value);
}
inline void CardItem::set_card_holder_number(const char* value) {
  set_has_card_holder_number();
  if (card_holder_number_ == &::google::protobuf::internal::kEmptyString) {
    card_holder_number_ = new ::std::string;
  }
  card_holder_number_->assign(value);
}
inline void CardItem::set_card_holder_number(const char* value, size_t size) {
  set_has_card_holder_number();
  if (card_holder_number_ == &::google::protobuf::internal::kEmptyString) {
    card_holder_number_ = new ::std::string;
  }
  card_holder_number_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CardItem::mutable_card_holder_number() {
  set_has_card_holder_number();
  if (card_holder_number_ == &::google::protobuf::internal::kEmptyString) {
    card_holder_number_ = new ::std::string;
  }
  return card_holder_number_;
}
inline ::std::string* CardItem::release_card_holder_number() {
  clear_has_card_holder_number();
  if (card_holder_number_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = card_holder_number_;
    card_holder_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CardItem::set_allocated_card_holder_number(::std::string* card_holder_number) {
  if (card_holder_number_ != &::google::protobuf::internal::kEmptyString) {
    delete card_holder_number_;
  }
  if (card_holder_number) {
    set_has_card_holder_number();
    card_holder_number_ = card_holder_number;
  } else {
    clear_has_card_holder_number();
    card_holder_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string card_holder_name = 4;
inline bool CardItem::has_card_holder_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CardItem::set_has_card_holder_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CardItem::clear_has_card_holder_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CardItem::clear_card_holder_name() {
  if (card_holder_name_ != &::google::protobuf::internal::kEmptyString) {
    card_holder_name_->clear();
  }
  clear_has_card_holder_name();
}
inline const ::std::string& CardItem::card_holder_name() const {
  return *card_holder_name_;
}
inline void CardItem::set_card_holder_name(const ::std::string& value) {
  set_has_card_holder_name();
  if (card_holder_name_ == &::google::protobuf::internal::kEmptyString) {
    card_holder_name_ = new ::std::string;
  }
  card_holder_name_->assign(value);
}
inline void CardItem::set_card_holder_name(const char* value) {
  set_has_card_holder_name();
  if (card_holder_name_ == &::google::protobuf::internal::kEmptyString) {
    card_holder_name_ = new ::std::string;
  }
  card_holder_name_->assign(value);
}
inline void CardItem::set_card_holder_name(const char* value, size_t size) {
  set_has_card_holder_name();
  if (card_holder_name_ == &::google::protobuf::internal::kEmptyString) {
    card_holder_name_ = new ::std::string;
  }
  card_holder_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CardItem::mutable_card_holder_name() {
  set_has_card_holder_name();
  if (card_holder_name_ == &::google::protobuf::internal::kEmptyString) {
    card_holder_name_ = new ::std::string;
  }
  return card_holder_name_;
}
inline ::std::string* CardItem::release_card_holder_name() {
  clear_has_card_holder_name();
  if (card_holder_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = card_holder_name_;
    card_holder_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CardItem::set_allocated_card_holder_name(::std::string* card_holder_name) {
  if (card_holder_name_ != &::google::protobuf::internal::kEmptyString) {
    delete card_holder_name_;
  }
  if (card_holder_name) {
    set_has_card_holder_name();
    card_holder_name_ = card_holder_name;
  } else {
    clear_has_card_holder_name();
    card_holder_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string bankId = 5;
inline bool CardItem::has_bankid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CardItem::set_has_bankid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CardItem::clear_has_bankid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CardItem::clear_bankid() {
  if (bankid_ != &::google::protobuf::internal::kEmptyString) {
    bankid_->clear();
  }
  clear_has_bankid();
}
inline const ::std::string& CardItem::bankid() const {
  return *bankid_;
}
inline void CardItem::set_bankid(const ::std::string& value) {
  set_has_bankid();
  if (bankid_ == &::google::protobuf::internal::kEmptyString) {
    bankid_ = new ::std::string;
  }
  bankid_->assign(value);
}
inline void CardItem::set_bankid(const char* value) {
  set_has_bankid();
  if (bankid_ == &::google::protobuf::internal::kEmptyString) {
    bankid_ = new ::std::string;
  }
  bankid_->assign(value);
}
inline void CardItem::set_bankid(const char* value, size_t size) {
  set_has_bankid();
  if (bankid_ == &::google::protobuf::internal::kEmptyString) {
    bankid_ = new ::std::string;
  }
  bankid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CardItem::mutable_bankid() {
  set_has_bankid();
  if (bankid_ == &::google::protobuf::internal::kEmptyString) {
    bankid_ = new ::std::string;
  }
  return bankid_;
}
inline ::std::string* CardItem::release_bankid() {
  clear_has_bankid();
  if (bankid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bankid_;
    bankid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CardItem::set_allocated_bankid(::std::string* bankid) {
  if (bankid_ != &::google::protobuf::internal::kEmptyString) {
    delete bankid_;
  }
  if (bankid) {
    set_has_bankid();
    bankid_ = bankid;
  } else {
    clear_has_bankid();
    bankid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 amount = 6;
inline bool CardItem::has_amount() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CardItem::set_has_amount() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CardItem::clear_has_amount() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CardItem::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 CardItem::amount() const {
  return amount_;
}
inline void CardItem::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
}

// optional uint32 locked_type = 7;
inline bool CardItem::has_locked_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CardItem::set_has_locked_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CardItem::clear_has_locked_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CardItem::clear_locked_type() {
  locked_type_ = 0u;
  clear_has_locked_type();
}
inline ::google::protobuf::uint32 CardItem::locked_type() const {
  return locked_type_;
}
inline void CardItem::set_locked_type(::google::protobuf::uint32 value) {
  set_has_locked_type();
  locked_type_ = value;
}

// optional uint32 bank_type = 8;
inline bool CardItem::has_bank_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CardItem::set_has_bank_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CardItem::clear_has_bank_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CardItem::clear_bank_type() {
  bank_type_ = 0u;
  clear_has_bank_type();
}
inline ::google::protobuf::uint32 CardItem::bank_type() const {
  return bank_type_;
}
inline void CardItem::set_bank_type(::google::protobuf::uint32 value) {
  set_has_bank_type();
  bank_type_ = value;
}

// optional string bank_name = 9;
inline bool CardItem::has_bank_name() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CardItem::set_has_bank_name() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CardItem::clear_has_bank_name() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CardItem::clear_bank_name() {
  if (bank_name_ != &::google::protobuf::internal::kEmptyString) {
    bank_name_->clear();
  }
  clear_has_bank_name();
}
inline const ::std::string& CardItem::bank_name() const {
  return *bank_name_;
}
inline void CardItem::set_bank_name(const ::std::string& value) {
  set_has_bank_name();
  if (bank_name_ == &::google::protobuf::internal::kEmptyString) {
    bank_name_ = new ::std::string;
  }
  bank_name_->assign(value);
}
inline void CardItem::set_bank_name(const char* value) {
  set_has_bank_name();
  if (bank_name_ == &::google::protobuf::internal::kEmptyString) {
    bank_name_ = new ::std::string;
  }
  bank_name_->assign(value);
}
inline void CardItem::set_bank_name(const char* value, size_t size) {
  set_has_bank_name();
  if (bank_name_ == &::google::protobuf::internal::kEmptyString) {
    bank_name_ = new ::std::string;
  }
  bank_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CardItem::mutable_bank_name() {
  set_has_bank_name();
  if (bank_name_ == &::google::protobuf::internal::kEmptyString) {
    bank_name_ = new ::std::string;
  }
  return bank_name_;
}
inline ::std::string* CardItem::release_bank_name() {
  clear_has_bank_name();
  if (bank_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bank_name_;
    bank_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CardItem::set_allocated_bank_name(::std::string* bank_name) {
  if (bank_name_ != &::google::protobuf::internal::kEmptyString) {
    delete bank_name_;
  }
  if (bank_name) {
    set_has_bank_name();
    bank_name_ = bank_name;
  } else {
    clear_has_bank_name();
    bank_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 row_id = 10;
inline bool CardItem::has_row_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CardItem::set_has_row_id() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CardItem::clear_has_row_id() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CardItem::clear_row_id() {
  row_id_ = 0u;
  clear_has_row_id();
}
inline ::google::protobuf::uint32 CardItem::row_id() const {
  return row_id_;
}
inline void CardItem::set_row_id(::google::protobuf::uint32 value) {
  set_has_row_id();
  row_id_ = value;
}

// optional uint64 last_sync_time = 11;
inline bool CardItem::has_last_sync_time() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CardItem::set_has_last_sync_time() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CardItem::clear_has_last_sync_time() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CardItem::clear_last_sync_time() {
  last_sync_time_ = GOOGLE_ULONGLONG(0);
  clear_has_last_sync_time();
}
inline ::google::protobuf::uint64 CardItem::last_sync_time() const {
  return last_sync_time_;
}
inline void CardItem::set_last_sync_time(::google::protobuf::uint64 value) {
  set_has_last_sync_time();
  last_sync_time_ = value;
}

// optional uint32 status = 12;
inline bool CardItem::has_status() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CardItem::set_has_status() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CardItem::clear_has_status() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CardItem::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 CardItem::status() const {
  return status_;
}
inline void CardItem::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
}

// optional uint32 channel = 13;
inline bool CardItem::has_channel() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CardItem::set_has_channel() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CardItem::clear_has_channel() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CardItem::clear_channel() {
  channel_ = 0u;
  clear_has_channel();
}
inline ::google::protobuf::uint32 CardItem::channel() const {
  return channel_;
}
inline void CardItem::set_channel(::google::protobuf::uint32 value) {
  set_has_channel();
  channel_ = value;
}

// optional uint32 io_city = 14;
inline bool CardItem::has_io_city() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CardItem::set_has_io_city() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CardItem::clear_has_io_city() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CardItem::clear_io_city() {
  io_city_ = 0u;
  clear_has_io_city();
}
inline ::google::protobuf::uint32 CardItem::io_city() const {
  return io_city_;
}
inline void CardItem::set_io_city(::google::protobuf::uint32 value) {
  set_has_io_city();
  io_city_ = value;
}

// optional uint32 tran_type = 15;
inline bool CardItem::has_tran_type() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CardItem::set_has_tran_type() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CardItem::clear_has_tran_type() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CardItem::clear_tran_type() {
  tran_type_ = 0u;
  clear_has_tran_type();
}
inline ::google::protobuf::uint32 CardItem::tran_type() const {
  return tran_type_;
}
inline void CardItem::set_tran_type(::google::protobuf::uint32 value) {
  set_has_tran_type();
  tran_type_ = value;
}

// optional string cardId = 16;
inline bool CardItem::has_cardid() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void CardItem::set_has_cardid() {
  _has_bits_[0] |= 0x00008000u;
}
inline void CardItem::clear_has_cardid() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void CardItem::clear_cardid() {
  if (cardid_ != &::google::protobuf::internal::kEmptyString) {
    cardid_->clear();
  }
  clear_has_cardid();
}
inline const ::std::string& CardItem::cardid() const {
  return *cardid_;
}
inline void CardItem::set_cardid(const ::std::string& value) {
  set_has_cardid();
  if (cardid_ == &::google::protobuf::internal::kEmptyString) {
    cardid_ = new ::std::string;
  }
  cardid_->assign(value);
}
inline void CardItem::set_cardid(const char* value) {
  set_has_cardid();
  if (cardid_ == &::google::protobuf::internal::kEmptyString) {
    cardid_ = new ::std::string;
  }
  cardid_->assign(value);
}
inline void CardItem::set_cardid(const char* value, size_t size) {
  set_has_cardid();
  if (cardid_ == &::google::protobuf::internal::kEmptyString) {
    cardid_ = new ::std::string;
  }
  cardid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CardItem::mutable_cardid() {
  set_has_cardid();
  if (cardid_ == &::google::protobuf::internal::kEmptyString) {
    cardid_ = new ::std::string;
  }
  return cardid_;
}
inline ::std::string* CardItem::release_cardid() {
  clear_has_cardid();
  if (cardid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cardid_;
    cardid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CardItem::set_allocated_cardid(::std::string* cardid) {
  if (cardid_ != &::google::protobuf::internal::kEmptyString) {
    delete cardid_;
  }
  if (cardid) {
    set_has_cardid();
    cardid_ = cardid;
  } else {
    clear_has_cardid();
    cardid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string cardType = 17;
inline bool CardItem::has_cardtype() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void CardItem::set_has_cardtype() {
  _has_bits_[0] |= 0x00010000u;
}
inline void CardItem::clear_has_cardtype() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void CardItem::clear_cardtype() {
  if (cardtype_ != &::google::protobuf::internal::kEmptyString) {
    cardtype_->clear();
  }
  clear_has_cardtype();
}
inline const ::std::string& CardItem::cardtype() const {
  return *cardtype_;
}
inline void CardItem::set_cardtype(const ::std::string& value) {
  set_has_cardtype();
  if (cardtype_ == &::google::protobuf::internal::kEmptyString) {
    cardtype_ = new ::std::string;
  }
  cardtype_->assign(value);
}
inline void CardItem::set_cardtype(const char* value) {
  set_has_cardtype();
  if (cardtype_ == &::google::protobuf::internal::kEmptyString) {
    cardtype_ = new ::std::string;
  }
  cardtype_->assign(value);
}
inline void CardItem::set_cardtype(const char* value, size_t size) {
  set_has_cardtype();
  if (cardtype_ == &::google::protobuf::internal::kEmptyString) {
    cardtype_ = new ::std::string;
  }
  cardtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CardItem::mutable_cardtype() {
  set_has_cardtype();
  if (cardtype_ == &::google::protobuf::internal::kEmptyString) {
    cardtype_ = new ::std::string;
  }
  return cardtype_;
}
inline ::std::string* CardItem::release_cardtype() {
  clear_has_cardtype();
  if (cardtype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cardtype_;
    cardtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CardItem::set_allocated_cardtype(::std::string* cardtype) {
  if (cardtype_ != &::google::protobuf::internal::kEmptyString) {
    delete cardtype_;
  }
  if (cardtype) {
    set_has_cardtype();
    cardtype_ = cardtype;
  } else {
    clear_has_cardtype();
    cardtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CardAddOrUpdate

// repeated .com.mservice.momo.msg.CardItem card_list = 1;
inline int CardAddOrUpdate::card_list_size() const {
  return card_list_.size();
}
inline void CardAddOrUpdate::clear_card_list() {
  card_list_.Clear();
}
inline const ::com::mservice::momo::msg::CardItem& CardAddOrUpdate::card_list(int index) const {
  return card_list_.Get(index);
}
inline ::com::mservice::momo::msg::CardItem* CardAddOrUpdate::mutable_card_list(int index) {
  return card_list_.Mutable(index);
}
inline ::com::mservice::momo::msg::CardItem* CardAddOrUpdate::add_card_list() {
  return card_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::CardItem >&
CardAddOrUpdate::card_list() const {
  return card_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::CardItem >*
CardAddOrUpdate::mutable_card_list() {
  return &card_list_;
}

// -------------------------------------------------------------------

// CardAddOrUpdateReply

// repeated .com.mservice.momo.msg.CardItem bank_net_to_momo_list = 1;
inline int CardAddOrUpdateReply::bank_net_to_momo_list_size() const {
  return bank_net_to_momo_list_.size();
}
inline void CardAddOrUpdateReply::clear_bank_net_to_momo_list() {
  bank_net_to_momo_list_.Clear();
}
inline const ::com::mservice::momo::msg::CardItem& CardAddOrUpdateReply::bank_net_to_momo_list(int index) const {
  return bank_net_to_momo_list_.Get(index);
}
inline ::com::mservice::momo::msg::CardItem* CardAddOrUpdateReply::mutable_bank_net_to_momo_list(int index) {
  return bank_net_to_momo_list_.Mutable(index);
}
inline ::com::mservice::momo::msg::CardItem* CardAddOrUpdateReply::add_bank_net_to_momo_list() {
  return bank_net_to_momo_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::CardItem >&
CardAddOrUpdateReply::bank_net_to_momo_list() const {
  return bank_net_to_momo_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::CardItem >*
CardAddOrUpdateReply::mutable_bank_net_to_momo_list() {
  return &bank_net_to_momo_list_;
}

// -------------------------------------------------------------------

// CardSyncFirstTimeReply

// repeated .com.mservice.momo.msg.CardItem CardList = 1;
inline int CardSyncFirstTimeReply::cardlist_size() const {
  return cardlist_.size();
}
inline void CardSyncFirstTimeReply::clear_cardlist() {
  cardlist_.Clear();
}
inline const ::com::mservice::momo::msg::CardItem& CardSyncFirstTimeReply::cardlist(int index) const {
  return cardlist_.Get(index);
}
inline ::com::mservice::momo::msg::CardItem* CardSyncFirstTimeReply::mutable_cardlist(int index) {
  return cardlist_.Mutable(index);
}
inline ::com::mservice::momo::msg::CardItem* CardSyncFirstTimeReply::add_cardlist() {
  return cardlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::CardItem >&
CardSyncFirstTimeReply::cardlist() const {
  return cardlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::CardItem >*
CardSyncFirstTimeReply::mutable_cardlist() {
  return &cardlist_;
}

// -------------------------------------------------------------------

// TranHisSyncReply

// optional bool result = 1;
inline bool TranHisSyncReply::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TranHisSyncReply::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TranHisSyncReply::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TranHisSyncReply::clear_result() {
  result_ = false;
  clear_has_result();
}
inline bool TranHisSyncReply::result() const {
  return result_;
}
inline void TranHisSyncReply::set_result(bool value) {
  set_has_result();
  result_ = value;
}

// repeated .com.mservice.momo.msg.TranHisV1 TranList = 2;
inline int TranHisSyncReply::tranlist_size() const {
  return tranlist_.size();
}
inline void TranHisSyncReply::clear_tranlist() {
  tranlist_.Clear();
}
inline const ::com::mservice::momo::msg::TranHisV1& TranHisSyncReply::tranlist(int index) const {
  return tranlist_.Get(index);
}
inline ::com::mservice::momo::msg::TranHisV1* TranHisSyncReply::mutable_tranlist(int index) {
  return tranlist_.Mutable(index);
}
inline ::com::mservice::momo::msg::TranHisV1* TranHisSyncReply::add_tranlist() {
  return tranlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::TranHisV1 >&
TranHisSyncReply::tranlist() const {
  return tranlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::TranHisV1 >*
TranHisSyncReply::mutable_tranlist() {
  return &tranlist_;
}

// -------------------------------------------------------------------

// Bill

// optional string providerId = 1;
inline bool Bill::has_providerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Bill::set_has_providerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Bill::clear_has_providerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Bill::clear_providerid() {
  if (providerid_ != &::google::protobuf::internal::kEmptyString) {
    providerid_->clear();
  }
  clear_has_providerid();
}
inline const ::std::string& Bill::providerid() const {
  return *providerid_;
}
inline void Bill::set_providerid(const ::std::string& value) {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  providerid_->assign(value);
}
inline void Bill::set_providerid(const char* value) {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  providerid_->assign(value);
}
inline void Bill::set_providerid(const char* value, size_t size) {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  providerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Bill::mutable_providerid() {
  set_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    providerid_ = new ::std::string;
  }
  return providerid_;
}
inline ::std::string* Bill::release_providerid() {
  clear_has_providerid();
  if (providerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = providerid_;
    providerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Bill::set_allocated_providerid(::std::string* providerid) {
  if (providerid_ != &::google::protobuf::internal::kEmptyString) {
    delete providerid_;
  }
  if (providerid) {
    set_has_providerid();
    providerid_ = providerid;
  } else {
    clear_has_providerid();
    providerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string billId = 2;
inline bool Bill::has_billid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Bill::set_has_billid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Bill::clear_has_billid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Bill::clear_billid() {
  if (billid_ != &::google::protobuf::internal::kEmptyString) {
    billid_->clear();
  }
  clear_has_billid();
}
inline const ::std::string& Bill::billid() const {
  return *billid_;
}
inline void Bill::set_billid(const ::std::string& value) {
  set_has_billid();
  if (billid_ == &::google::protobuf::internal::kEmptyString) {
    billid_ = new ::std::string;
  }
  billid_->assign(value);
}
inline void Bill::set_billid(const char* value) {
  set_has_billid();
  if (billid_ == &::google::protobuf::internal::kEmptyString) {
    billid_ = new ::std::string;
  }
  billid_->assign(value);
}
inline void Bill::set_billid(const char* value, size_t size) {
  set_has_billid();
  if (billid_ == &::google::protobuf::internal::kEmptyString) {
    billid_ = new ::std::string;
  }
  billid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Bill::mutable_billid() {
  set_has_billid();
  if (billid_ == &::google::protobuf::internal::kEmptyString) {
    billid_ = new ::std::string;
  }
  return billid_;
}
inline ::std::string* Bill::release_billid() {
  clear_has_billid();
  if (billid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = billid_;
    billid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Bill::set_allocated_billid(::std::string* billid) {
  if (billid_ != &::google::protobuf::internal::kEmptyString) {
    delete billid_;
  }
  if (billid) {
    set_has_billid();
    billid_ = billid;
  } else {
    clear_has_billid();
    billid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RemoveSavedBill

// repeated .com.mservice.momo.msg.Bill bills = 1;
inline int RemoveSavedBill::bills_size() const {
  return bills_.size();
}
inline void RemoveSavedBill::clear_bills() {
  bills_.Clear();
}
inline const ::com::mservice::momo::msg::Bill& RemoveSavedBill::bills(int index) const {
  return bills_.Get(index);
}
inline ::com::mservice::momo::msg::Bill* RemoveSavedBill::mutable_bills(int index) {
  return bills_.Mutable(index);
}
inline ::com::mservice::momo::msg::Bill* RemoveSavedBill::add_bills() {
  return bills_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::Bill >&
RemoveSavedBill::bills() const {
  return bills_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::Bill >*
RemoveSavedBill::mutable_bills() {
  return &bills_;
}

// -------------------------------------------------------------------

// RemoveSavedBillReply

// optional .com.mservice.momo.msg.RemoveSavedBillReply.Result result = 1;
inline bool RemoveSavedBillReply::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemoveSavedBillReply::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RemoveSavedBillReply::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RemoveSavedBillReply::clear_result() {
  result_ = 1;
  clear_has_result();
}
inline ::com::mservice::momo::msg::RemoveSavedBillReply_Result RemoveSavedBillReply::result() const {
  return static_cast< ::com::mservice::momo::msg::RemoveSavedBillReply_Result >(result_);
}
inline void RemoveSavedBillReply::set_result(::com::mservice::momo::msg::RemoveSavedBillReply_Result value) {
  assert(::com::mservice::momo::msg::RemoveSavedBillReply_Result_IsValid(value));
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// Notification

// optional string id = 1;
inline bool Notification::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Notification::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Notification::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Notification::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Notification::id() const {
  return *id_;
}
inline void Notification::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Notification::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Notification::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Notification::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* Notification::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Notification::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 priority = 2;
inline bool Notification::has_priority() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Notification::set_has_priority() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Notification::clear_has_priority() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Notification::clear_priority() {
  priority_ = 0u;
  clear_has_priority();
}
inline ::google::protobuf::uint32 Notification::priority() const {
  return priority_;
}
inline void Notification::set_priority(::google::protobuf::uint32 value) {
  set_has_priority();
  priority_ = value;
}

// optional uint32 type = 3;
inline bool Notification::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Notification::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Notification::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Notification::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 Notification::type() const {
  return type_;
}
inline void Notification::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional string caption = 4;
inline bool Notification::has_caption() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Notification::set_has_caption() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Notification::clear_has_caption() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Notification::clear_caption() {
  if (caption_ != &::google::protobuf::internal::kEmptyString) {
    caption_->clear();
  }
  clear_has_caption();
}
inline const ::std::string& Notification::caption() const {
  return *caption_;
}
inline void Notification::set_caption(const ::std::string& value) {
  set_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    caption_ = new ::std::string;
  }
  caption_->assign(value);
}
inline void Notification::set_caption(const char* value) {
  set_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    caption_ = new ::std::string;
  }
  caption_->assign(value);
}
inline void Notification::set_caption(const char* value, size_t size) {
  set_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    caption_ = new ::std::string;
  }
  caption_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Notification::mutable_caption() {
  set_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    caption_ = new ::std::string;
  }
  return caption_;
}
inline ::std::string* Notification::release_caption() {
  clear_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = caption_;
    caption_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Notification::set_allocated_caption(::std::string* caption) {
  if (caption_ != &::google::protobuf::internal::kEmptyString) {
    delete caption_;
  }
  if (caption) {
    set_has_caption();
    caption_ = caption;
  } else {
    clear_has_caption();
    caption_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string body = 5;
inline bool Notification::has_body() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Notification::set_has_body() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Notification::clear_has_body() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Notification::clear_body() {
  if (body_ != &::google::protobuf::internal::kEmptyString) {
    body_->clear();
  }
  clear_has_body();
}
inline const ::std::string& Notification::body() const {
  return *body_;
}
inline void Notification::set_body(const ::std::string& value) {
  set_has_body();
  if (body_ == &::google::protobuf::internal::kEmptyString) {
    body_ = new ::std::string;
  }
  body_->assign(value);
}
inline void Notification::set_body(const char* value) {
  set_has_body();
  if (body_ == &::google::protobuf::internal::kEmptyString) {
    body_ = new ::std::string;
  }
  body_->assign(value);
}
inline void Notification::set_body(const char* value, size_t size) {
  set_has_body();
  if (body_ == &::google::protobuf::internal::kEmptyString) {
    body_ = new ::std::string;
  }
  body_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Notification::mutable_body() {
  set_has_body();
  if (body_ == &::google::protobuf::internal::kEmptyString) {
    body_ = new ::std::string;
  }
  return body_;
}
inline ::std::string* Notification::release_body() {
  clear_has_body();
  if (body_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = body_;
    body_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Notification::set_allocated_body(::std::string* body) {
  if (body_ != &::google::protobuf::internal::kEmptyString) {
    delete body_;
  }
  if (body) {
    set_has_body();
    body_ = body;
  } else {
    clear_has_body();
    body_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 tranId = 6;
inline bool Notification::has_tranid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Notification::set_has_tranid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Notification::clear_has_tranid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Notification::clear_tranid() {
  tranid_ = GOOGLE_ULONGLONG(0);
  clear_has_tranid();
}
inline ::google::protobuf::uint64 Notification::tranid() const {
  return tranid_;
}
inline void Notification::set_tranid(::google::protobuf::uint64 value) {
  set_has_tranid();
  tranid_ = value;
}

// optional uint64 cmdId = 7;
inline bool Notification::has_cmdid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Notification::set_has_cmdid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Notification::clear_has_cmdid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Notification::clear_cmdid() {
  cmdid_ = GOOGLE_ULONGLONG(0);
  clear_has_cmdid();
}
inline ::google::protobuf::uint64 Notification::cmdid() const {
  return cmdid_;
}
inline void Notification::set_cmdid(::google::protobuf::uint64 value) {
  set_has_cmdid();
  cmdid_ = value;
}

// optional uint64 time = 8;
inline bool Notification::has_time() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Notification::set_has_time() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Notification::clear_has_time() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Notification::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::uint64 Notification::time() const {
  return time_;
}
inline void Notification::set_time(::google::protobuf::uint64 value) {
  set_has_time();
  time_ = value;
}

// optional uint32 sender = 9;
inline bool Notification::has_sender() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Notification::set_has_sender() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Notification::clear_has_sender() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Notification::clear_sender() {
  sender_ = 0u;
  clear_has_sender();
}
inline ::google::protobuf::uint32 Notification::sender() const {
  return sender_;
}
inline void Notification::set_sender(::google::protobuf::uint32 value) {
  set_has_sender();
  sender_ = value;
}

// optional uint32 status = 10;
inline bool Notification::has_status() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Notification::set_has_status() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Notification::clear_has_status() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Notification::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 Notification::status() const {
  return status_;
}
inline void Notification::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
}

// optional uint32 tranHisType = 11;
inline bool Notification::has_tranhistype() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Notification::set_has_tranhistype() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Notification::clear_has_tranhistype() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Notification::clear_tranhistype() {
  tranhistype_ = 0u;
  clear_has_tranhistype();
}
inline ::google::protobuf::uint32 Notification::tranhistype() const {
  return tranhistype_;
}
inline void Notification::set_tranhistype(::google::protobuf::uint32 value) {
  set_has_tranhistype();
  tranhistype_ = value;
}

// optional string refId = 12;
inline bool Notification::has_refid() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Notification::set_has_refid() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Notification::clear_has_refid() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Notification::clear_refid() {
  if (refid_ != &::google::protobuf::internal::kEmptyString) {
    refid_->clear();
  }
  clear_has_refid();
}
inline const ::std::string& Notification::refid() const {
  return *refid_;
}
inline void Notification::set_refid(const ::std::string& value) {
  set_has_refid();
  if (refid_ == &::google::protobuf::internal::kEmptyString) {
    refid_ = new ::std::string;
  }
  refid_->assign(value);
}
inline void Notification::set_refid(const char* value) {
  set_has_refid();
  if (refid_ == &::google::protobuf::internal::kEmptyString) {
    refid_ = new ::std::string;
  }
  refid_->assign(value);
}
inline void Notification::set_refid(const char* value, size_t size) {
  set_has_refid();
  if (refid_ == &::google::protobuf::internal::kEmptyString) {
    refid_ = new ::std::string;
  }
  refid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Notification::mutable_refid() {
  set_has_refid();
  if (refid_ == &::google::protobuf::internal::kEmptyString) {
    refid_ = new ::std::string;
  }
  return refid_;
}
inline ::std::string* Notification::release_refid() {
  clear_has_refid();
  if (refid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = refid_;
    refid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Notification::set_allocated_refid(::std::string* refid) {
  if (refid_ != &::google::protobuf::internal::kEmptyString) {
    delete refid_;
  }
  if (refid) {
    set_has_refid();
    refid_ = refid;
  } else {
    clear_has_refid();
    refid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string btnTitle = 13;
inline bool Notification::has_btntitle() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Notification::set_has_btntitle() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Notification::clear_has_btntitle() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Notification::clear_btntitle() {
  if (btntitle_ != &::google::protobuf::internal::kEmptyString) {
    btntitle_->clear();
  }
  clear_has_btntitle();
}
inline const ::std::string& Notification::btntitle() const {
  return *btntitle_;
}
inline void Notification::set_btntitle(const ::std::string& value) {
  set_has_btntitle();
  if (btntitle_ == &::google::protobuf::internal::kEmptyString) {
    btntitle_ = new ::std::string;
  }
  btntitle_->assign(value);
}
inline void Notification::set_btntitle(const char* value) {
  set_has_btntitle();
  if (btntitle_ == &::google::protobuf::internal::kEmptyString) {
    btntitle_ = new ::std::string;
  }
  btntitle_->assign(value);
}
inline void Notification::set_btntitle(const char* value, size_t size) {
  set_has_btntitle();
  if (btntitle_ == &::google::protobuf::internal::kEmptyString) {
    btntitle_ = new ::std::string;
  }
  btntitle_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Notification::mutable_btntitle() {
  set_has_btntitle();
  if (btntitle_ == &::google::protobuf::internal::kEmptyString) {
    btntitle_ = new ::std::string;
  }
  return btntitle_;
}
inline ::std::string* Notification::release_btntitle() {
  clear_has_btntitle();
  if (btntitle_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = btntitle_;
    btntitle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Notification::set_allocated_btntitle(::std::string* btntitle) {
  if (btntitle_ != &::google::protobuf::internal::kEmptyString) {
    delete btntitle_;
  }
  if (btntitle) {
    set_has_btntitle();
    btntitle_ = btntitle;
  } else {
    clear_has_btntitle();
    btntitle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 btnStatus = 14;
inline bool Notification::has_btnstatus() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Notification::set_has_btnstatus() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Notification::clear_has_btnstatus() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Notification::clear_btnstatus() {
  btnstatus_ = 0u;
  clear_has_btnstatus();
}
inline ::google::protobuf::uint32 Notification::btnstatus() const {
  return btnstatus_;
}
inline void Notification::set_btnstatus(::google::protobuf::uint32 value) {
  set_has_btnstatus();
  btnstatus_ = value;
}

// optional string htmlBody = 15;
inline bool Notification::has_htmlbody() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Notification::set_has_htmlbody() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Notification::clear_has_htmlbody() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Notification::clear_htmlbody() {
  if (htmlbody_ != &::google::protobuf::internal::kEmptyString) {
    htmlbody_->clear();
  }
  clear_has_htmlbody();
}
inline const ::std::string& Notification::htmlbody() const {
  return *htmlbody_;
}
inline void Notification::set_htmlbody(const ::std::string& value) {
  set_has_htmlbody();
  if (htmlbody_ == &::google::protobuf::internal::kEmptyString) {
    htmlbody_ = new ::std::string;
  }
  htmlbody_->assign(value);
}
inline void Notification::set_htmlbody(const char* value) {
  set_has_htmlbody();
  if (htmlbody_ == &::google::protobuf::internal::kEmptyString) {
    htmlbody_ = new ::std::string;
  }
  htmlbody_->assign(value);
}
inline void Notification::set_htmlbody(const char* value, size_t size) {
  set_has_htmlbody();
  if (htmlbody_ == &::google::protobuf::internal::kEmptyString) {
    htmlbody_ = new ::std::string;
  }
  htmlbody_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Notification::mutable_htmlbody() {
  set_has_htmlbody();
  if (htmlbody_ == &::google::protobuf::internal::kEmptyString) {
    htmlbody_ = new ::std::string;
  }
  return htmlbody_;
}
inline ::std::string* Notification::release_htmlbody() {
  clear_has_htmlbody();
  if (htmlbody_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = htmlbody_;
    htmlbody_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Notification::set_allocated_htmlbody(::std::string* htmlbody) {
  if (htmlbody_ != &::google::protobuf::internal::kEmptyString) {
    delete htmlbody_;
  }
  if (htmlbody) {
    set_has_htmlbody();
    htmlbody_ = htmlbody;
  } else {
    clear_has_htmlbody();
    htmlbody_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string extra = 16;
inline bool Notification::has_extra() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Notification::set_has_extra() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Notification::clear_has_extra() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Notification::clear_extra() {
  if (extra_ != &::google::protobuf::internal::kEmptyString) {
    extra_->clear();
  }
  clear_has_extra();
}
inline const ::std::string& Notification::extra() const {
  return *extra_;
}
inline void Notification::set_extra(const ::std::string& value) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  extra_->assign(value);
}
inline void Notification::set_extra(const char* value) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  extra_->assign(value);
}
inline void Notification::set_extra(const char* value, size_t size) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  extra_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Notification::mutable_extra() {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  return extra_;
}
inline ::std::string* Notification::release_extra() {
  clear_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extra_;
    extra_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Notification::set_allocated_extra(::std::string* extra) {
  if (extra_ != &::google::protobuf::internal::kEmptyString) {
    delete extra_;
  }
  if (extra) {
    set_has_extra();
    extra_ = extra;
  } else {
    clear_has_extra();
    extra_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 category = 17;
inline bool Notification::has_category() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Notification::set_has_category() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Notification::clear_has_category() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Notification::clear_category() {
  category_ = 0u;
  clear_has_category();
}
inline ::google::protobuf::uint32 Notification::category() const {
  return category_;
}
inline void Notification::set_category(::google::protobuf::uint32 value) {
  set_has_category();
  category_ = value;
}

// -------------------------------------------------------------------

// UpdateNotificationsStatus

// repeated .com.mservice.momo.msg.Notification notifications = 1;
inline int UpdateNotificationsStatus::notifications_size() const {
  return notifications_.size();
}
inline void UpdateNotificationsStatus::clear_notifications() {
  notifications_.Clear();
}
inline const ::com::mservice::momo::msg::Notification& UpdateNotificationsStatus::notifications(int index) const {
  return notifications_.Get(index);
}
inline ::com::mservice::momo::msg::Notification* UpdateNotificationsStatus::mutable_notifications(int index) {
  return notifications_.Mutable(index);
}
inline ::com::mservice::momo::msg::Notification* UpdateNotificationsStatus::add_notifications() {
  return notifications_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::Notification >&
UpdateNotificationsStatus::notifications() const {
  return notifications_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::Notification >*
UpdateNotificationsStatus::mutable_notifications() {
  return &notifications_;
}

// optional uint32 flag = 2;
inline bool UpdateNotificationsStatus::has_flag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateNotificationsStatus::set_has_flag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateNotificationsStatus::clear_has_flag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateNotificationsStatus::clear_flag() {
  flag_ = 0u;
  clear_has_flag();
}
inline ::google::protobuf::uint32 UpdateNotificationsStatus::flag() const {
  return flag_;
}
inline void UpdateNotificationsStatus::set_flag(::google::protobuf::uint32 value) {
  set_has_flag();
  flag_ = value;
}

// -------------------------------------------------------------------

// UpdateNotificationsStatusReply

// repeated .com.mservice.momo.msg.Notification notifications = 1;
inline int UpdateNotificationsStatusReply::notifications_size() const {
  return notifications_.size();
}
inline void UpdateNotificationsStatusReply::clear_notifications() {
  notifications_.Clear();
}
inline const ::com::mservice::momo::msg::Notification& UpdateNotificationsStatusReply::notifications(int index) const {
  return notifications_.Get(index);
}
inline ::com::mservice::momo::msg::Notification* UpdateNotificationsStatusReply::mutable_notifications(int index) {
  return notifications_.Mutable(index);
}
inline ::com::mservice::momo::msg::Notification* UpdateNotificationsStatusReply::add_notifications() {
  return notifications_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::Notification >&
UpdateNotificationsStatusReply::notifications() const {
  return notifications_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::Notification >*
UpdateNotificationsStatusReply::mutable_notifications() {
  return &notifications_;
}

// optional uint32 flag = 2;
inline bool UpdateNotificationsStatusReply::has_flag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateNotificationsStatusReply::set_has_flag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateNotificationsStatusReply::clear_has_flag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateNotificationsStatusReply::clear_flag() {
  flag_ = 0u;
  clear_has_flag();
}
inline ::google::protobuf::uint32 UpdateNotificationsStatusReply::flag() const {
  return flag_;
}
inline void UpdateNotificationsStatusReply::set_flag(::google::protobuf::uint32 value) {
  set_has_flag();
  flag_ = value;
}

// -------------------------------------------------------------------

// NotificationSyncReply

// repeated .com.mservice.momo.msg.Notification notifications = 1;
inline int NotificationSyncReply::notifications_size() const {
  return notifications_.size();
}
inline void NotificationSyncReply::clear_notifications() {
  notifications_.Clear();
}
inline const ::com::mservice::momo::msg::Notification& NotificationSyncReply::notifications(int index) const {
  return notifications_.Get(index);
}
inline ::com::mservice::momo::msg::Notification* NotificationSyncReply::mutable_notifications(int index) {
  return notifications_.Mutable(index);
}
inline ::com::mservice::momo::msg::Notification* NotificationSyncReply::add_notifications() {
  return notifications_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::Notification >&
NotificationSyncReply::notifications() const {
  return notifications_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::Notification >*
NotificationSyncReply::mutable_notifications() {
  return &notifications_;
}

// -------------------------------------------------------------------

// NotificationNew

// optional .com.mservice.momo.msg.Notification notification = 1;
inline bool NotificationNew::has_notification() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NotificationNew::set_has_notification() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NotificationNew::clear_has_notification() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NotificationNew::clear_notification() {
  if (notification_ != NULL) notification_->::com::mservice::momo::msg::Notification::Clear();
  clear_has_notification();
}
inline const ::com::mservice::momo::msg::Notification& NotificationNew::notification() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return notification_ != NULL ? *notification_ : *default_instance().notification_;
#else
  return notification_ != NULL ? *notification_ : *default_instance_->notification_;
#endif
}
inline ::com::mservice::momo::msg::Notification* NotificationNew::mutable_notification() {
  set_has_notification();
  if (notification_ == NULL) notification_ = new ::com::mservice::momo::msg::Notification;
  return notification_;
}
inline ::com::mservice::momo::msg::Notification* NotificationNew::release_notification() {
  clear_has_notification();
  ::com::mservice::momo::msg::Notification* temp = notification_;
  notification_ = NULL;
  return temp;
}
inline void NotificationNew::set_allocated_notification(::com::mservice::momo::msg::Notification* notification) {
  delete notification_;
  notification_ = notification;
  if (notification) {
    set_has_notification();
  } else {
    clear_has_notification();
  }
}

// -------------------------------------------------------------------

// NotificationReceived

// optional string notificationId = 1;
inline bool NotificationReceived::has_notificationid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NotificationReceived::set_has_notificationid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NotificationReceived::clear_has_notificationid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NotificationReceived::clear_notificationid() {
  if (notificationid_ != &::google::protobuf::internal::kEmptyString) {
    notificationid_->clear();
  }
  clear_has_notificationid();
}
inline const ::std::string& NotificationReceived::notificationid() const {
  return *notificationid_;
}
inline void NotificationReceived::set_notificationid(const ::std::string& value) {
  set_has_notificationid();
  if (notificationid_ == &::google::protobuf::internal::kEmptyString) {
    notificationid_ = new ::std::string;
  }
  notificationid_->assign(value);
}
inline void NotificationReceived::set_notificationid(const char* value) {
  set_has_notificationid();
  if (notificationid_ == &::google::protobuf::internal::kEmptyString) {
    notificationid_ = new ::std::string;
  }
  notificationid_->assign(value);
}
inline void NotificationReceived::set_notificationid(const char* value, size_t size) {
  set_has_notificationid();
  if (notificationid_ == &::google::protobuf::internal::kEmptyString) {
    notificationid_ = new ::std::string;
  }
  notificationid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NotificationReceived::mutable_notificationid() {
  set_has_notificationid();
  if (notificationid_ == &::google::protobuf::internal::kEmptyString) {
    notificationid_ = new ::std::string;
  }
  return notificationid_;
}
inline ::std::string* NotificationReceived::release_notificationid() {
  clear_has_notificationid();
  if (notificationid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = notificationid_;
    notificationid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NotificationReceived::set_allocated_notificationid(::std::string* notificationid) {
  if (notificationid_ != &::google::protobuf::internal::kEmptyString) {
    delete notificationid_;
  }
  if (notificationid) {
    set_has_notificationid();
    notificationid_ = notificationid;
  } else {
    clear_has_notificationid();
    notificationid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .com.mservice.momo.msg.Notification noti = 2;
inline int NotificationReceived::noti_size() const {
  return noti_.size();
}
inline void NotificationReceived::clear_noti() {
  noti_.Clear();
}
inline const ::com::mservice::momo::msg::Notification& NotificationReceived::noti(int index) const {
  return noti_.Get(index);
}
inline ::com::mservice::momo::msg::Notification* NotificationReceived::mutable_noti(int index) {
  return noti_.Mutable(index);
}
inline ::com::mservice::momo::msg::Notification* NotificationReceived::add_noti() {
  return noti_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::Notification >&
NotificationReceived::noti() const {
  return noti_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::Notification >*
NotificationReceived::mutable_noti() {
  return &noti_;
}

// -------------------------------------------------------------------

// GetNotification

// optional string notiId = 1;
inline bool GetNotification::has_notiid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetNotification::set_has_notiid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetNotification::clear_has_notiid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetNotification::clear_notiid() {
  if (notiid_ != &::google::protobuf::internal::kEmptyString) {
    notiid_->clear();
  }
  clear_has_notiid();
}
inline const ::std::string& GetNotification::notiid() const {
  return *notiid_;
}
inline void GetNotification::set_notiid(const ::std::string& value) {
  set_has_notiid();
  if (notiid_ == &::google::protobuf::internal::kEmptyString) {
    notiid_ = new ::std::string;
  }
  notiid_->assign(value);
}
inline void GetNotification::set_notiid(const char* value) {
  set_has_notiid();
  if (notiid_ == &::google::protobuf::internal::kEmptyString) {
    notiid_ = new ::std::string;
  }
  notiid_->assign(value);
}
inline void GetNotification::set_notiid(const char* value, size_t size) {
  set_has_notiid();
  if (notiid_ == &::google::protobuf::internal::kEmptyString) {
    notiid_ = new ::std::string;
  }
  notiid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetNotification::mutable_notiid() {
  set_has_notiid();
  if (notiid_ == &::google::protobuf::internal::kEmptyString) {
    notiid_ = new ::std::string;
  }
  return notiid_;
}
inline ::std::string* GetNotification::release_notiid() {
  clear_has_notiid();
  if (notiid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = notiid_;
    notiid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetNotification::set_allocated_notiid(::std::string* notiid) {
  if (notiid_ != &::google::protobuf::internal::kEmptyString) {
    delete notiid_;
  }
  if (notiid) {
    set_has_notiid();
    notiid_ = notiid;
  } else {
    clear_has_notiid();
    notiid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GetNotificationReply

// optional .com.mservice.momo.msg.Notification noti = 1;
inline bool GetNotificationReply::has_noti() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetNotificationReply::set_has_noti() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetNotificationReply::clear_has_noti() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetNotificationReply::clear_noti() {
  if (noti_ != NULL) noti_->::com::mservice::momo::msg::Notification::Clear();
  clear_has_noti();
}
inline const ::com::mservice::momo::msg::Notification& GetNotificationReply::noti() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return noti_ != NULL ? *noti_ : *default_instance().noti_;
#else
  return noti_ != NULL ? *noti_ : *default_instance_->noti_;
#endif
}
inline ::com::mservice::momo::msg::Notification* GetNotificationReply::mutable_noti() {
  set_has_noti();
  if (noti_ == NULL) noti_ = new ::com::mservice::momo::msg::Notification;
  return noti_;
}
inline ::com::mservice::momo::msg::Notification* GetNotificationReply::release_noti() {
  clear_has_noti();
  ::com::mservice::momo::msg::Notification* temp = noti_;
  noti_ = NULL;
  return temp;
}
inline void GetNotificationReply::set_allocated_noti(::com::mservice::momo::msg::Notification* noti) {
  delete noti_;
  noti_ = noti;
  if (noti) {
    set_has_noti();
  } else {
    clear_has_noti();
  }
}

// -------------------------------------------------------------------

// Avatar

// optional string byte_string = 1;
inline bool Avatar::has_byte_string() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Avatar::set_has_byte_string() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Avatar::clear_has_byte_string() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Avatar::clear_byte_string() {
  if (byte_string_ != &::google::protobuf::internal::kEmptyString) {
    byte_string_->clear();
  }
  clear_has_byte_string();
}
inline const ::std::string& Avatar::byte_string() const {
  return *byte_string_;
}
inline void Avatar::set_byte_string(const ::std::string& value) {
  set_has_byte_string();
  if (byte_string_ == &::google::protobuf::internal::kEmptyString) {
    byte_string_ = new ::std::string;
  }
  byte_string_->assign(value);
}
inline void Avatar::set_byte_string(const char* value) {
  set_has_byte_string();
  if (byte_string_ == &::google::protobuf::internal::kEmptyString) {
    byte_string_ = new ::std::string;
  }
  byte_string_->assign(value);
}
inline void Avatar::set_byte_string(const char* value, size_t size) {
  set_has_byte_string();
  if (byte_string_ == &::google::protobuf::internal::kEmptyString) {
    byte_string_ = new ::std::string;
  }
  byte_string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Avatar::mutable_byte_string() {
  set_has_byte_string();
  if (byte_string_ == &::google::protobuf::internal::kEmptyString) {
    byte_string_ = new ::std::string;
  }
  return byte_string_;
}
inline ::std::string* Avatar::release_byte_string() {
  clear_has_byte_string();
  if (byte_string_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = byte_string_;
    byte_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Avatar::set_allocated_byte_string(::std::string* byte_string) {
  if (byte_string_ != &::google::protobuf::internal::kEmptyString) {
    delete byte_string_;
  }
  if (byte_string) {
    set_has_byte_string();
    byte_string_ = byte_string;
  } else {
    clear_has_byte_string();
    byte_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AvatarReply

// optional bool result = 1;
inline bool AvatarReply::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AvatarReply::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AvatarReply::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AvatarReply::clear_result() {
  result_ = false;
  clear_has_result();
}
inline bool AvatarReply::result() const {
  return result_;
}
inline void AvatarReply::set_result(bool value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// AvatarUploadReply

// optional string token = 1;
inline bool AvatarUploadReply::has_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AvatarUploadReply::set_has_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AvatarUploadReply::clear_has_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AvatarUploadReply::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& AvatarUploadReply::token() const {
  return *token_;
}
inline void AvatarUploadReply::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void AvatarUploadReply::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void AvatarUploadReply::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AvatarUploadReply::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* AvatarUploadReply::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AvatarUploadReply::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GetDynamicConfig

// optional string name = 1;
inline bool GetDynamicConfig::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetDynamicConfig::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetDynamicConfig::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetDynamicConfig::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& GetDynamicConfig::name() const {
  return *name_;
}
inline void GetDynamicConfig::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void GetDynamicConfig::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void GetDynamicConfig::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetDynamicConfig::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* GetDynamicConfig::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetDynamicConfig::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GetDynamicConfigReply

// optional string name = 1;
inline bool GetDynamicConfigReply::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetDynamicConfigReply::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetDynamicConfigReply::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetDynamicConfigReply::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& GetDynamicConfigReply::name() const {
  return *name_;
}
inline void GetDynamicConfigReply::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void GetDynamicConfigReply::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void GetDynamicConfigReply::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetDynamicConfigReply::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* GetDynamicConfigReply::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetDynamicConfigReply::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string value = 2;
inline bool GetDynamicConfigReply::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetDynamicConfigReply::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetDynamicConfigReply::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetDynamicConfigReply::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& GetDynamicConfigReply::value() const {
  return *value_;
}
inline void GetDynamicConfigReply::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void GetDynamicConfigReply::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void GetDynamicConfigReply::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetDynamicConfigReply::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* GetDynamicConfigReply::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetDynamicConfigReply::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GetSmartLinkUrl

// required uint64 amount = 1;
inline bool GetSmartLinkUrl::has_amount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetSmartLinkUrl::set_has_amount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetSmartLinkUrl::clear_has_amount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetSmartLinkUrl::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 GetSmartLinkUrl::amount() const {
  return amount_;
}
inline void GetSmartLinkUrl::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
}

// -------------------------------------------------------------------

// GetSmartLinkUrlReply

// required string url = 1;
inline bool GetSmartLinkUrlReply::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetSmartLinkUrlReply::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetSmartLinkUrlReply::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetSmartLinkUrlReply::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& GetSmartLinkUrlReply::url() const {
  return *url_;
}
inline void GetSmartLinkUrlReply::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void GetSmartLinkUrlReply::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void GetSmartLinkUrlReply::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetSmartLinkUrlReply::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* GetSmartLinkUrlReply::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetSmartLinkUrlReply::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// StoreRateInfo

// required int32 storeId = 1;
inline bool StoreRateInfo::has_storeid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StoreRateInfo::set_has_storeid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StoreRateInfo::clear_has_storeid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StoreRateInfo::clear_storeid() {
  storeid_ = 0;
  clear_has_storeid();
}
inline ::google::protobuf::int32 StoreRateInfo::storeid() const {
  return storeid_;
}
inline void StoreRateInfo::set_storeid(::google::protobuf::int32 value) {
  set_has_storeid();
  storeid_ = value;
}

// required int32 s1 = 2;
inline bool StoreRateInfo::has_s1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StoreRateInfo::set_has_s1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StoreRateInfo::clear_has_s1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StoreRateInfo::clear_s1() {
  s1_ = 0;
  clear_has_s1();
}
inline ::google::protobuf::int32 StoreRateInfo::s1() const {
  return s1_;
}
inline void StoreRateInfo::set_s1(::google::protobuf::int32 value) {
  set_has_s1();
  s1_ = value;
}

// required int32 s2 = 3;
inline bool StoreRateInfo::has_s2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StoreRateInfo::set_has_s2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StoreRateInfo::clear_has_s2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StoreRateInfo::clear_s2() {
  s2_ = 0;
  clear_has_s2();
}
inline ::google::protobuf::int32 StoreRateInfo::s2() const {
  return s2_;
}
inline void StoreRateInfo::set_s2(::google::protobuf::int32 value) {
  set_has_s2();
  s2_ = value;
}

// required int32 s3 = 4;
inline bool StoreRateInfo::has_s3() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StoreRateInfo::set_has_s3() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StoreRateInfo::clear_has_s3() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StoreRateInfo::clear_s3() {
  s3_ = 0;
  clear_has_s3();
}
inline ::google::protobuf::int32 StoreRateInfo::s3() const {
  return s3_;
}
inline void StoreRateInfo::set_s3(::google::protobuf::int32 value) {
  set_has_s3();
  s3_ = value;
}

// required int32 s4 = 5;
inline bool StoreRateInfo::has_s4() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StoreRateInfo::set_has_s4() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StoreRateInfo::clear_has_s4() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StoreRateInfo::clear_s4() {
  s4_ = 0;
  clear_has_s4();
}
inline ::google::protobuf::int32 StoreRateInfo::s4() const {
  return s4_;
}
inline void StoreRateInfo::set_s4(::google::protobuf::int32 value) {
  set_has_s4();
  s4_ = value;
}

// required int32 s5 = 6;
inline bool StoreRateInfo::has_s5() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void StoreRateInfo::set_has_s5() {
  _has_bits_[0] |= 0x00000020u;
}
inline void StoreRateInfo::clear_has_s5() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void StoreRateInfo::clear_s5() {
  s5_ = 0;
  clear_has_s5();
}
inline ::google::protobuf::int32 StoreRateInfo::s5() const {
  return s5_;
}
inline void StoreRateInfo::set_s5(::google::protobuf::int32 value) {
  set_has_s5();
  s5_ = value;
}

// -------------------------------------------------------------------

// GetStoreRate

// repeated int32 storeIds = 1;
inline int GetStoreRate::storeids_size() const {
  return storeids_.size();
}
inline void GetStoreRate::clear_storeids() {
  storeids_.Clear();
}
inline ::google::protobuf::int32 GetStoreRate::storeids(int index) const {
  return storeids_.Get(index);
}
inline void GetStoreRate::set_storeids(int index, ::google::protobuf::int32 value) {
  storeids_.Set(index, value);
}
inline void GetStoreRate::add_storeids(::google::protobuf::int32 value) {
  storeids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GetStoreRate::storeids() const {
  return storeids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GetStoreRate::mutable_storeids() {
  return &storeids_;
}

// -------------------------------------------------------------------

// GetStoreRateReply

// repeated .com.mservice.momo.msg.StoreRateInfo rateInfos = 1;
inline int GetStoreRateReply::rateinfos_size() const {
  return rateinfos_.size();
}
inline void GetStoreRateReply::clear_rateinfos() {
  rateinfos_.Clear();
}
inline const ::com::mservice::momo::msg::StoreRateInfo& GetStoreRateReply::rateinfos(int index) const {
  return rateinfos_.Get(index);
}
inline ::com::mservice::momo::msg::StoreRateInfo* GetStoreRateReply::mutable_rateinfos(int index) {
  return rateinfos_.Mutable(index);
}
inline ::com::mservice::momo::msg::StoreRateInfo* GetStoreRateReply::add_rateinfos() {
  return rateinfos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::StoreRateInfo >&
GetStoreRateReply::rateinfos() const {
  return rateinfos_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::StoreRateInfo >*
GetStoreRateReply::mutable_rateinfos() {
  return &rateinfos_;
}

// -------------------------------------------------------------------

// StoreComment

// required string commentId = 1;
inline bool StoreComment::has_commentid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StoreComment::set_has_commentid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StoreComment::clear_has_commentid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StoreComment::clear_commentid() {
  if (commentid_ != &::google::protobuf::internal::kEmptyString) {
    commentid_->clear();
  }
  clear_has_commentid();
}
inline const ::std::string& StoreComment::commentid() const {
  return *commentid_;
}
inline void StoreComment::set_commentid(const ::std::string& value) {
  set_has_commentid();
  if (commentid_ == &::google::protobuf::internal::kEmptyString) {
    commentid_ = new ::std::string;
  }
  commentid_->assign(value);
}
inline void StoreComment::set_commentid(const char* value) {
  set_has_commentid();
  if (commentid_ == &::google::protobuf::internal::kEmptyString) {
    commentid_ = new ::std::string;
  }
  commentid_->assign(value);
}
inline void StoreComment::set_commentid(const char* value, size_t size) {
  set_has_commentid();
  if (commentid_ == &::google::protobuf::internal::kEmptyString) {
    commentid_ = new ::std::string;
  }
  commentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreComment::mutable_commentid() {
  set_has_commentid();
  if (commentid_ == &::google::protobuf::internal::kEmptyString) {
    commentid_ = new ::std::string;
  }
  return commentid_;
}
inline ::std::string* StoreComment::release_commentid() {
  clear_has_commentid();
  if (commentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = commentid_;
    commentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StoreComment::set_allocated_commentid(::std::string* commentid) {
  if (commentid_ != &::google::protobuf::internal::kEmptyString) {
    delete commentid_;
  }
  if (commentid) {
    set_has_commentid();
    commentid_ = commentid;
  } else {
    clear_has_commentid();
    commentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 storeId = 2;
inline bool StoreComment::has_storeid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StoreComment::set_has_storeid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StoreComment::clear_has_storeid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StoreComment::clear_storeid() {
  storeid_ = 0;
  clear_has_storeid();
}
inline ::google::protobuf::int32 StoreComment::storeid() const {
  return storeid_;
}
inline void StoreComment::set_storeid(::google::protobuf::int32 value) {
  set_has_storeid();
  storeid_ = value;
}

// required int32 commenterPhone = 3;
inline bool StoreComment::has_commenterphone() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StoreComment::set_has_commenterphone() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StoreComment::clear_has_commenterphone() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StoreComment::clear_commenterphone() {
  commenterphone_ = 0;
  clear_has_commenterphone();
}
inline ::google::protobuf::int32 StoreComment::commenterphone() const {
  return commenterphone_;
}
inline void StoreComment::set_commenterphone(::google::protobuf::int32 value) {
  set_has_commenterphone();
  commenterphone_ = value;
}

// required string commenterName = 4;
inline bool StoreComment::has_commentername() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StoreComment::set_has_commentername() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StoreComment::clear_has_commentername() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StoreComment::clear_commentername() {
  if (commentername_ != &::google::protobuf::internal::kEmptyString) {
    commentername_->clear();
  }
  clear_has_commentername();
}
inline const ::std::string& StoreComment::commentername() const {
  return *commentername_;
}
inline void StoreComment::set_commentername(const ::std::string& value) {
  set_has_commentername();
  if (commentername_ == &::google::protobuf::internal::kEmptyString) {
    commentername_ = new ::std::string;
  }
  commentername_->assign(value);
}
inline void StoreComment::set_commentername(const char* value) {
  set_has_commentername();
  if (commentername_ == &::google::protobuf::internal::kEmptyString) {
    commentername_ = new ::std::string;
  }
  commentername_->assign(value);
}
inline void StoreComment::set_commentername(const char* value, size_t size) {
  set_has_commentername();
  if (commentername_ == &::google::protobuf::internal::kEmptyString) {
    commentername_ = new ::std::string;
  }
  commentername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreComment::mutable_commentername() {
  set_has_commentername();
  if (commentername_ == &::google::protobuf::internal::kEmptyString) {
    commentername_ = new ::std::string;
  }
  return commentername_;
}
inline ::std::string* StoreComment::release_commentername() {
  clear_has_commentername();
  if (commentername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = commentername_;
    commentername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StoreComment::set_allocated_commentername(::std::string* commentername) {
  if (commentername_ != &::google::protobuf::internal::kEmptyString) {
    delete commentername_;
  }
  if (commentername) {
    set_has_commentername();
    commentername_ = commentername;
  } else {
    clear_has_commentername();
    commentername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string content = 5;
inline bool StoreComment::has_content() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StoreComment::set_has_content() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StoreComment::clear_has_content() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StoreComment::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& StoreComment::content() const {
  return *content_;
}
inline void StoreComment::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void StoreComment::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void StoreComment::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreComment::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* StoreComment::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StoreComment::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int64 date = 6;
inline bool StoreComment::has_date() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void StoreComment::set_has_date() {
  _has_bits_[0] |= 0x00000020u;
}
inline void StoreComment::clear_has_date() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void StoreComment::clear_date() {
  date_ = GOOGLE_LONGLONG(0);
  clear_has_date();
}
inline ::google::protobuf::int64 StoreComment::date() const {
  return date_;
}
inline void StoreComment::set_date(::google::protobuf::int64 value) {
  set_has_date();
  date_ = value;
}

// required int32 rateStar = 7;
inline bool StoreComment::has_ratestar() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void StoreComment::set_has_ratestar() {
  _has_bits_[0] |= 0x00000040u;
}
inline void StoreComment::clear_has_ratestar() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void StoreComment::clear_ratestar() {
  ratestar_ = 0;
  clear_has_ratestar();
}
inline ::google::protobuf::int32 StoreComment::ratestar() const {
  return ratestar_;
}
inline void StoreComment::set_ratestar(::google::protobuf::int32 value) {
  set_has_ratestar();
  ratestar_ = value;
}

// required int32 status = 8;
inline bool StoreComment::has_status() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void StoreComment::set_has_status() {
  _has_bits_[0] |= 0x00000080u;
}
inline void StoreComment::clear_has_status() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void StoreComment::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 StoreComment::status() const {
  return status_;
}
inline void StoreComment::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// GetStoreCommentPage

// required int32 storeId = 1;
inline bool GetStoreCommentPage::has_storeid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetStoreCommentPage::set_has_storeid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetStoreCommentPage::clear_has_storeid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetStoreCommentPage::clear_storeid() {
  storeid_ = 0;
  clear_has_storeid();
}
inline ::google::protobuf::int32 GetStoreCommentPage::storeid() const {
  return storeid_;
}
inline void GetStoreCommentPage::set_storeid(::google::protobuf::int32 value) {
  set_has_storeid();
  storeid_ = value;
}

// required int32 commenterPhone = 2;
inline bool GetStoreCommentPage::has_commenterphone() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetStoreCommentPage::set_has_commenterphone() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetStoreCommentPage::clear_has_commenterphone() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetStoreCommentPage::clear_commenterphone() {
  commenterphone_ = 0;
  clear_has_commenterphone();
}
inline ::google::protobuf::int32 GetStoreCommentPage::commenterphone() const {
  return commenterphone_;
}
inline void GetStoreCommentPage::set_commenterphone(::google::protobuf::int32 value) {
  set_has_commenterphone();
  commenterphone_ = value;
}

// required int64 lowestTime = 3;
inline bool GetStoreCommentPage::has_lowesttime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetStoreCommentPage::set_has_lowesttime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetStoreCommentPage::clear_has_lowesttime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetStoreCommentPage::clear_lowesttime() {
  lowesttime_ = GOOGLE_LONGLONG(0);
  clear_has_lowesttime();
}
inline ::google::protobuf::int64 GetStoreCommentPage::lowesttime() const {
  return lowesttime_;
}
inline void GetStoreCommentPage::set_lowesttime(::google::protobuf::int64 value) {
  set_has_lowesttime();
  lowesttime_ = value;
}

// -------------------------------------------------------------------

// GetStoreCommentPageReply

// repeated .com.mservice.momo.msg.StoreComment comments = 3;
inline int GetStoreCommentPageReply::comments_size() const {
  return comments_.size();
}
inline void GetStoreCommentPageReply::clear_comments() {
  comments_.Clear();
}
inline const ::com::mservice::momo::msg::StoreComment& GetStoreCommentPageReply::comments(int index) const {
  return comments_.Get(index);
}
inline ::com::mservice::momo::msg::StoreComment* GetStoreCommentPageReply::mutable_comments(int index) {
  return comments_.Mutable(index);
}
inline ::com::mservice::momo::msg::StoreComment* GetStoreCommentPageReply::add_comments() {
  return comments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::StoreComment >&
GetStoreCommentPageReply::comments() const {
  return comments_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::StoreComment >*
GetStoreCommentPageReply::mutable_comments() {
  return &comments_;
}

// -------------------------------------------------------------------

// StoreCommentCrud

// required int32 cmd = 1;
inline bool StoreCommentCrud::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StoreCommentCrud::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StoreCommentCrud::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StoreCommentCrud::clear_cmd() {
  cmd_ = 0;
  clear_has_cmd();
}
inline ::google::protobuf::int32 StoreCommentCrud::cmd() const {
  return cmd_;
}
inline void StoreCommentCrud::set_cmd(::google::protobuf::int32 value) {
  set_has_cmd();
  cmd_ = value;
}

// required .com.mservice.momo.msg.StoreComment comment = 2;
inline bool StoreCommentCrud::has_comment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StoreCommentCrud::set_has_comment() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StoreCommentCrud::clear_has_comment() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StoreCommentCrud::clear_comment() {
  if (comment_ != NULL) comment_->::com::mservice::momo::msg::StoreComment::Clear();
  clear_has_comment();
}
inline const ::com::mservice::momo::msg::StoreComment& StoreCommentCrud::comment() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return comment_ != NULL ? *comment_ : *default_instance().comment_;
#else
  return comment_ != NULL ? *comment_ : *default_instance_->comment_;
#endif
}
inline ::com::mservice::momo::msg::StoreComment* StoreCommentCrud::mutable_comment() {
  set_has_comment();
  if (comment_ == NULL) comment_ = new ::com::mservice::momo::msg::StoreComment;
  return comment_;
}
inline ::com::mservice::momo::msg::StoreComment* StoreCommentCrud::release_comment() {
  clear_has_comment();
  ::com::mservice::momo::msg::StoreComment* temp = comment_;
  comment_ = NULL;
  return temp;
}
inline void StoreCommentCrud::set_allocated_comment(::com::mservice::momo::msg::StoreComment* comment) {
  delete comment_;
  comment_ = comment;
  if (comment) {
    set_has_comment();
  } else {
    clear_has_comment();
  }
}

// -------------------------------------------------------------------

// StoreCommentCrudReply

// required int32 error = 1;
inline bool StoreCommentCrudReply::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StoreCommentCrudReply::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StoreCommentCrudReply::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StoreCommentCrudReply::clear_error() {
  error_ = 0;
  clear_has_error();
}
inline ::google::protobuf::int32 StoreCommentCrudReply::error() const {
  return error_;
}
inline void StoreCommentCrudReply::set_error(::google::protobuf::int32 value) {
  set_has_error();
  error_ = value;
}

// required string desc = 2;
inline bool StoreCommentCrudReply::has_desc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StoreCommentCrudReply::set_has_desc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StoreCommentCrudReply::clear_has_desc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StoreCommentCrudReply::clear_desc() {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& StoreCommentCrudReply::desc() const {
  return *desc_;
}
inline void StoreCommentCrudReply::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void StoreCommentCrudReply::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void StoreCommentCrudReply::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreCommentCrudReply::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  return desc_;
}
inline ::std::string* StoreCommentCrudReply::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StoreCommentCrudReply::set_allocated_desc(::std::string* desc) {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    delete desc_;
  }
  if (desc) {
    set_has_desc();
    desc_ = desc;
  } else {
    clear_has_desc();
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string commentId = 3;
inline bool StoreCommentCrudReply::has_commentid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StoreCommentCrudReply::set_has_commentid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StoreCommentCrudReply::clear_has_commentid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StoreCommentCrudReply::clear_commentid() {
  if (commentid_ != &::google::protobuf::internal::kEmptyString) {
    commentid_->clear();
  }
  clear_has_commentid();
}
inline const ::std::string& StoreCommentCrudReply::commentid() const {
  return *commentid_;
}
inline void StoreCommentCrudReply::set_commentid(const ::std::string& value) {
  set_has_commentid();
  if (commentid_ == &::google::protobuf::internal::kEmptyString) {
    commentid_ = new ::std::string;
  }
  commentid_->assign(value);
}
inline void StoreCommentCrudReply::set_commentid(const char* value) {
  set_has_commentid();
  if (commentid_ == &::google::protobuf::internal::kEmptyString) {
    commentid_ = new ::std::string;
  }
  commentid_->assign(value);
}
inline void StoreCommentCrudReply::set_commentid(const char* value, size_t size) {
  set_has_commentid();
  if (commentid_ == &::google::protobuf::internal::kEmptyString) {
    commentid_ = new ::std::string;
  }
  commentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreCommentCrudReply::mutable_commentid() {
  set_has_commentid();
  if (commentid_ == &::google::protobuf::internal::kEmptyString) {
    commentid_ = new ::std::string;
  }
  return commentid_;
}
inline ::std::string* StoreCommentCrudReply::release_commentid() {
  clear_has_commentid();
  if (commentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = commentid_;
    commentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StoreCommentCrudReply::set_allocated_commentid(::std::string* commentid) {
  if (commentid_ != &::google::protobuf::internal::kEmptyString) {
    delete commentid_;
  }
  if (commentid) {
    set_has_commentid();
    commentid_ = commentid;
  } else {
    clear_has_commentid();
    commentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// StoreWarningType

// required int32 id = 1;
inline bool StoreWarningType::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StoreWarningType::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StoreWarningType::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StoreWarningType::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 StoreWarningType::id() const {
  return id_;
}
inline void StoreWarningType::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required string name = 2;
inline bool StoreWarningType::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StoreWarningType::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StoreWarningType::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StoreWarningType::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& StoreWarningType::name() const {
  return *name_;
}
inline void StoreWarningType::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void StoreWarningType::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void StoreWarningType::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreWarningType::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* StoreWarningType::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StoreWarningType::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GetStoreWarningType

// -------------------------------------------------------------------

// GetStoreWarningTypeReply

// repeated .com.mservice.momo.msg.StoreWarningType types = 1;
inline int GetStoreWarningTypeReply::types_size() const {
  return types_.size();
}
inline void GetStoreWarningTypeReply::clear_types() {
  types_.Clear();
}
inline const ::com::mservice::momo::msg::StoreWarningType& GetStoreWarningTypeReply::types(int index) const {
  return types_.Get(index);
}
inline ::com::mservice::momo::msg::StoreWarningType* GetStoreWarningTypeReply::mutable_types(int index) {
  return types_.Mutable(index);
}
inline ::com::mservice::momo::msg::StoreWarningType* GetStoreWarningTypeReply::add_types() {
  return types_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::StoreWarningType >&
GetStoreWarningTypeReply::types() const {
  return types_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::StoreWarningType >*
GetStoreWarningTypeReply::mutable_types() {
  return &types_;
}

// -------------------------------------------------------------------

// WarnStore

// required int32 storeId = 1;
inline bool WarnStore::has_storeid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WarnStore::set_has_storeid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WarnStore::clear_has_storeid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WarnStore::clear_storeid() {
  storeid_ = 0;
  clear_has_storeid();
}
inline ::google::protobuf::int32 WarnStore::storeid() const {
  return storeid_;
}
inline void WarnStore::set_storeid(::google::protobuf::int32 value) {
  set_has_storeid();
  storeid_ = value;
}

// required int32 warningType = 3;
inline bool WarnStore::has_warningtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WarnStore::set_has_warningtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WarnStore::clear_has_warningtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WarnStore::clear_warningtype() {
  warningtype_ = 0;
  clear_has_warningtype();
}
inline ::google::protobuf::int32 WarnStore::warningtype() const {
  return warningtype_;
}
inline void WarnStore::set_warningtype(::google::protobuf::int32 value) {
  set_has_warningtype();
  warningtype_ = value;
}

// -------------------------------------------------------------------

// WarnStoreReply

// required int32 error = 1;
inline bool WarnStoreReply::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WarnStoreReply::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WarnStoreReply::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WarnStoreReply::clear_error() {
  error_ = 0;
  clear_has_error();
}
inline ::google::protobuf::int32 WarnStoreReply::error() const {
  return error_;
}
inline void WarnStoreReply::set_error(::google::protobuf::int32 value) {
  set_has_error();
  error_ = value;
}

// required string desc = 2;
inline bool WarnStoreReply::has_desc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WarnStoreReply::set_has_desc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WarnStoreReply::clear_has_desc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WarnStoreReply::clear_desc() {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& WarnStoreReply::desc() const {
  return *desc_;
}
inline void WarnStoreReply::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void WarnStoreReply::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void WarnStoreReply::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WarnStoreReply::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  return desc_;
}
inline ::std::string* WarnStoreReply::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WarnStoreReply::set_allocated_desc(::std::string* desc) {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    delete desc_;
  }
  if (desc) {
    set_has_desc();
    desc_ = desc;
  } else {
    clear_has_desc();
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GiftType

// optional string id = 1;
inline bool GiftType::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GiftType::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GiftType::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GiftType::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& GiftType::id() const {
  return *id_;
}
inline void GiftType::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void GiftType::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void GiftType::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GiftType::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* GiftType::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GiftType::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string serviceId = 2;
inline bool GiftType::has_serviceid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GiftType::set_has_serviceid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GiftType::clear_has_serviceid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GiftType::clear_serviceid() {
  if (serviceid_ != &::google::protobuf::internal::kEmptyString) {
    serviceid_->clear();
  }
  clear_has_serviceid();
}
inline const ::std::string& GiftType::serviceid() const {
  return *serviceid_;
}
inline void GiftType::set_serviceid(const ::std::string& value) {
  set_has_serviceid();
  if (serviceid_ == &::google::protobuf::internal::kEmptyString) {
    serviceid_ = new ::std::string;
  }
  serviceid_->assign(value);
}
inline void GiftType::set_serviceid(const char* value) {
  set_has_serviceid();
  if (serviceid_ == &::google::protobuf::internal::kEmptyString) {
    serviceid_ = new ::std::string;
  }
  serviceid_->assign(value);
}
inline void GiftType::set_serviceid(const char* value, size_t size) {
  set_has_serviceid();
  if (serviceid_ == &::google::protobuf::internal::kEmptyString) {
    serviceid_ = new ::std::string;
  }
  serviceid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GiftType::mutable_serviceid() {
  set_has_serviceid();
  if (serviceid_ == &::google::protobuf::internal::kEmptyString) {
    serviceid_ = new ::std::string;
  }
  return serviceid_;
}
inline ::std::string* GiftType::release_serviceid() {
  clear_has_serviceid();
  if (serviceid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serviceid_;
    serviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GiftType::set_allocated_serviceid(::std::string* serviceid) {
  if (serviceid_ != &::google::protobuf::internal::kEmptyString) {
    delete serviceid_;
  }
  if (serviceid) {
    set_has_serviceid();
    serviceid_ = serviceid;
  } else {
    clear_has_serviceid();
    serviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 3;
inline bool GiftType::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GiftType::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GiftType::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GiftType::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& GiftType::name() const {
  return *name_;
}
inline void GiftType::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void GiftType::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void GiftType::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GiftType::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* GiftType::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GiftType::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string desc = 4;
inline bool GiftType::has_desc() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GiftType::set_has_desc() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GiftType::clear_has_desc() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GiftType::clear_desc() {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& GiftType::desc() const {
  return *desc_;
}
inline void GiftType::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void GiftType::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void GiftType::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GiftType::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  return desc_;
}
inline ::std::string* GiftType::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GiftType::set_allocated_desc(::std::string* desc) {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    delete desc_;
  }
  if (desc) {
    set_has_desc();
    desc_ = desc;
  } else {
    clear_has_desc();
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string icon = 5;
inline bool GiftType::has_icon() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GiftType::set_has_icon() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GiftType::clear_has_icon() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GiftType::clear_icon() {
  if (icon_ != &::google::protobuf::internal::kEmptyString) {
    icon_->clear();
  }
  clear_has_icon();
}
inline const ::std::string& GiftType::icon() const {
  return *icon_;
}
inline void GiftType::set_icon(const ::std::string& value) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    icon_ = new ::std::string;
  }
  icon_->assign(value);
}
inline void GiftType::set_icon(const char* value) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    icon_ = new ::std::string;
  }
  icon_->assign(value);
}
inline void GiftType::set_icon(const char* value, size_t size) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    icon_ = new ::std::string;
  }
  icon_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GiftType::mutable_icon() {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    icon_ = new ::std::string;
  }
  return icon_;
}
inline ::std::string* GiftType::release_icon() {
  clear_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = icon_;
    icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GiftType::set_allocated_icon(::std::string* icon) {
  if (icon_ != &::google::protobuf::internal::kEmptyString) {
    delete icon_;
  }
  if (icon) {
    set_has_icon();
    icon_ = icon;
  } else {
    clear_has_icon();
    icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string image = 6;
inline bool GiftType::has_image() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GiftType::set_has_image() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GiftType::clear_has_image() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GiftType::clear_image() {
  if (image_ != &::google::protobuf::internal::kEmptyString) {
    image_->clear();
  }
  clear_has_image();
}
inline const ::std::string& GiftType::image() const {
  return *image_;
}
inline void GiftType::set_image(const ::std::string& value) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(value);
}
inline void GiftType::set_image(const char* value) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(value);
}
inline void GiftType::set_image(const char* value, size_t size) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GiftType::mutable_image() {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  return image_;
}
inline ::std::string* GiftType::release_image() {
  clear_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = image_;
    image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GiftType::set_allocated_image(::std::string* image) {
  if (image_ != &::google::protobuf::internal::kEmptyString) {
    delete image_;
  }
  if (image) {
    set_has_image();
    image_ = image;
  } else {
    clear_has_image();
    image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool transfer = 7;
inline bool GiftType::has_transfer() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GiftType::set_has_transfer() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GiftType::clear_has_transfer() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GiftType::clear_transfer() {
  transfer_ = false;
  clear_has_transfer();
}
inline bool GiftType::transfer() const {
  return transfer_;
}
inline void GiftType::set_transfer(bool value) {
  set_has_transfer();
  transfer_ = value;
}

// optional uint32 status = 8;
inline bool GiftType::has_status() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GiftType::set_has_status() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GiftType::clear_has_status() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GiftType::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 GiftType::status() const {
  return status_;
}
inline void GiftType::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
}

// optional uint64 modifyDate = 9;
inline bool GiftType::has_modifydate() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GiftType::set_has_modifydate() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GiftType::clear_has_modifydate() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GiftType::clear_modifydate() {
  modifydate_ = GOOGLE_ULONGLONG(0);
  clear_has_modifydate();
}
inline ::google::protobuf::uint64 GiftType::modifydate() const {
  return modifydate_;
}
inline void GiftType::set_modifydate(::google::protobuf::uint64 value) {
  set_has_modifydate();
  modifydate_ = value;
}

// optional bool isNew = 10;
inline bool GiftType::has_isnew() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GiftType::set_has_isnew() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GiftType::clear_has_isnew() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GiftType::clear_isnew() {
  isnew_ = false;
  clear_has_isnew();
}
inline bool GiftType::isnew() const {
  return isnew_;
}
inline void GiftType::set_isnew(bool value) {
  set_has_isnew();
  isnew_ = value;
}

// repeated int64 price = 11;
inline int GiftType::price_size() const {
  return price_.size();
}
inline void GiftType::clear_price() {
  price_.Clear();
}
inline ::google::protobuf::int64 GiftType::price(int index) const {
  return price_.Get(index);
}
inline void GiftType::set_price(int index, ::google::protobuf::int64 value) {
  price_.Set(index, value);
}
inline void GiftType::add_price(::google::protobuf::int64 value) {
  price_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
GiftType::price() const {
  return price_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
GiftType::mutable_price() {
  return &price_;
}

// optional string policy = 12;
inline bool GiftType::has_policy() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GiftType::set_has_policy() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GiftType::clear_has_policy() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GiftType::clear_policy() {
  if (policy_ != &::google::protobuf::internal::kEmptyString) {
    policy_->clear();
  }
  clear_has_policy();
}
inline const ::std::string& GiftType::policy() const {
  return *policy_;
}
inline void GiftType::set_policy(const ::std::string& value) {
  set_has_policy();
  if (policy_ == &::google::protobuf::internal::kEmptyString) {
    policy_ = new ::std::string;
  }
  policy_->assign(value);
}
inline void GiftType::set_policy(const char* value) {
  set_has_policy();
  if (policy_ == &::google::protobuf::internal::kEmptyString) {
    policy_ = new ::std::string;
  }
  policy_->assign(value);
}
inline void GiftType::set_policy(const char* value, size_t size) {
  set_has_policy();
  if (policy_ == &::google::protobuf::internal::kEmptyString) {
    policy_ = new ::std::string;
  }
  policy_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GiftType::mutable_policy() {
  set_has_policy();
  if (policy_ == &::google::protobuf::internal::kEmptyString) {
    policy_ = new ::std::string;
  }
  return policy_;
}
inline ::std::string* GiftType::release_policy() {
  clear_has_policy();
  if (policy_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = policy_;
    policy_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GiftType::set_allocated_policy(::std::string* policy) {
  if (policy_ != &::google::protobuf::internal::kEmptyString) {
    delete policy_;
  }
  if (policy) {
    set_has_policy();
    policy_ = policy;
  } else {
    clear_has_policy();
    policy_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Gift

// optional string id = 1;
inline bool Gift::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Gift::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Gift::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Gift::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Gift::id() const {
  return *id_;
}
inline void Gift::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Gift::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Gift::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Gift::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* Gift::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Gift::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string code = 2;
inline bool Gift::has_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Gift::set_has_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Gift::clear_has_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Gift::clear_code() {
  if (code_ != &::google::protobuf::internal::kEmptyString) {
    code_->clear();
  }
  clear_has_code();
}
inline const ::std::string& Gift::code() const {
  return *code_;
}
inline void Gift::set_code(const ::std::string& value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(value);
}
inline void Gift::set_code(const char* value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(value);
}
inline void Gift::set_code(const char* value, size_t size) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Gift::mutable_code() {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  return code_;
}
inline ::std::string* Gift::release_code() {
  clear_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = code_;
    code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Gift::set_allocated_code(::std::string* code) {
  if (code_ != &::google::protobuf::internal::kEmptyString) {
    delete code_;
  }
  if (code) {
    set_has_code();
    code_ = code;
  } else {
    clear_has_code();
    code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 amount = 3;
inline bool Gift::has_amount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Gift::set_has_amount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Gift::clear_has_amount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Gift::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 Gift::amount() const {
  return amount_;
}
inline void Gift::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
}

// optional string desc = 5;
inline bool Gift::has_desc() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Gift::set_has_desc() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Gift::clear_has_desc() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Gift::clear_desc() {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& Gift::desc() const {
  return *desc_;
}
inline void Gift::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void Gift::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void Gift::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Gift::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  return desc_;
}
inline ::std::string* Gift::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Gift::set_allocated_desc(::std::string* desc) {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    delete desc_;
  }
  if (desc) {
    set_has_desc();
    desc_ = desc;
  } else {
    clear_has_desc();
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string typeId = 6;
inline bool Gift::has_typeid_() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Gift::set_has_typeid_() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Gift::clear_has_typeid_() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Gift::clear_typeid_() {
  if (typeid__ != &::google::protobuf::internal::kEmptyString) {
    typeid__->clear();
  }
  clear_has_typeid_();
}
inline const ::std::string& Gift::typeid_() const {
  return *typeid__;
}
inline void Gift::set_typeid_(const ::std::string& value) {
  set_has_typeid_();
  if (typeid__ == &::google::protobuf::internal::kEmptyString) {
    typeid__ = new ::std::string;
  }
  typeid__->assign(value);
}
inline void Gift::set_typeid_(const char* value) {
  set_has_typeid_();
  if (typeid__ == &::google::protobuf::internal::kEmptyString) {
    typeid__ = new ::std::string;
  }
  typeid__->assign(value);
}
inline void Gift::set_typeid_(const char* value, size_t size) {
  set_has_typeid_();
  if (typeid__ == &::google::protobuf::internal::kEmptyString) {
    typeid__ = new ::std::string;
  }
  typeid__->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Gift::mutable_typeid_() {
  set_has_typeid_();
  if (typeid__ == &::google::protobuf::internal::kEmptyString) {
    typeid__ = new ::std::string;
  }
  return typeid__;
}
inline ::std::string* Gift::release_typeid_() {
  clear_has_typeid_();
  if (typeid__ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = typeid__;
    typeid__ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Gift::set_allocated_typeid_(::std::string* typeid_) {
  if (typeid__ != &::google::protobuf::internal::kEmptyString) {
    delete typeid__;
  }
  if (typeid_) {
    set_has_typeid_();
    typeid__ = typeid_;
  } else {
    clear_has_typeid_();
    typeid__ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 startDate = 7;
inline bool Gift::has_startdate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Gift::set_has_startdate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Gift::clear_has_startdate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Gift::clear_startdate() {
  startdate_ = GOOGLE_ULONGLONG(0);
  clear_has_startdate();
}
inline ::google::protobuf::uint64 Gift::startdate() const {
  return startdate_;
}
inline void Gift::set_startdate(::google::protobuf::uint64 value) {
  set_has_startdate();
  startdate_ = value;
}

// optional uint64 endDate = 8;
inline bool Gift::has_enddate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Gift::set_has_enddate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Gift::clear_has_enddate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Gift::clear_enddate() {
  enddate_ = GOOGLE_ULONGLONG(0);
  clear_has_enddate();
}
inline ::google::protobuf::uint64 Gift::enddate() const {
  return enddate_;
}
inline void Gift::set_enddate(::google::protobuf::uint64 value) {
  set_has_enddate();
  enddate_ = value;
}

// optional uint64 modifyDate = 9;
inline bool Gift::has_modifydate() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Gift::set_has_modifydate() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Gift::clear_has_modifydate() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Gift::clear_modifydate() {
  modifydate_ = GOOGLE_ULONGLONG(0);
  clear_has_modifydate();
}
inline ::google::protobuf::uint64 Gift::modifydate() const {
  return modifydate_;
}
inline void Gift::set_modifydate(::google::protobuf::uint64 value) {
  set_has_modifydate();
  modifydate_ = value;
}

// optional int32 status = 10;
inline bool Gift::has_status() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Gift::set_has_status() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Gift::clear_has_status() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Gift::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 Gift::status() const {
  return status_;
}
inline void Gift::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// optional string extra = 11;
inline bool Gift::has_extra() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Gift::set_has_extra() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Gift::clear_has_extra() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Gift::clear_extra() {
  if (extra_ != &::google::protobuf::internal::kEmptyString) {
    extra_->clear();
  }
  clear_has_extra();
}
inline const ::std::string& Gift::extra() const {
  return *extra_;
}
inline void Gift::set_extra(const ::std::string& value) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  extra_->assign(value);
}
inline void Gift::set_extra(const char* value) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  extra_->assign(value);
}
inline void Gift::set_extra(const char* value, size_t size) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  extra_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Gift::mutable_extra() {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  return extra_;
}
inline ::std::string* Gift::release_extra() {
  clear_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extra_;
    extra_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Gift::set_allocated_extra(::std::string* extra) {
  if (extra_ != &::google::protobuf::internal::kEmptyString) {
    delete extra_;
  }
  if (extra) {
    set_has_extra();
    extra_ = extra;
  } else {
    clear_has_extra();
    extra_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GiftClaim

// required string code = 1;
inline bool GiftClaim::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GiftClaim::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GiftClaim::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GiftClaim::clear_code() {
  if (code_ != &::google::protobuf::internal::kEmptyString) {
    code_->clear();
  }
  clear_has_code();
}
inline const ::std::string& GiftClaim::code() const {
  return *code_;
}
inline void GiftClaim::set_code(const ::std::string& value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(value);
}
inline void GiftClaim::set_code(const char* value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(value);
}
inline void GiftClaim::set_code(const char* value, size_t size) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GiftClaim::mutable_code() {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  return code_;
}
inline ::std::string* GiftClaim::release_code() {
  clear_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = code_;
    code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GiftClaim::set_allocated_code(::std::string* code) {
  if (code_ != &::google::protobuf::internal::kEmptyString) {
    delete code_;
  }
  if (code) {
    set_has_code();
    code_ = code;
  } else {
    clear_has_code();
    code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GiftClaimReply

// required int32 error = 1;
inline bool GiftClaimReply::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GiftClaimReply::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GiftClaimReply::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GiftClaimReply::clear_error() {
  error_ = 0;
  clear_has_error();
}
inline ::google::protobuf::int32 GiftClaimReply::error() const {
  return error_;
}
inline void GiftClaimReply::set_error(::google::protobuf::int32 value) {
  set_has_error();
  error_ = value;
}

// optional int64 point = 2;
inline bool GiftClaimReply::has_point() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GiftClaimReply::set_has_point() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GiftClaimReply::clear_has_point() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GiftClaimReply::clear_point() {
  point_ = GOOGLE_LONGLONG(0);
  clear_has_point();
}
inline ::google::protobuf::int64 GiftClaimReply::point() const {
  return point_;
}
inline void GiftClaimReply::set_point(::google::protobuf::int64 value) {
  set_has_point();
  point_ = value;
}

// optional .com.mservice.momo.msg.Gift gift = 3;
inline bool GiftClaimReply::has_gift() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GiftClaimReply::set_has_gift() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GiftClaimReply::clear_has_gift() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GiftClaimReply::clear_gift() {
  if (gift_ != NULL) gift_->::com::mservice::momo::msg::Gift::Clear();
  clear_has_gift();
}
inline const ::com::mservice::momo::msg::Gift& GiftClaimReply::gift() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return gift_ != NULL ? *gift_ : *default_instance().gift_;
#else
  return gift_ != NULL ? *gift_ : *default_instance_->gift_;
#endif
}
inline ::com::mservice::momo::msg::Gift* GiftClaimReply::mutable_gift() {
  set_has_gift();
  if (gift_ == NULL) gift_ = new ::com::mservice::momo::msg::Gift;
  return gift_;
}
inline ::com::mservice::momo::msg::Gift* GiftClaimReply::release_gift() {
  clear_has_gift();
  ::com::mservice::momo::msg::Gift* temp = gift_;
  gift_ = NULL;
  return temp;
}
inline void GiftClaimReply::set_allocated_gift(::com::mservice::momo::msg::Gift* gift) {
  delete gift_;
  gift_ = gift;
  if (gift) {
    set_has_gift();
  } else {
    clear_has_gift();
  }
}

// -------------------------------------------------------------------

// UserSetting

// optional bool useMpoint = 1;
inline bool UserSetting::has_usempoint() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserSetting::set_has_usempoint() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserSetting::clear_has_usempoint() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserSetting::clear_usempoint() {
  usempoint_ = false;
  clear_has_usempoint();
}
inline bool UserSetting::usempoint() const {
  return usempoint_;
}
inline void UserSetting::set_usempoint(bool value) {
  set_has_usempoint();
  usempoint_ = value;
}

// -------------------------------------------------------------------

// GetGiftType

// optional uint64 time = 1;
inline bool GetGiftType::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetGiftType::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetGiftType::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetGiftType::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::uint64 GetGiftType::time() const {
  return time_;
}
inline void GetGiftType::set_time(::google::protobuf::uint64 value) {
  set_has_time();
  time_ = value;
}

// optional string giftTypeId = 2;
inline bool GetGiftType::has_gifttypeid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetGiftType::set_has_gifttypeid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetGiftType::clear_has_gifttypeid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetGiftType::clear_gifttypeid() {
  if (gifttypeid_ != &::google::protobuf::internal::kEmptyString) {
    gifttypeid_->clear();
  }
  clear_has_gifttypeid();
}
inline const ::std::string& GetGiftType::gifttypeid() const {
  return *gifttypeid_;
}
inline void GetGiftType::set_gifttypeid(const ::std::string& value) {
  set_has_gifttypeid();
  if (gifttypeid_ == &::google::protobuf::internal::kEmptyString) {
    gifttypeid_ = new ::std::string;
  }
  gifttypeid_->assign(value);
}
inline void GetGiftType::set_gifttypeid(const char* value) {
  set_has_gifttypeid();
  if (gifttypeid_ == &::google::protobuf::internal::kEmptyString) {
    gifttypeid_ = new ::std::string;
  }
  gifttypeid_->assign(value);
}
inline void GetGiftType::set_gifttypeid(const char* value, size_t size) {
  set_has_gifttypeid();
  if (gifttypeid_ == &::google::protobuf::internal::kEmptyString) {
    gifttypeid_ = new ::std::string;
  }
  gifttypeid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetGiftType::mutable_gifttypeid() {
  set_has_gifttypeid();
  if (gifttypeid_ == &::google::protobuf::internal::kEmptyString) {
    gifttypeid_ = new ::std::string;
  }
  return gifttypeid_;
}
inline ::std::string* GetGiftType::release_gifttypeid() {
  clear_has_gifttypeid();
  if (gifttypeid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gifttypeid_;
    gifttypeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetGiftType::set_allocated_gifttypeid(::std::string* gifttypeid) {
  if (gifttypeid_ != &::google::protobuf::internal::kEmptyString) {
    delete gifttypeid_;
  }
  if (gifttypeid) {
    set_has_gifttypeid();
    gifttypeid_ = gifttypeid;
  } else {
    clear_has_gifttypeid();
    gifttypeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GetGiftTypeReply

// repeated .com.mservice.momo.msg.GiftType giftType = 1;
inline int GetGiftTypeReply::gifttype_size() const {
  return gifttype_.size();
}
inline void GetGiftTypeReply::clear_gifttype() {
  gifttype_.Clear();
}
inline const ::com::mservice::momo::msg::GiftType& GetGiftTypeReply::gifttype(int index) const {
  return gifttype_.Get(index);
}
inline ::com::mservice::momo::msg::GiftType* GetGiftTypeReply::mutable_gifttype(int index) {
  return gifttype_.Mutable(index);
}
inline ::com::mservice::momo::msg::GiftType* GetGiftTypeReply::add_gifttype() {
  return gifttype_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::GiftType >&
GetGiftTypeReply::gifttype() const {
  return gifttype_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::GiftType >*
GetGiftTypeReply::mutable_gifttype() {
  return &gifttype_;
}

// -------------------------------------------------------------------

// GetGift

// optional string giftId = 1;
inline bool GetGift::has_giftid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetGift::set_has_giftid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetGift::clear_has_giftid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetGift::clear_giftid() {
  if (giftid_ != &::google::protobuf::internal::kEmptyString) {
    giftid_->clear();
  }
  clear_has_giftid();
}
inline const ::std::string& GetGift::giftid() const {
  return *giftid_;
}
inline void GetGift::set_giftid(const ::std::string& value) {
  set_has_giftid();
  if (giftid_ == &::google::protobuf::internal::kEmptyString) {
    giftid_ = new ::std::string;
  }
  giftid_->assign(value);
}
inline void GetGift::set_giftid(const char* value) {
  set_has_giftid();
  if (giftid_ == &::google::protobuf::internal::kEmptyString) {
    giftid_ = new ::std::string;
  }
  giftid_->assign(value);
}
inline void GetGift::set_giftid(const char* value, size_t size) {
  set_has_giftid();
  if (giftid_ == &::google::protobuf::internal::kEmptyString) {
    giftid_ = new ::std::string;
  }
  giftid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetGift::mutable_giftid() {
  set_has_giftid();
  if (giftid_ == &::google::protobuf::internal::kEmptyString) {
    giftid_ = new ::std::string;
  }
  return giftid_;
}
inline ::std::string* GetGift::release_giftid() {
  clear_has_giftid();
  if (giftid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = giftid_;
    giftid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetGift::set_allocated_giftid(::std::string* giftid) {
  if (giftid_ != &::google::protobuf::internal::kEmptyString) {
    delete giftid_;
  }
  if (giftid) {
    set_has_giftid();
    giftid_ = giftid;
  } else {
    clear_has_giftid();
    giftid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GetGiftReply

// optional int32 index = 1;
inline bool GetGiftReply::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetGiftReply::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetGiftReply::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetGiftReply::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 GetGiftReply::index() const {
  return index_;
}
inline void GetGiftReply::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
}

// repeated .com.mservice.momo.msg.Gift gift = 2;
inline int GetGiftReply::gift_size() const {
  return gift_.size();
}
inline void GetGiftReply::clear_gift() {
  gift_.Clear();
}
inline const ::com::mservice::momo::msg::Gift& GetGiftReply::gift(int index) const {
  return gift_.Get(index);
}
inline ::com::mservice::momo::msg::Gift* GetGiftReply::mutable_gift(int index) {
  return gift_.Mutable(index);
}
inline ::com::mservice::momo::msg::Gift* GetGiftReply::add_gift() {
  return gift_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::Gift >&
GetGiftReply::gift() const {
  return gift_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::Gift >*
GetGiftReply::mutable_gift() {
  return &gift_;
}

// -------------------------------------------------------------------

// SetGiftStatus

// optional string giftId = 1;
inline bool SetGiftStatus::has_giftid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetGiftStatus::set_has_giftid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetGiftStatus::clear_has_giftid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetGiftStatus::clear_giftid() {
  if (giftid_ != &::google::protobuf::internal::kEmptyString) {
    giftid_->clear();
  }
  clear_has_giftid();
}
inline const ::std::string& SetGiftStatus::giftid() const {
  return *giftid_;
}
inline void SetGiftStatus::set_giftid(const ::std::string& value) {
  set_has_giftid();
  if (giftid_ == &::google::protobuf::internal::kEmptyString) {
    giftid_ = new ::std::string;
  }
  giftid_->assign(value);
}
inline void SetGiftStatus::set_giftid(const char* value) {
  set_has_giftid();
  if (giftid_ == &::google::protobuf::internal::kEmptyString) {
    giftid_ = new ::std::string;
  }
  giftid_->assign(value);
}
inline void SetGiftStatus::set_giftid(const char* value, size_t size) {
  set_has_giftid();
  if (giftid_ == &::google::protobuf::internal::kEmptyString) {
    giftid_ = new ::std::string;
  }
  giftid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SetGiftStatus::mutable_giftid() {
  set_has_giftid();
  if (giftid_ == &::google::protobuf::internal::kEmptyString) {
    giftid_ = new ::std::string;
  }
  return giftid_;
}
inline ::std::string* SetGiftStatus::release_giftid() {
  clear_has_giftid();
  if (giftid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = giftid_;
    giftid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SetGiftStatus::set_allocated_giftid(::std::string* giftid) {
  if (giftid_ != &::google::protobuf::internal::kEmptyString) {
    delete giftid_;
  }
  if (giftid) {
    set_has_giftid();
    giftid_ = giftid;
  } else {
    clear_has_giftid();
    giftid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SendMessage

// optional int32 toPhone = 1;
inline bool SendMessage::has_tophone() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SendMessage::set_has_tophone() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SendMessage::clear_has_tophone() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SendMessage::clear_tophone() {
  tophone_ = 0;
  clear_has_tophone();
}
inline ::google::protobuf::int32 SendMessage::tophone() const {
  return tophone_;
}
inline void SendMessage::set_tophone(::google::protobuf::int32 value) {
  set_has_tophone();
  tophone_ = value;
}

// optional int64 tranId = 2;
inline bool SendMessage::has_tranid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SendMessage::set_has_tranid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SendMessage::clear_has_tranid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SendMessage::clear_tranid() {
  tranid_ = GOOGLE_LONGLONG(0);
  clear_has_tranid();
}
inline ::google::protobuf::int64 SendMessage::tranid() const {
  return tranid_;
}
inline void SendMessage::set_tranid(::google::protobuf::int64 value) {
  set_has_tranid();
  tranid_ = value;
}

// optional string senderName = 3;
inline bool SendMessage::has_sendername() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SendMessage::set_has_sendername() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SendMessage::clear_has_sendername() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SendMessage::clear_sendername() {
  if (sendername_ != &::google::protobuf::internal::kEmptyString) {
    sendername_->clear();
  }
  clear_has_sendername();
}
inline const ::std::string& SendMessage::sendername() const {
  return *sendername_;
}
inline void SendMessage::set_sendername(const ::std::string& value) {
  set_has_sendername();
  if (sendername_ == &::google::protobuf::internal::kEmptyString) {
    sendername_ = new ::std::string;
  }
  sendername_->assign(value);
}
inline void SendMessage::set_sendername(const char* value) {
  set_has_sendername();
  if (sendername_ == &::google::protobuf::internal::kEmptyString) {
    sendername_ = new ::std::string;
  }
  sendername_->assign(value);
}
inline void SendMessage::set_sendername(const char* value, size_t size) {
  set_has_sendername();
  if (sendername_ == &::google::protobuf::internal::kEmptyString) {
    sendername_ = new ::std::string;
  }
  sendername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SendMessage::mutable_sendername() {
  set_has_sendername();
  if (sendername_ == &::google::protobuf::internal::kEmptyString) {
    sendername_ = new ::std::string;
  }
  return sendername_;
}
inline ::std::string* SendMessage::release_sendername() {
  clear_has_sendername();
  if (sendername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sendername_;
    sendername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SendMessage::set_allocated_sendername(::std::string* sendername) {
  if (sendername_ != &::google::protobuf::internal::kEmptyString) {
    delete sendername_;
  }
  if (sendername) {
    set_has_sendername();
    sendername_ = sendername;
  } else {
    clear_has_sendername();
    sendername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string msg = 4;
inline bool SendMessage::has_msg() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SendMessage::set_has_msg() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SendMessage::clear_has_msg() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SendMessage::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& SendMessage::msg() const {
  return *msg_;
}
inline void SendMessage::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void SendMessage::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void SendMessage::set_msg(const char* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SendMessage::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* SendMessage::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SendMessage::set_allocated_msg(::std::string* msg) {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_;
  }
  if (msg) {
    set_has_msg();
    msg_ = msg;
  } else {
    clear_has_msg();
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 type = 5;
inline bool SendMessage::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SendMessage::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SendMessage::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SendMessage::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 SendMessage::type() const {
  return type_;
}
inline void SendMessage::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// GiftRequest

// optional string giftId = 1;
inline bool GiftRequest::has_giftid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GiftRequest::set_has_giftid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GiftRequest::clear_has_giftid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GiftRequest::clear_giftid() {
  if (giftid_ != &::google::protobuf::internal::kEmptyString) {
    giftid_->clear();
  }
  clear_has_giftid();
}
inline const ::std::string& GiftRequest::giftid() const {
  return *giftid_;
}
inline void GiftRequest::set_giftid(const ::std::string& value) {
  set_has_giftid();
  if (giftid_ == &::google::protobuf::internal::kEmptyString) {
    giftid_ = new ::std::string;
  }
  giftid_->assign(value);
}
inline void GiftRequest::set_giftid(const char* value) {
  set_has_giftid();
  if (giftid_ == &::google::protobuf::internal::kEmptyString) {
    giftid_ = new ::std::string;
  }
  giftid_->assign(value);
}
inline void GiftRequest::set_giftid(const char* value, size_t size) {
  set_has_giftid();
  if (giftid_ == &::google::protobuf::internal::kEmptyString) {
    giftid_ = new ::std::string;
  }
  giftid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GiftRequest::mutable_giftid() {
  set_has_giftid();
  if (giftid_ == &::google::protobuf::internal::kEmptyString) {
    giftid_ = new ::std::string;
  }
  return giftid_;
}
inline ::std::string* GiftRequest::release_giftid() {
  clear_has_giftid();
  if (giftid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = giftid_;
    giftid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GiftRequest::set_allocated_giftid(::std::string* giftid) {
  if (giftid_ != &::google::protobuf::internal::kEmptyString) {
    delete giftid_;
  }
  if (giftid) {
    set_has_giftid();
    giftid_ = giftid;
  } else {
    clear_has_giftid();
    giftid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string serviceId = 2;
inline bool GiftRequest::has_serviceid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GiftRequest::set_has_serviceid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GiftRequest::clear_has_serviceid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GiftRequest::clear_serviceid() {
  if (serviceid_ != &::google::protobuf::internal::kEmptyString) {
    serviceid_->clear();
  }
  clear_has_serviceid();
}
inline const ::std::string& GiftRequest::serviceid() const {
  return *serviceid_;
}
inline void GiftRequest::set_serviceid(const ::std::string& value) {
  set_has_serviceid();
  if (serviceid_ == &::google::protobuf::internal::kEmptyString) {
    serviceid_ = new ::std::string;
  }
  serviceid_->assign(value);
}
inline void GiftRequest::set_serviceid(const char* value) {
  set_has_serviceid();
  if (serviceid_ == &::google::protobuf::internal::kEmptyString) {
    serviceid_ = new ::std::string;
  }
  serviceid_->assign(value);
}
inline void GiftRequest::set_serviceid(const char* value, size_t size) {
  set_has_serviceid();
  if (serviceid_ == &::google::protobuf::internal::kEmptyString) {
    serviceid_ = new ::std::string;
  }
  serviceid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GiftRequest::mutable_serviceid() {
  set_has_serviceid();
  if (serviceid_ == &::google::protobuf::internal::kEmptyString) {
    serviceid_ = new ::std::string;
  }
  return serviceid_;
}
inline ::std::string* GiftRequest::release_serviceid() {
  clear_has_serviceid();
  if (serviceid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serviceid_;
    serviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GiftRequest::set_allocated_serviceid(::std::string* serviceid) {
  if (serviceid_ != &::google::protobuf::internal::kEmptyString) {
    delete serviceid_;
  }
  if (serviceid) {
    set_has_serviceid();
    serviceid_ = serviceid;
  } else {
    clear_has_serviceid();
    serviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GetTranConfirmReply

// optional int64 point = 3;
inline bool GetTranConfirmReply::has_point() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetTranConfirmReply::set_has_point() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetTranConfirmReply::clear_has_point() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetTranConfirmReply::clear_point() {
  point_ = GOOGLE_LONGLONG(0);
  clear_has_point();
}
inline ::google::protobuf::int64 GetTranConfirmReply::point() const {
  return point_;
}
inline void GetTranConfirmReply::set_point(::google::protobuf::int64 value) {
  set_has_point();
  point_ = value;
}

// optional int64 momo = 4;
inline bool GetTranConfirmReply::has_momo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetTranConfirmReply::set_has_momo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetTranConfirmReply::clear_has_momo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetTranConfirmReply::clear_momo() {
  momo_ = GOOGLE_LONGLONG(0);
  clear_has_momo();
}
inline ::google::protobuf::int64 GetTranConfirmReply::momo() const {
  return momo_;
}
inline void GetTranConfirmReply::set_momo(::google::protobuf::int64 value) {
  set_has_momo();
  momo_ = value;
}

// optional int64 gift = 5;
inline bool GetTranConfirmReply::has_gift() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetTranConfirmReply::set_has_gift() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetTranConfirmReply::clear_has_gift() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetTranConfirmReply::clear_gift() {
  gift_ = GOOGLE_LONGLONG(0);
  clear_has_gift();
}
inline ::google::protobuf::int64 GetTranConfirmReply::gift() const {
  return gift_;
}
inline void GetTranConfirmReply::set_gift(::google::protobuf::int64 value) {
  set_has_gift();
  gift_ = value;
}

// -------------------------------------------------------------------

// InfoAlertType

// optional string id = 1;
inline bool InfoAlertType::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InfoAlertType::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InfoAlertType::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InfoAlertType::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& InfoAlertType::id() const {
  return *id_;
}
inline void InfoAlertType::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void InfoAlertType::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void InfoAlertType::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InfoAlertType::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* InfoAlertType::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InfoAlertType::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string desc = 2;
inline bool InfoAlertType::has_desc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InfoAlertType::set_has_desc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InfoAlertType::clear_has_desc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InfoAlertType::clear_desc() {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& InfoAlertType::desc() const {
  return *desc_;
}
inline void InfoAlertType::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void InfoAlertType::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void InfoAlertType::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InfoAlertType::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  return desc_;
}
inline ::std::string* InfoAlertType::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InfoAlertType::set_allocated_desc(::std::string* desc) {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    delete desc_;
  }
  if (desc) {
    set_has_desc();
    desc_ = desc;
  } else {
    clear_has_desc();
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 status = 3;
inline bool InfoAlertType::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InfoAlertType::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InfoAlertType::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InfoAlertType::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 InfoAlertType::status() const {
  return status_;
}
inline void InfoAlertType::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
}

// optional uint64 last_time = 4;
inline bool InfoAlertType::has_last_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InfoAlertType::set_has_last_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InfoAlertType::clear_has_last_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InfoAlertType::clear_last_time() {
  last_time_ = GOOGLE_ULONGLONG(0);
  clear_has_last_time();
}
inline ::google::protobuf::uint64 InfoAlertType::last_time() const {
  return last_time_;
}
inline void InfoAlertType::set_last_time(::google::protobuf::uint64 value) {
  set_has_last_time();
  last_time_ = value;
}

// -------------------------------------------------------------------

// GetAlertType

// optional uint64 last_time = 1;
inline bool GetAlertType::has_last_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetAlertType::set_has_last_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetAlertType::clear_has_last_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetAlertType::clear_last_time() {
  last_time_ = GOOGLE_ULONGLONG(0);
  clear_has_last_time();
}
inline ::google::protobuf::uint64 GetAlertType::last_time() const {
  return last_time_;
}
inline void GetAlertType::set_last_time(::google::protobuf::uint64 value) {
  set_has_last_time();
  last_time_ = value;
}

// -------------------------------------------------------------------

// GetAlertTypeReply

// repeated .com.mservice.momo.msg.InfoAlertType alert_types = 1;
inline int GetAlertTypeReply::alert_types_size() const {
  return alert_types_.size();
}
inline void GetAlertTypeReply::clear_alert_types() {
  alert_types_.Clear();
}
inline const ::com::mservice::momo::msg::InfoAlertType& GetAlertTypeReply::alert_types(int index) const {
  return alert_types_.Get(index);
}
inline ::com::mservice::momo::msg::InfoAlertType* GetAlertTypeReply::mutable_alert_types(int index) {
  return alert_types_.Mutable(index);
}
inline ::com::mservice::momo::msg::InfoAlertType* GetAlertTypeReply::add_alert_types() {
  return alert_types_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::InfoAlertType >&
GetAlertTypeReply::alert_types() const {
  return alert_types_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::mservice::momo::msg::InfoAlertType >*
GetAlertTypeReply::mutable_alert_types() {
  return &alert_types_;
}

// -------------------------------------------------------------------

// InfoAlert

// optional string alert_id = 1;
inline bool InfoAlert::has_alert_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InfoAlert::set_has_alert_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InfoAlert::clear_has_alert_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InfoAlert::clear_alert_id() {
  if (alert_id_ != &::google::protobuf::internal::kEmptyString) {
    alert_id_->clear();
  }
  clear_has_alert_id();
}
inline const ::std::string& InfoAlert::alert_id() const {
  return *alert_id_;
}
inline void InfoAlert::set_alert_id(const ::std::string& value) {
  set_has_alert_id();
  if (alert_id_ == &::google::protobuf::internal::kEmptyString) {
    alert_id_ = new ::std::string;
  }
  alert_id_->assign(value);
}
inline void InfoAlert::set_alert_id(const char* value) {
  set_has_alert_id();
  if (alert_id_ == &::google::protobuf::internal::kEmptyString) {
    alert_id_ = new ::std::string;
  }
  alert_id_->assign(value);
}
inline void InfoAlert::set_alert_id(const char* value, size_t size) {
  set_has_alert_id();
  if (alert_id_ == &::google::protobuf::internal::kEmptyString) {
    alert_id_ = new ::std::string;
  }
  alert_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InfoAlert::mutable_alert_id() {
  set_has_alert_id();
  if (alert_id_ == &::google::protobuf::internal::kEmptyString) {
    alert_id_ = new ::std::string;
  }
  return alert_id_;
}
inline ::std::string* InfoAlert::release_alert_id() {
  clear_has_alert_id();
  if (alert_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = alert_id_;
    alert_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InfoAlert::set_allocated_alert_id(::std::string* alert_id) {
  if (alert_id_ != &::google::protobuf::internal::kEmptyString) {
    delete alert_id_;
  }
  if (alert_id) {
    set_has_alert_id();
    alert_id_ = alert_id;
  } else {
    clear_has_alert_id();
    alert_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 type = 2;
inline bool InfoAlert::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InfoAlert::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InfoAlert::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InfoAlert::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 InfoAlert::type() const {
  return type_;
}
inline void InfoAlert::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional string desc = 3;
inline bool InfoAlert::has_desc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InfoAlert::set_has_desc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InfoAlert::clear_has_desc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InfoAlert::clear_desc() {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& InfoAlert::desc() const {
  return *desc_;
}
inline void InfoAlert::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void InfoAlert::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void InfoAlert::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InfoAlert::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  return desc_;
}
inline ::std::string* InfoAlert::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InfoAlert::set_allocated_desc(::std::string* desc) {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    delete desc_;
  }
  if (desc) {
    set_has_desc();
    desc_ = desc;
  } else {
    clear_has_desc();
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string images = 4;
inline int InfoAlert::images_size() const {
  return images_.size();
}
inline void InfoAlert::clear_images() {
  images_.Clear();
}
inline const ::std::string& InfoAlert::images(int index) const {
  return images_.Get(index);
}
inline ::std::string* InfoAlert::mutable_images(int index) {
  return images_.Mutable(index);
}
inline void InfoAlert::set_images(int index, const ::std::string& value) {
  images_.Mutable(index)->assign(value);
}
inline void InfoAlert::set_images(int index, const char* value) {
  images_.Mutable(index)->assign(value);
}
inline void InfoAlert::set_images(int index, const char* value, size_t size) {
  images_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InfoAlert::add_images() {
  return images_.Add();
}
inline void InfoAlert::add_images(const ::std::string& value) {
  images_.Add()->assign(value);
}
inline void InfoAlert::add_images(const char* value) {
  images_.Add()->assign(value);
}
inline void InfoAlert::add_images(const char* value, size_t size) {
  images_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
InfoAlert::images() const {
  return images_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
InfoAlert::mutable_images() {
  return &images_;
}

// optional string os = 5;
inline bool InfoAlert::has_os() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InfoAlert::set_has_os() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InfoAlert::clear_has_os() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InfoAlert::clear_os() {
  if (os_ != &::google::protobuf::internal::kEmptyString) {
    os_->clear();
  }
  clear_has_os();
}
inline const ::std::string& InfoAlert::os() const {
  return *os_;
}
inline void InfoAlert::set_os(const ::std::string& value) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  os_->assign(value);
}
inline void InfoAlert::set_os(const char* value) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  os_->assign(value);
}
inline void InfoAlert::set_os(const char* value, size_t size) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  os_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InfoAlert::mutable_os() {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  return os_;
}
inline ::std::string* InfoAlert::release_os() {
  clear_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = os_;
    os_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InfoAlert::set_allocated_os(::std::string* os) {
  if (os_ != &::google::protobuf::internal::kEmptyString) {
    delete os_;
  }
  if (os) {
    set_has_os();
    os_ = os;
  } else {
    clear_has_os();
    os_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace msg
}  // namespace momo
}  // namespace mservice
}  // namespace com

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_MomoProto_2eproto__INCLUDED
